# values.secret.json

This is a binary file of the type: Binary

# values-stage.yaml

This is a binary file of the type: Binary

# values-prod.yaml

This is a binary file of the type: Binary

# values-dev.yaml

This is a binary file of the type: Binary

# tsconfig.json

```json
{
  "compilerOptions": {
    "target": "es2017",
    "module": "commonjs",
    "moduleResolution": "node",
    "jsx": "react",
    "declaration": true,
    "experimentalDecorators": true,
    "preserveConstEnums": true,
    "sourceMap": true,
    "noImplicitAny": false,
    "allowSyntheticDefaultImports": false,
    "pretty": true,
    "removeComments": false,
    "lib": [
      "es2017",
      "dom",
      "esnext.asynciterable"
    ],
    "types": [
      "@types/node",
      "@types/jest"
    ]
  },
  "include": [
    "./typings/*.d.ts"
  ]
}
```

# transform.js

```js
const config = {
    babelrc: false,
    presets: ["@babel/preset-env", "@babel/preset-react",
    // ["@babel/preset-typescript", { isTSX: true, allExtensions: true }]
  ],
    plugins: [
      ["@babel/plugin-proposal-class-properties", { loose: true }],
      "@babel/plugin-transform-runtime",
      "@babel/plugin-syntax-dynamic-import",
      "@babel/plugin-proposal-object-rest-spread",
    ],
  };
  module.exports = require("babel-jest").createTransformer(config);
  
```

# prettier.config.js

```js
module.exports = {
    bracketSpacing: true,
    printWidth: 120,
    singleQuote: true,
    tabWidth: 4,
    trailingComma: 'all',
    endOfLine: 'lf',
};

```

# package.json

```json
{
  "name": "sample-stack",
  "version": "0.9.12",
  "private": true,
  "homepage": "https://github.com/cdmbase/fullstack-pro#readme",
  "bugs": {
    "url": "https://github.com/cdmbase/fullstack-pro/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/cdmbase/fullstack-pro.git"
  },
  "license": "MIT",
  "author": {
    "name": "CDMBase LLC",
    "email": "none@cdmbase.com"
  },
  "workspaces": {
    "packages": [
      "portable-devices/*",
      "packages-modules/**",
      "packages/**",
      "servers/*"
    ]
  },
  "scripts": {
    "prebootstrap": "lerna run prepare",
    "bootstrap": "yarn && yarn lerna",
    "postbootstrap": "yarn build",
    "build": "yarn build:packages",
    "build:clean": "lerna exec yarn build:clean",
    "build:packages": "lerna run build --ignore *server --ignore *device --ignore *browser-extension",
    "build:packages:watch": "lerna run build:lib:watch --ignore *server --ignore *device --ignore *browser-extension --stream",
    "check-updates": "lerna exec ./node_modules/.bin/npm-check-updates -- -u",
    "clean": "lerna clean --yes && yarn build:clean && rimraf node_modules",
    "clean:force": "rimraf package-lock.json yarn.lock && yarn clean",
    "clean:install": "yarn clean:force && yarn git:pull && yarn bootstrap",
    "cli": "node tools/cli",
    "commit": "git cz",
    "compile": "lerna exec -- yarn compile",
    "coverage": "jest --coverage",
    "postcoverage": "remap-istanbul --input coverage/coverage.raw.json --type lcovonly --output coverage/lcov.info",
    "db:migrate": "knex migrate:latest --cwd . --knexfile ./servers/backend-server/knexfile.js",
    "db:migrate:rollback": "knex migrate:rollback  --cwd . --knexfile ./servers/backend-server/knexfile.js",
    "db:seed": "yarn db:migrate && knex seed:run  --cwd . --knexfile ./servers/backend-server/knexfile.js",
    "predevpublish": "git checkout devpublish && git pull origin devpublish && git merge -s recursive -X theirs develop -m 'merge from develop' && yarn gitcommit && node tools/update-dependency-version.js && yarn gitcommit",
    "devpublish": "lerna publish prerelease --ignore-scripts --exact",
    "postdevpublish": "git checkout develop",
    "devpublish:auto": "yarn devpublish -- --yes",
    "devpublish:force": "yarn devpublish:forceManual -- --yes",
    "devpublish:forceManual": "yarn devpublish -- --force-publish=*",
    "devpublish:push": "yarn predevpublish && git push origin devpublish && yarn postdevpublish",
    "format": "yarn lint --fix",
    "format:md": "yarn lint:md --fix",
    "generateGraphql": "graphql-codegen",
    "generateGraphql:watch": "yarn generateGraphql -- --watch",
    "git:pull": "git pull origin $(git rev-parse --abbrev-ref HEAD)",
    "gitcommit": "git add -A && git diff --staged --quiet || git commit -am 'auto publish [skip ci] \r\n'",
    "husky-skip": "cross-env HUSKY_SKIP_HOOKS=1",
    "jest": "./node_modules/.bin/jest",
    "lerna": "lerna bootstrap",
    "prelernapublish": "git checkout publish && git pull origin publish  && git merge -s recursive -X theirs master  -m 'merge from master' && yarn gitcommit && node tools/update-dependency-version.js && yarn gitcommit",
    "lernapublish": "lerna publish --ignore-scripts --cd-version=patch",
    "postlernapublish": "git checkout master",
    "lint": "eslint --ext js --ext ts --ext md",
    "lint:ci": "yarn lint . --format junit",
    "lint:fix": "yarn lint -- --fix",
    "lint:md": "markdownlint",
    "lintx": "yarn lint ./packages/**/src/**/*.ts ./packages-modules/**/src/**/*.ts",
    "prodBuild": "cross-env NODE_ENV=production babel-node --presets es2015 tools/webpack.run",
    "publish": "yarn lernapublish",
    "publish:auto": "yarn lernapublish --yes",
    "publish:force": "yarn publish:forceManual --yes",
    "publish:forceManual": "yarn lernapublish --force-publish=*",
    "publish:push": "yarn prelernapublish && git push origin publish && yarn postlernapublish",
    "start": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env yarn zen:watch",
    "start:envSSR": "cross-env SSR=true NODE_ENV=development ENV_FILE=../../config/development/dev.env yarn zen:watch",
    "start:test": "cross-env NODE_ENV=test ENV_FILE=../../config/test/test.env zen watch",
    "test": "cross-env ENV_FILE=config/test/test.env jest",
    "posttest": "yarn lint",
    "test:watch": "npm test -- --watch",
    "pretravis": "yarn compile",
    "travis": "istanbul cover -x \"*.test.js\" _mocha -- --timeout 5000 --full-trace ./test/tests.js",
    "posttravis": "yarn lint",
    "watch": "lerna exec --no-sort --ignore *server --ignore *device --ignore *browser-extension --stream --parallel -- webpack --watch",
    "watch-packages": "lerna exec --no-sort  --scope @sample-stack/platform* --scope @sample-stack/react-shared-components --scope @sample-stack/core --stream --parallel 'webpack --watch'",
    "zen:build": "cross-env NODE_ENV=production zen build",
    "zen:exp": "zen exp",
    "zen:watch": "zen  watch -x",
    "zen:watch:debug": "yarn zen:watch -- -v"
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  },
  "lint-staged": {
    "*.md": [
      "yarn format:md",
      "git add"
    ],
    "*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "git add"
    ]
  },
  "resolutions": {
    "@apollo/client": "~3.3.21",
    "chokidar": "^3.4.0",
    "react": "17.0.1",
    "react-dom": "17.0.1"
  },
  "dependencies": {
    "dataloader": "^2.0.0",
    "graphql": "^14.7.0",
    "graphql-tag": "^2.11.0"
  },
  "devDependencies": {
    "@babel/cli": "^7.7.7",
    "@babel/core": "^7.7.7",
    "@babel/plugin-proposal-class-properties": "^7.7.4",
    "@babel/plugin-proposal-decorators": "^7.7.4",
    "@babel/plugin-proposal-export-default-from": "^7.7.4",
    "@babel/plugin-proposal-export-namespace-from": "^7.7.4",
    "@babel/plugin-proposal-nullish-coalescing-operator": "^7.7.4",
    "@babel/plugin-proposal-object-rest-spread": "^7.7.7",
    "@babel/plugin-proposal-optional-chaining": "^7.7.5",
    "@babel/plugin-proposal-pipeline-operator": "^7.7.7",
    "@babel/plugin-syntax-dynamic-import": "^7.7.4",
    "@babel/plugin-syntax-export-default-from": "^7.7.4",
    "@babel/plugin-syntax-export-namespace-from": "^7.7.4",
    "@babel/plugin-syntax-import-meta": "^7.7.4",
    "@babel/plugin-syntax-numeric-separator": "^7.7.4",
    "@babel/plugin-transform-destructuring": "^7.7.4",
    "@babel/plugin-transform-for-of": "^7.13.0",
    "@babel/plugin-transform-modules-commonjs": "^7.7.5",
    "@babel/plugin-transform-regenerator": "^7.7.5",
    "@babel/plugin-transform-runtime": "^7.7.6",
    "@babel/polyfill": "7.7.0",
    "@babel/preset-env": "^7.7.7",
    "@babel/preset-flow": "^7.7.4",
    "@babel/preset-react": "^7.7.4",
    "@babel/preset-typescript": "^7.7.7",
    "@babel/register": "^7.7.7",
    "@babel/runtime": "^7.7.7",
    "@graphql-codegen/add": "^2.0.2",
    "@graphql-codegen/cli": "^1.21.8",
    "@graphql-codegen/fragment-matcher": "^2.0.1",
    "@graphql-codegen/import-types-preset": "^1.18.6",
    "@graphql-codegen/near-operation-file-preset": "^1.18.6",
    "@graphql-codegen/typescript": "^1.23.0",
    "@graphql-codegen/typescript-graphql-files-modules": "^1.18.1",
    "@graphql-codegen/typescript-operations": "^1.18.4",
    "@graphql-codegen/typescript-react-apollo": "^2.3.1",
    "@graphql-codegen/typescript-resolvers": "^1.20.0",
    "@hot-loader/react-dom": "^17.0.0",
    "@larix/zen": "0.1.37",
    "@open-wc/building-rollup": "^1.10.0",
    "@redux-devtools/core": "^3.9.0",
    "@redux-devtools/dock-monitor": "^1.4.0",
    "@redux-devtools/log-monitor": "^2.3.0",
    "@rollup/plugin-graphql": "1.0.0",
    "@rollup/plugin-image": "^2.0.6",
    "@rollup/plugin-typescript": "^6.1.0",
    "@shelf/jest-mongodb": "^1.1.5",
    "@types/async": "^3.0.3",
    "@types/body-parser": "1.17.1",
    "@types/bunyan": "^1.8.6",
    "@types/classnames": "^2.2.9",
    "@types/cors": "2.8.6",
    "@types/enzyme": "^3.10.4",
    "@types/express": "^4.17.2",
    "@types/hoist-non-react-statics": "^3.3.1",
    "@types/ioredis": "^4.14.4",
    "@types/isomorphic-fetch": "0.0.35",
    "@types/jest": "^26.0.24",
    "@types/lodash-es": "^4.17.3",
    "@types/minimist": "^1.2.0",
    "@types/node": "13.1.0",
    "@types/prop-types": "^15.7.3",
    "@types/react": "^17.0.35",
    "@types/react-dom": "^17.0.11",
    "@types/react-helmet": "^5.0.14",
    "@types/react-loadable": "^5.5.3",
    "@types/react-redux": "^7.1.5",
    "@types/react-router": "^5.1.3",
    "@types/react-router-config": "^5.0.2",
    "@types/react-router-dom": "^5.1.3",
    "@types/react-test-renderer": "^17.0.1",
    "@types/redux-logger": "^3.0.9",
    "@types/semver": "^6.2.0",
    "@types/sinon": "^7.5.1",
    "@types/webpack": "^4.41.0",
    "@types/webpack-env": "^1.14.1",
    "@types/zen-observable": "^0.8.0",
    "@typescript-eslint/eslint-plugin": "^4.20.0",
    "@typescript-eslint/eslint-plugin-tslint": "^4.20.0",
    "@typescript-eslint/parser": "^4.20.0",
    "apollo": "^2.21.2",
    "apollo-server-testing": "^2.21.1",
    "autoprefixer": "^9.7.3",
    "awesome-typescript-loader": "^5.2.1",
    "babel-core": "^7.0.0-bridge.0",
    "babel-eslint": "^10.0.3",
    "babel-jest": "^26.3.0",
    "babel-loader": "^8.0.6",
    "babel-plugin-import": "^1.13.3",
    "caporal": "^1.3.0",
    "chokidar": "^3.4.0",
    "clean-webpack-plugin": "^2.0.0",
    "commitizen": "^4.2.3",
    "concurrently": "^5.0.2",
    "connect": "^3.7.0",
    "copy-webpack-plugin": "^6.4.0",
    "cross-env": "^6.0.3",
    "css-loader": "^3.4.0",
    "csstype": "^2.5.5",
    "dotenv-safe": "^8.2.0",
    "dotenv-webpack": "^6.0.0",
    "envalid": "^7.2.2",
    "enzyme": "^3.11.0",
    "enzyme-adapter-react-16": "^1.15.2",
    "eslint": "^7.23.0",
    "eslint-config-airbnb-typescript": "^12.3.1",
    "eslint-config-prettier": "^8.1.0",
    "eslint-loader": "^4.0.2",
    "eslint-plugin-graphql": "^4.0.0",
    "eslint-plugin-import": "^2.22.1",
    "eslint-plugin-jest": "^24.3.3",
    "eslint-plugin-jsdoc": "^32.3.0",
    "eslint-plugin-jsx-a11y": "^6.4.1",
    "eslint-plugin-markdown": "^2.0.1",
    "eslint-plugin-no-null": "^1.0.2",
    "eslint-plugin-prettier": "^3.3.1",
    "eslint-plugin-react": "^7.23.1",
    "eslint-plugin-react-hooks": "^4.2.0",
    "eslint-plugin-simple-import-sort": "^7.0.0",
    "express": "^4.17.1",
    "extract-text-webpack-plugin": "^4.0.0-beta.0",
    "file-loader": "^5.0.2",
    "freeport-async": "^2.0.0",
    "fs-extra": "^8.1.0",
    "html-loader": "^0.5.5",
    "html-webpack-plugin": "^3.2.0",
    "http-proxy-middleware": "^0.20.0",
    "husky": "^5.0.9",
    "ignore-loader": "^0.1.2",
    "image-size": "^0.8.3",
    "ip": "^1.1.5",
    "isomorphic-style-loader": "^5.1.0",
    "istanbul": "1.0.0-alpha.2",
    "jest": "^26.0.0",
    "jest-css-modules-transform": "^3.1.0",
    "jest-dom": "^4.0.0",
    "jest-junit": "^12.2.0",
    "jest-matcher-utils": "^26.0.0",
    "jest-raw-loader": "^1.0.1",
    "jest-transform-graphql": "^2.1.0",
    "jsdom": "^15.2.1",
    "lerna": "^4.0.0",
    "lint-staged": "^9.5.0",
    "lodash": "^4.17.15",
    "lodash-es": "^4.17.15",
    "lodash-webpack-plugin": "^0.11.5",
    "markdownlint-cli": "^0.27.0",
    "merge": "^1.2.1",
    "mime": "^2.4.4",
    "mini-css-extract-plugin": "^0.9.0",
    "minilog": "^3.1.0",
    "mkdirp": "^0.5.1",
    "mocha": "^6.2.2",
    "mocha-steps": "^1.3.0",
    "module": "^1.2.5",
    "morgan": "^1.9.1",
    "nock": "^11.7.0",
    "node-dev": "^4.0.0",
    "node-sass": "^4.13.0",
    "nodemon": "^2.0.2",
    "openurl": "^1.1.1",
    "pm2": "^4.2.1",
    "postcss-loader": "^3.0.0",
    "prettier": "^2.2.1",
    "qrcode-terminal": "^0.12.0",
    "raw-loader": "^4.0.0",
    "react-addons-test-utils": "^16.0.0-alpha.3",
    "react-hot-loader": "^4.12.18",
    "react-test-renderer": "^16.12.0",
    "redux-devtools-extension": "^2.13.8",
    "redux-mock-store": "^1.5.4",
    "remap-istanbul": "^0.13.0",
    "resolve-url-loader": "^3.1.1",
    "rimraf": "^3.0.0",
    "rollup": "^2.53.2",
    "rollup-plugin-string": "^3.0.0",
    "sass-loader": "^8.0.0",
    "shelljs": "^0.8.3",
    "simple-git": "^2.42.0",
    "sinon": "^8.0.1",
    "source-list-map": "^2.0.1",
    "source-map-loader": "^0.2.4",
    "source-map-support": "^0.5.16",
    "standard-version": "^7.0.1",
    "style-loader": "^1.1.1",
    "svg-url-loader": "^3.0.3",
    "tcomb": "^3.2.29",
    "ts-jest": "^26.0.0",
    "ts-loader": "^6.2.1",
    "ts-node": "^8.5.4",
    "tslib": "^1.10.0",
    "tslint": "^6.1.3",
    "typedoc": "^0.15.5",
    "typescript": "4.2.3",
    "uglify-es": "^3.3.9",
    "uglifyjs-webpack-plugin": "^2.2.0",
    "url-loader": "^3.0.0",
    "wait-on": "^4.0.0",
    "webpack": "4.46.0",
    "webpack-bundle-analyzer": "^4.5.0",
    "webpack-cli": "^3.3.10",
    "webpack-dev-middleware": "^4.1.0",
    "webpack-dev-server": "^3.11.2",
    "webpack-hot-middleware": "^2.25.0",
    "webpack-manifest-plugin": "^2.2.0",
    "webpack-merge": "^5.4.0",
    "webpack-node-externals": "^3.0.0",
    "webpack-sources": "^1.4.3",
    "webpack-virtual-modules": "^0.4.3",
    "ws": "^7.2.1"
  },
  "engines": {
    "node": ">=12.18.4 < 15.0.0",
    "yarn": ">=1.22"
  },
  "cacheDirectories": [
    ".cache"
  ],
  "packageManager": "yarn@1.22.22+sha512.a6b2f7906b721bba3d67d4aff083df04dad64c399707841b7acf00f6b133b7ac24255f2652fa22ae3534329dc6180534e98d17432037ff6fd140556e2bb3137e"
}

```

# lint-staged.config.js

```js
module.exports = {
    '*.{js,jsx,ts,tsx,json,md}': ['prettier --write', 'git add'],
    // '*.{ts,tsx}': ['eslint --fix'], // this can be tested
};
```

# lerna.json

```json
{
  "changelog": {
    "repo": "cdmbase/lerna-bootstrap",
    "labels": {
      "tag: breaking change": ":boom: Breaking Change",
      "tag: new feature": ":rocket: New Feature",
      "tag: bug fix": ":bug: Bug Fix",
      "tag: polish": ":nail_care: Polish",
      "tag: documentation": "Documentation",
      "tag: internal": ":house: Internal"
    }
  },
  "command": {
    "publish": {
      "registry": "https://registry.npmjs.org",
      "graphType": "all",
      "allowBranch": [
        "publish",
        "devpublish"
      ],
      "message": "chore(release): publish",
      "ignoreChanges": [
        "**/__fixtures__/**",
        "**/__tests__/**",
        "**/*.md",
        "**/example/**"
      ]
    },
    "version": {
      "allowBranch": [
        "master",
        "develop",
        "publish",
        "devpublish"
      ],
      "conventionalCommits": true,
      "message": "chore: release package(s)"
    }
  },
  "npmClient": "yarn",
  "useWorkspaces": true,
  "packages": [
    "packages-modules/**",
    "packages/**",
    "servers/*",
    "portable-devices/*"
  ],
  "version": "0.0.0"
}
```

# jest.config.mongodb.js

```js
module.exports = {
    preset: '@shelf/jest-mongodb',
};

```

# jest.config.js

```js
const merge = require('merge')
const baseConfig = require('./jest.config.base');
const mongodbConfig = require('./jest.config.mongodb')
module.exports = merge.recursive(
    baseConfig,
    mongodbConfig,
    {
        globals: {

        }
    },
    // https://baltuta.eu/posts/typescript-lerna-monorepo-more-tools 
    // {
    //     roots: ['<rootDir>'],
    //     projects: [
    //         '<rootDir>/packages/ui',
    //         '<rootDir>/packages/api',
    //         '<rootDir>/packages/diceroll'
    //     ],
    // }

);
```

# jest.config.base.js

```js
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable @typescript-eslint/no-var-requires */
const { defaults } = require('jest-config');

module.exports = {
    testEnvironment: 'node',
    setupFiles: [
        // needed for UI to mock canvas load
        // "jest-canvas-mock"
    ],
    preset: 'ts-jest',
    testMatch: null,
    testRegex: '.*test*\\.(ts|tsx|js)$',
    testPathIgnorePatterns: ['/node_modules/', '/dist/'],
    transform: {
        '\\.(gql)$': 'jest-transform-graphql',
        '\\.(graphql|graphqls)$': 'jest-raw-loader',
        '\\.(ts|tsx)$': 'ts-jest',
        // Use our custom transformer only for the *.js and *.jsx files
        '\\.(js|jsx)?$': './transform.js',
        // future need to test with
        //  "^.+\\.(js|jsx|ts|tsx)$": "./transform.js",
        '.+\\.(css|styl|less|sass|scss)$': 'jest-css-modules-transform',
    },
    roots: ['packages', 'packages-modules', 'servers'],
    moduleFileExtensions: [
        'tsx', // TODO can be removed as default extension includes
        'ts', // TODO can be removed as default extension includes
        ...defaults.moduleFileExtensions,
        'js', // TODO can be removed as default extension includes
        'jsx', // TODO can be removed as default extension includes
        'json',
        'gql',
        'graphql',
    ],
    moduleNameMapper: {
        '^__mocks__/(.*)$': '<rootDir>/../../__mocks__/$1',
        // we'll use commonjs version of lodash for tests 👌
        // because we don't need to use any kind of tree shaking right?!
        '^lodash-es$': '<rootDir>/node_modules/lodash/index.js',
    },
    transformIgnorePatterns: ['/node_modules/(?!(babel-runtime|antd)).*/', '<rootDir>/node_modules/(?!lodash-es/.*)'],
    clearMocks: true,
    verbose: true,
    // projects: ['<rootDir>'], // TODO need to test with it https://github.com/bryan-hunter/yarn-workspace-lerna-monorepo/blob/master/jest.config.base.js
    coverageDirectory: '<rootDir>/coverage/',
    coveragePathIgnorePatterns: ['<rootDir>/build/', '<rootDir>/lib/', '<rootDir>/dist/', '<rootDir>/node_modules/'],
    globals: {
        __BACKEND_URL__: 'http://localhost:3010',
        __GRAPHQL_URL__: 'http://localhost:8085/graphql',
        'ts-jest': {
            // tsConfig: "<rootDir>/src/__tests__/tsconfig.json",
            // https://github.com/kulshekhar/ts-jest/issues/766
            diagnostics: {
                warnOnly: true,
            },
            // "skipBabel": true
        },
    },
};

```

# jest-transform-i18next.js

```js
const fs = require('fs');
const path = require('path');

module.exports = {
    process() {
        const pathname = arguments[1];
        const dir = path.dirname(pathname);
        const locales = fs.readdirSync(dir);
        const result = {};
        for (const locale of locales) {
            if (fs.statSync(path.join(dir, locale)).isDirectory()) {
                const localeFiles = fs.readdirSync(path.join(dir, locale));
                for (const localeFile of localeFiles) {
                    if (localeFile.indexOf('.json') >= 0) {
                        result[locale] = JSON.parse(fs.readFileSync(path.join(dir, locale, localeFile), 'utf8'));
                    }
                }
            }
        }
        return {
            code: `module.exports = ${JSON.stringify(result)};`,
        };
    },
};

```

# jest-mongodb-config.js

```js
module.exports = {
    mongodbMemoryServerOptions: {
      instance: {
        dbName: 'jest'
      },
      binary: {
        version: '4.0.12', // Version of MongoDB
        skipMD5: true
      },
      autoStart: false
    }
  };
```

# jenkins_variables.groovy

```groovy
import groovy.json.JsonSlurper

def getVersion(json_file_path){
  def inputFile = readFile(json_file_path)
  def InputJSON = new JsonSlurper().parseText(inputFile)
  def version = InputJSON.version
return version
}

def getName(json_file_path){
  def inputFile = readFile(json_file_path)
  def InputJSON = new JsonSlurper().parseText(inputFile)
  def name = InputJSON.name
return name
}

def getSecrets(json_file_path, env, var){
  def inputFile = new File(json_file_path)
  def InputJSON = new JsonSlurper().parse(inputFile)
  def secret = InputJSON."${env}"."${var}"
return secret
}

```

# husky.config.js

```js
module.exports = {
    hooks: {
        'pre-commit': 'lint-staged',
        //'pre-push': 'yarn test', // when production ready
    },
};
```

# commitlint.config.js

```js
module.exports = {
    extends: ['@commitlint/config-conventional'],
    rules: {
        'header-max-length': [0, 'always', 100], // corresponding to maxHeaderWidth of commitizen
    },
};

```

# combined_repo.md

```md
# Repo as one markdown file

This file was generated by the repo-to-one-file package, find it here: 

 [GitHub](https://github.com/tonypls/repo-to-one-file-cli) 

 [NPM](https://www.npmjs.com/package/repo-to-one-file)

# Directory Structure

\`\`\`
.browserslistrc
.eslintignore
.eslintrc.js
.markdownlint.json
.markdownlintignore
.npmrc
.travis.yml
.vscode/
  extensions.json
  launch.json
  settings.json
CHANGELOG.md
CODE_OF_CONDUCT.md
Dockerfile
ISSUES.md
Jenkinsfile
LICENSE
README.md
ScreenShot.png
babel.config.js
codegen.yml
commitlint.config.js
config/
  development/
    settings.json
  production/
  staging/
  test/
docs/
  Moleculer.md
  References.md
  development/
    CodeContribution/
      Adding_New_Modules.md
      Desktop_Setup.md
      DoAndDont.md
      GitHooks.md
      HowToContribute.md
      How_to_Run_Various_Options.md
      Known_Issues.md
      Lint_And_Formatter.md
      Project_Setup.md
      React-Patterns/
        Dynamically_Render_Components.md
        HOC_With_Render_Props.md
        Mongoose_Connection.md
        React_Componet_Extensions.md
        RxJS_notes.md
        Styles_With_Type.md
      Tutorials.md
      faq.md
      installation_issues.md
      lerna-yarn-workspaces.md
    Database/
      mongodb-test.md
    Deployment/
      How_To_Setup_Jenkins.md
      JenkinsDeployment.md
    Mobile/
      How_To_Make_Expo_Wrok_With_Monorepos.md
      React-Native-FAQ.md
      Run_mobile.md
husky.config.js
jenkins_variables.groovy
jest-mongodb-config.js
jest-transform-i18next.js
jest.config.base.js
jest.config.js
jest.config.mongodb.js
lerna.json
lint-staged.config.js
package.json
packages/
  sample-core/
    .npmignore
    README.md
    jest.config.js
    package.json
    src/
      index.ts
    tsconfig.json
    webpack.config.js
  sample-platform/
    browser/
      jest.config.js
      package.json
      src/
        api.ts
        components/
          Counter.tsx
          NavBar.tsx
          index.ts
        containers/
          Clock.tsx
          Counter.tsx
          Loading.tsx
          PersonList.tsx
          ServerCounter.tsx
          __tests__/
            ApolloProvider.test.tsx
            Counter.test.tsx
            PersonList.test.tsx
            __snapshots__/
              Counter.test.tsx.snap
              PersonList.test.tsx.snap
            redux.test.tsx
            setup.ts
            utils.ts
          index.ts
        graphql/
          index.ts
          mutations/
            addCount.graphql
            addPerson.graphql
            index.ts
          queries/
            count.graphql
            index.ts
            person.graphql
            persons.graphql
          subscriptions/
            count.graphql
            index.ts
        index.ts
        inversify-containers/
          index.ts
          module.ts
        module.ts
        redux/
          __mocks__/
            api.ts
          actions/
            __tests__/
              sampleActions.test.ts
            index.ts
            sampleActions.ts
          index.ts
          reducers/
            Store.ts
            __tests__/
              sampleReducers.test.ts
            index.ts
            sampleReducers.ts
        services/
          index.ts
      tsconfig.json
      webpack.config.js
    server/
      .npmignore
      README.md
      jest.config.js
      package.json
      src/
        index.ts
      tsconfig.json
      webpack.config.js
  sample-store/
    .npmignore
    README.md
    package.json
    src/
      __tests__/
        counter-hemera-repository.test.ts
        counter-repository.test.ts
        db/
          config.json
          migrations/
            counter.ts
          seeds/
            counter.ts
      constants/
        constants.ts
        index.ts
      container/
        index.ts
        module.ts
      database-store/
        migrations/
          counter.ts
          index.ts
        seeds/
          counter.ts
          index.ts
      db-helpers/
        abstract-repository.ts
        db-config.ts
        entity.ts
        index.ts
        repository.ts
      index.ts
      models/
        counter.ts
        index.ts
        interfaces/
          count-model.ts
          index.ts
      repository/
        counter-hemera-repository.ts
        counter-repository.ts
        index.ts
        interfaces/
          counter-repository.ts
          index.ts
    tsconfig.json
    webpack.config.js
packages-modules/
  counter/
    browser/
      jest.config.js
      package.json
      rollup.config.js
      src/
        apollo-server-n-client/
          components/
            CounterView.tsx
          compute.tsx
          containers/
            Counter.tsx
          generated-model.tsx
          graphql/
            __tests__/
              apollo-client-test-helper.ts
              apollo-client.test.ts
            id-generation.ts
            index.ts
            mutations/
              AddCounter.client.gql
              AddCounter.gql
              AddCounter_WS.gql
              SyncCachedCounter.gql
            queries/
              CounterCacheQuery_WS.gql
              CounterQuery.client.gql
              CounterQuery.gql
            resolvers/
              index.ts
              resolvers.ts
            schema/
              counter-state.graphql
            subscriptions/
              CounterSubscription.gql
          index.ts
          module.tsx
          redux/
            index.ts
            reducers/
              index.ts
        common/
          components/
            Dashboard.tsx
            Home.tsx
          compute.tsx
          generated-models.ts
          index.ts
          interfaces/
            context.ts
          module.tsx
        connected-react-router/
          README.md
          __tests__/
            __snapshots__/
              connected-react-router-module.test.ts.snap
            connected-react-router-module.test.ts
          components/
            Counter.tsx
            Hello.tsx
            HelloChild.tsx
            Home.tsx
            NavBar.tsx
            NoMatch.tsx
          compute.tsx
          constants/
            action-types.ts
            index.ts
            routes-types.ts
          electron-module.tsx
          index.electron.ts
          index.ts
          interfaces/
            index.ts
            state.ts
          module.tsx
          redux/
            actions/
              counter.ts
              index.ts
            index.ts
            reducers/
              counter.ts
              index.ts
        fela/
          README.md
          components/
            CompledWithTheme.tsx
            ComplexComponent.tsx
            index.ts
          compute.tsx
          index.ts
          interfaces/
            index.ts
            theme.ts
          module.tsx
          theme.ts
        generated-models.ts
        index.ts
        utils/
          index.ts
          menu.ts
      tsconfig.json
      typings/
        graphql.d.ts
      webpack.config.js
    electron/
      jest.config.js
      package.json
      rollup.config.js
      src/
        epics/
          count-tray-updater.ts
          index.ts
        index.ts
      tsconfig.json
      typings/
        graphql.d.ts
      webpack.config.js
    mobile/
      jest.config.js
      package.json
      src/
        common/
          components/
            Dashboard.tsx
            Home.tsx
          compute.tsx
          generated-models.ts
          index.ts
          interfaces/
            context.ts
          module.tsx
        connected-react-router/
          README.md
          components/
            Counter.tsx
            Hello.tsx
          compute.tsx
          constants/
            action-types.ts
            index.ts
            routes-types.ts
          index.ts
          interfaces/
            index.ts
            state.ts
          module.tsx
          redux/
            actions/
              counter.ts
              index.ts
            index.ts
            reducers/
              counter.ts
              index.ts
        index.ts
        utils/
          index.ts
          menu.ts
      tsconfig.json
      typings/
        graphql.d.ts
    server/
      jest.config.js
      package.json
      src/
        config/
          config.ts
          index.ts
        constants/
          constants.ts
          index.ts
        containers/
          containers.ts
          index.ts
        dataloader/
          cache.ts
          counter-dataloader.ts
          index.ts
        generated-models.ts
        graphqlTypes/
          index.ts
          resolvers.ts
          schema.graphql
        index.ts
        interfaces/
          context.ts
          counter-service.ts
          index.ts
        module.ts
        resolvers/
          index.ts
          resolver.ts
        schema/
          schema.graphql
        services/
          counter-mock-microservice.ts
          counter-mock-moleculer-service.ts
          counter-mock-proxy-service.ts
          counter-mock-service.ts
          index.ts
      tsconfig.json
      webpack.config.js
portable-devices/
  desktop/
    assets/
      entitlements.mac.plist
      html/
        about-page.html
        main-page.html
        tray-page.html
      icon.icns
      icon.ico
      icon.png
      icon.svg
      icons/
        1024x1024.png
        128x128.png
        16x16.png
        24x24.png
        256x256.png
        32x32.png
        48x48.png
        512x512.png
        64x64.png
        96x96.png
        icon-22.png
        icon-256.png
      preload.js
    electron-webpack.json
    jest.config.js
    package.json
    src/
      common/
        channel.ts
        config/
          base-apollo-client.ts
          base-redux-config.ts
          config.ts
        constants/
          index.ts
          ipcEvents.ts
        index.ts
        utils/
          index.ts
          is.ts
          logger.ts
      main/
        app/
          App.ts
          Service.ts
          View.ts
          index.ts
        bootstrap.ts
        config/
          client.service.ts
          epic-config.ts
          redux-electron-config.ts
        index.ts
        interfaces/
          index.ts
          tray-icon.ts
          tray-window.ts
        ioc/
          index.ts
          inversify.config.ts
          loader.ts
          types.ts
        menu-template.ts
        models/
          User.ts
          index.ts
        modules/
          index.ts
          module.ts
        services/
          Logger.ts
          System.ts
          User.ts
          index.ts
        utils/
          AutoUpdater.ts
          createProtocol.ts
          index.ts
          ioc.ts
          logger/
            customLogger.ts
            index.ts
            logDecorator.ts
          sqlite/
            connection.ts
          window/
            devTools.ts
            index.ts
            protocol.ts
        views/
          about.ts
          index.ts
          main.ts
          tray.ts
      renderer/
        about.tsx
        app/
          500.tsx
          About.tsx
          ErrorBoundary.tsx
          Main.tsx
          ServerError.tsx
          Tray.tsx
        components/
          WindowHeader.tsx
          layout/
            components/
              SideMenu.tsx
              index.ts
            index.ts
        config/
          config.ts
          index.ts
          main/
            client.service.ts
            epic-config.ts
            fela-renderer.ts
            redux-config.ts
          public-config.ts
          router-history.ts
          tray/
            client.service.ts
            epic-config.ts
            fela-renderer.ts
            redux-config.ts
        main.tsx
        modules/
          main/
            index.ts
            module.tsx
          tray/
            index.ts
            module.tsx
        tray-main.tsx
    tools/
      esm-wrapper.js
      utils.js
    tsconfig.json
    webpack.main.additions.js
    webpack.renderer.additions.js
  mobile/
    .exprc
    App.tsx
    __generated__/
      AppEntry.js
    app.json
    assets/
      fonts/
        SpaceMono-Regular.ttf
      images/
        adaptive-icon.png
        favicon.png
        icon.png
        splash.png
    babel.config.js
    eas.json
    index.js
    jest.config.js
    metro.config.js
    package.json
    src/
      App.tsx
      assets/
        fonts/
          SpaceMono-Regular.ttf
        images/
          adaptive-icon.png
          favicon.png
          icon.png
          splash.png
      components/
        __tests__/
          StyledText-test.js
        layout/
          Drawer.tsx
          Header.tsx
          Layout.tsx
          NativeBaseIcon.tsx
          NativeBaseSample.tsx
          SideBar.tsx
          module.ts
          root-navigation.tsx
      config/
        base-apollo-client.ts
        base-redux-config.ts
        client.service.ts
        config.ts
        epic-config.ts
        fela-renderer.ts
        index.ts
        public-config.ts
        redux-config.ts
        router-history.ts
      constants/
        Colors.ts
        Layout.ts
      hooks/
        useCachedResources.ts
        useColorScheme.ts
        useColorScheme.web.ts
      modules/
        index.ts
        modules.tsx
        render.tsx
      pages/
        dashboard.tsx
        hello.tsx
        index.ts
      screens/
        NotFoundScreen.tsx
    tsconfig.json
    types.tsx
    webpack.config.js
prettier.config.js
servers/
  backend-server/
    .dockerignore
    .npmignore
    .npmrc
    .zenrc.js
    CHANGELOG.md
    Dockerfile
    LICENSE
    README.md
    generated-schema.graphql
    knexfile.js
    package.json
    src/
      api/
        remote-config.ts
        resolver.ts
        root-schema.graphqls
        scalar.ts
      config/
        config.ts
        index.ts
        moleculer.config.ts
      connectors/
        connection-broker.ts
        graphql-pubsub-connector.ts
        mongo-connector.ts
        nats-connector.ts
        redis-connector.ts
      constants/
        ENDPOINTS.ts
        index.ts
      express-app.ts
      index.ts
      interfaces/
        index.ts
        module-interface.ts
      main.spec.ts
      middleware/
        cors.ts
        error.ts
        moleculer-inter-namespace.ts
        persistedQuery.ts
        services.ts
      modules/
        index.ts
        module.ts
      server-setup/
        graphql-server.ts
        graphql-subscription-server.ts
        websocket-multipath-update.ts
      service.ts
      stack-server.ts
      utils/
        migrations.ts
    tsconfig.json
    webpack.config.lint.js
  frontend-server/
    .browserslistrc
    .dockerignore
    .npmignore
    .npmrc
    .zenrc.js
    Dockerfile
    package.json
    src/
      app/
        500.tsx
        ErrorBoundary.tsx
        Main.tsx
        ServerError.tsx
      backend/
        app.ts
        middlewares/
          cors.ts
          error.ts
        modules/
          index.ts
          modules.ts
        server.ts
        ssr/
          html.tsx
        website.tsx
      config/
        __mocks__/
          mockFetch.ts
          mockWatchQuery.ts
        __tests__/
          apollo-client-subscribe-to-more.ts
        base-apollo-client.ts
        base-redux-config.ts
        client.service.ts
        config.ts
        epic-config.ts
        fela-renderer.ts
        index.ts
        public-config.ts
        redux-config.ts
        router-history.ts
      index.tsx
      modules/
        index.ts
        layout/
          components/
            SideMenu.tsx
            index.ts
          index.ts
        module.tsx
      postcss.config.js
    tools/
      webpackAppConfig.js
    tsconfig.json
    webpack.config.lint.js
  moleculer-server/
    .dockerignore
    .draft-tasks.toml
    .draftignore
    .npmrc
    .vscode/
      launch.json
    Dockerfile
    README.md
    charts/
      chart/
        .helmignore
        Chart.yaml
        templates/
          NOTES.txt
          _helpers.tpl
          deployment.yaml
          ingress.yaml
          mongodb-external-service.yaml
          nats-external-service.yaml
          redis-external-service.yaml
          service.yaml
        values-dev.yaml
        values-prod.yaml
        values-stage.yaml
        values.yaml
    draft.toml
    package.json
    src/
      config/
        config.ts
        index.ts
        moleculer.config.ts
      connectors/
        connection-broker.ts
        graphql-pubsub-connector.ts
        mongo-connector.ts
        nats-connector.ts
        redis-connector.ts
      index.ts
      modules/
        index.ts
        module.ts
      stack-server.ts
      test/
        unit/
          greeter.spec.ts
    tsconfig.json
    webpack.config.js
tools/
  .eslintrc
  cli/
    command-invoker.js
    commands/
      add-module.js
      delete-module.js
    config.js
    helpers/
      util.js
  cli.js
  esm-wrapper.js
  get-symlinked-modules.js
  html-plugin-template.ejs
  templates/
    module/
      browser/
        package.json
        src/
          constants/
            constants.ts
            index.ts
          graphql/
            index.ts
            link/
              index.ts
            mutations/
              index.ts
            queries/
              index.ts
              module-query.gql
            schema.ts
          index.tsx
          locales/
            en/
              translations.json
            index.ts
            ru/
              translations.json
          module.tsx
          selectors/
            index.ts
          utils/
            index.ts
        tsconfig.json
        webpack.config.js
      server/
        package.json
        src/
          config/
            index.ts
          constants/
            index.ts
            types.ts
          containers/
            index.ts
            module.ts
          index.ts
          interfaces/
            index.ts
          module.ts
          plugin/
            index.ts
          services/
            index.ts
        tsconfig.json
        webpack.config.js
  update-dependency-version.js
  webpack-util.js
  webpackAppConfig.js
transform.js
tsconfig.json
typings/
  graphql.d.ts
  index.d.ts
values-dev.yaml
values-prod.yaml
values-stage.yaml
values.secret.json
\`\`\`

## README.md

\`\`\`md
# Full Stack Packages

*Fullstack packages to develop and test end to end; to use as packages or work independently.*

Purpose: 
---
The idea is to create modules for each package so it can work independently as well as integrated to another project as packages. 

## Screenshot
![screencast](./ScreenShot.png)


Useful commands:
---
|command|Description|
|--------------------------|-----------|    
|`lerna clean`|                 - removes the node_modules directory from all packages. |
|`npm start`|       - starts the web server and backend server. Or Use `yarn zen:watch`|
|`yarn zen:watch`|         - starts the web server and backend server in watch mode.|
|`yarn zen:watch:debug`|    - starts the web server and backend server in debug and watch mode.|
|`yarn watch`|               - build the packages in watchmode (Useful for development)|
|`yarn lerna`|               - install external dependencies at the repo root so they're |`lable to all packages.|
|`yarn build`|               - build all the packages|
|`yarn install`|                - runs `lerna` and `build`|
|`lerna publish`|               - publishes packages in the current Lerna project. |

Files explained:
---    
It uses `lerna.json` for creating the packages structure. Under packages you can create different modules based on its usage. For example:

     packages                    - Has the packages to organize the codebase into multi-package repositories.
         sample-core             - Core interfaces of the packages which can be shared between server and client.
         sample-platform/server      - Core platform interfaces and its implementation code for Server.   
         sample-platform/browser     - Core platform browser State related code which consists of Redux, Graphql Gql and UI Components.
         sample-platform/react-shared-components     - React pure components and containers are defined. 
     packages-modules            - Has the server and browser side packages designed for a specific module feature.
     servers                     - Has the servers to organize the codebase into multi-package repositories.
         frontend-server         - Frontend Client Server. This is useful to show demo of this package.
         backend-server          - Backend apollo server. 
    

## [Click here for Project Setup](docs/development/CodeContribution/Project_Setup.md)

In Order to get started with the development you need to go through the 
documentation first

- [Getting Started with lerna](./docs/development/CodeContribution/lerna-build-tools.md)
- [Running the servers](./docs/development/CodeContribution/How_to_Run_Various_Options.md)
- [Dos and Dont](./docs/development/CodeContribution/DoAndDont.md)


\`\`\`

## package.json

\`\`\`json
{
  "name": "sample-stack",
  "version": "0.9.12",
  "private": true,
  "homepage": "https://github.com/cdmbase/fullstack-pro#readme",
  "bugs": {
    "url": "https://github.com/cdmbase/fullstack-pro/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/cdmbase/fullstack-pro.git"
  },
  "license": "MIT",
  "author": {
    "name": "CDMBase LLC",
    "email": "none@cdmbase.com"
  },
  "workspaces": {
    "packages": [
      "portable-devices/*",
      "packages-modules/**",
      "packages/**",
      "servers/*"
    ]
  },
  "scripts": {
    "prebootstrap": "lerna run prepare",
    "bootstrap": "yarn && yarn lerna",
    "postbootstrap": "yarn build",
    "build": "yarn build:packages",
    "build:clean": "lerna exec yarn build:clean",
    "build:packages": "lerna run build --ignore *server --ignore *device --ignore *browser-extension",
    "build:packages:watch": "lerna run build:lib:watch --ignore *server --ignore *device --ignore *browser-extension --stream",
    "check-updates": "lerna exec ./node_modules/.bin/npm-check-updates -- -u",
    "clean": "lerna clean --yes && yarn build:clean && rimraf node_modules",
    "clean:force": "rimraf package-lock.json yarn.lock && yarn clean",
    "clean:install": "yarn clean:force && yarn git:pull && yarn bootstrap",
    "cli": "node tools/cli",
    "commit": "git cz",
    "compile": "lerna exec -- yarn compile",
    "coverage": "jest --coverage",
    "postcoverage": "remap-istanbul --input coverage/coverage.raw.json --type lcovonly --output coverage/lcov.info",
    "db:migrate": "knex migrate:latest --cwd . --knexfile ./servers/backend-server/knexfile.js",
    "db:migrate:rollback": "knex migrate:rollback  --cwd . --knexfile ./servers/backend-server/knexfile.js",
    "db:seed": "yarn db:migrate && knex seed:run  --cwd . --knexfile ./servers/backend-server/knexfile.js",
    "predevpublish": "git checkout devpublish && git pull origin devpublish && git merge -s recursive -X theirs develop -m 'merge from develop' && yarn gitcommit && node tools/update-dependency-version.js && yarn gitcommit",
    "devpublish": "lerna publish prerelease --ignore-scripts --exact",
    "postdevpublish": "git checkout develop",
    "devpublish:auto": "yarn devpublish -- --yes",
    "devpublish:force": "yarn devpublish:forceManual -- --yes",
    "devpublish:forceManual": "yarn devpublish -- --force-publish=*",
    "devpublish:push": "yarn predevpublish && git push origin devpublish && yarn postdevpublish",
    "format": "yarn lint --fix",
    "format:md": "yarn lint:md --fix",
    "generateGraphql": "graphql-codegen",
    "generateGraphql:watch": "yarn generateGraphql -- --watch",
    "git:pull": "git pull origin $(git rev-parse --abbrev-ref HEAD)",
    "gitcommit": "git add -A && git diff --staged --quiet || git commit -am 'auto publish [skip ci] \r\n'",
    "husky-skip": "cross-env HUSKY_SKIP_HOOKS=1",
    "jest": "./node_modules/.bin/jest",
    "lerna": "lerna bootstrap",
    "prelernapublish": "git checkout publish && git pull origin publish  && git merge -s recursive -X theirs master  -m 'merge from master' && yarn gitcommit && node tools/update-dependency-version.js && yarn gitcommit",
    "lernapublish": "lerna publish --ignore-scripts --cd-version=patch",
    "postlernapublish": "git checkout master",
    "lint": "eslint --ext js --ext ts --ext md",
    "lint:ci": "yarn lint . --format junit",
    "lint:fix": "yarn lint -- --fix",
    "lint:md": "markdownlint",
    "lintx": "yarn lint ./packages/**/src/**/*.ts ./packages-modules/**/src/**/*.ts",
    "prodBuild": "cross-env NODE_ENV=production babel-node --presets es2015 tools/webpack.run",
    "publish": "yarn lernapublish",
    "publish:auto": "yarn lernapublish --yes",
    "publish:force": "yarn publish:forceManual --yes",
    "publish:forceManual": "yarn lernapublish --force-publish=*",
    "publish:push": "yarn prelernapublish && git push origin publish && yarn postlernapublish",
    "start": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env yarn zen:watch",
    "start:envSSR": "cross-env SSR=true NODE_ENV=development ENV_FILE=../../config/development/dev.env yarn zen:watch",
    "start:test": "cross-env NODE_ENV=test ENV_FILE=../../config/test/test.env zen watch",
    "test": "cross-env ENV_FILE=config/test/test.env jest",
    "posttest": "yarn lint",
    "test:watch": "npm test -- --watch",
    "pretravis": "yarn compile",
    "travis": "istanbul cover -x \"*.test.js\" _mocha -- --timeout 5000 --full-trace ./test/tests.js",
    "posttravis": "yarn lint",
    "watch": "lerna exec --no-sort --ignore *server --ignore *device --ignore *browser-extension --stream --parallel -- webpack --watch",
    "watch-packages": "lerna exec --no-sort  --scope @sample-stack/platform* --scope @sample-stack/react-shared-components --scope @sample-stack/core --stream --parallel 'webpack --watch'",
    "zen:build": "cross-env NODE_ENV=production zen build",
    "zen:exp": "zen exp",
    "zen:watch": "zen  watch -x",
    "zen:watch:debug": "yarn zen:watch -- -v"
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  },
  "lint-staged": {
    "*.md": [
      "yarn format:md",
      "git add"
    ],
    "*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "git add"
    ]
  },
  "resolutions": {
    "@apollo/client": "~3.3.21",
    "chokidar": "^3.4.0",
    "react": "17.0.1",
    "react-dom": "17.0.1"
  },
  "dependencies": {
    "dataloader": "^2.0.0",
    "graphql": "^14.7.0",
    "graphql-tag": "^2.11.0"
  },
  "devDependencies": {
    "@babel/cli": "^7.7.7",
    "@babel/core": "^7.7.7",
    "@babel/plugin-proposal-class-properties": "^7.7.4",
    "@babel/plugin-proposal-decorators": "^7.7.4",
    "@babel/plugin-proposal-export-default-from": "^7.7.4",
    "@babel/plugin-proposal-export-namespace-from": "^7.7.4",
    "@babel/plugin-proposal-nullish-coalescing-operator": "^7.7.4",
    "@babel/plugin-proposal-object-rest-spread": "^7.7.7",
    "@babel/plugin-proposal-optional-chaining": "^7.7.5",
    "@babel/plugin-proposal-pipeline-operator": "^7.7.7",
    "@babel/plugin-syntax-dynamic-import": "^7.7.4",
    "@babel/plugin-syntax-export-default-from": "^7.7.4",
    "@babel/plugin-syntax-export-namespace-from": "^7.7.4",
    "@babel/plugin-syntax-import-meta": "^7.7.4",
    "@babel/plugin-syntax-numeric-separator": "^7.7.4",
    "@babel/plugin-transform-destructuring": "^7.7.4",
    "@babel/plugin-transform-for-of": "^7.13.0",
    "@babel/plugin-transform-modules-commonjs": "^7.7.5",
    "@babel/plugin-transform-regenerator": "^7.7.5",
    "@babel/plugin-transform-runtime": "^7.7.6",
    "@babel/polyfill": "7.7.0",
    "@babel/preset-env": "^7.7.7",
    "@babel/preset-flow": "^7.7.4",
    "@babel/preset-react": "^7.7.4",
    "@babel/preset-typescript": "^7.7.7",
    "@babel/register": "^7.7.7",
    "@babel/runtime": "^7.7.7",
    "@graphql-codegen/add": "^2.0.2",
    "@graphql-codegen/cli": "^1.21.8",
    "@graphql-codegen/fragment-matcher": "^2.0.1",
    "@graphql-codegen/import-types-preset": "^1.18.6",
    "@graphql-codegen/near-operation-file-preset": "^1.18.6",
    "@graphql-codegen/typescript": "^1.23.0",
    "@graphql-codegen/typescript-graphql-files-modules": "^1.18.1",
    "@graphql-codegen/typescript-operations": "^1.18.4",
    "@graphql-codegen/typescript-react-apollo": "^2.3.1",
    "@graphql-codegen/typescript-resolvers": "^1.20.0",
    "@hot-loader/react-dom": "^17.0.0",
    "@larix/zen": "0.1.37",
    "@open-wc/building-rollup": "^1.10.0",
    "@redux-devtools/core": "^3.9.0",
    "@redux-devtools/dock-monitor": "^1.4.0",
    "@redux-devtools/log-monitor": "^2.3.0",
    "@rollup/plugin-graphql": "1.0.0",
    "@rollup/plugin-image": "^2.0.6",
    "@rollup/plugin-typescript": "^6.1.0",
    "@shelf/jest-mongodb": "^1.1.5",
    "@types/async": "^3.0.3",
    "@types/body-parser": "1.17.1",
    "@types/bunyan": "^1.8.6",
    "@types/classnames": "^2.2.9",
    "@types/cors": "2.8.6",
    "@types/enzyme": "^3.10.4",
    "@types/express": "^4.17.2",
    "@types/hoist-non-react-statics": "^3.3.1",
    "@types/ioredis": "^4.14.4",
    "@types/isomorphic-fetch": "0.0.35",
    "@types/jest": "^26.0.24",
    "@types/lodash-es": "^4.17.3",
    "@types/minimist": "^1.2.0",
    "@types/node": "13.1.0",
    "@types/prop-types": "^15.7.3",
    "@types/react": "^17.0.35",
    "@types/react-dom": "^17.0.11",
    "@types/react-helmet": "^5.0.14",
    "@types/react-loadable": "^5.5.3",
    "@types/react-redux": "^7.1.5",
    "@types/react-router": "^5.1.3",
    "@types/react-router-config": "^5.0.2",
    "@types/react-router-dom": "^5.1.3",
    "@types/react-test-renderer": "^17.0.1",
    "@types/redux-logger": "^3.0.9",
    "@types/semver": "^6.2.0",
    "@types/sinon": "^7.5.1",
    "@types/webpack": "^4.41.0",
    "@types/webpack-env": "^1.14.1",
    "@types/zen-observable": "^0.8.0",
    "@typescript-eslint/eslint-plugin": "^4.20.0",
    "@typescript-eslint/eslint-plugin-tslint": "^4.20.0",
    "@typescript-eslint/parser": "^4.20.0",
    "apollo": "^2.21.2",
    "apollo-server-testing": "^2.21.1",
    "autoprefixer": "^9.7.3",
    "awesome-typescript-loader": "^5.2.1",
    "babel-core": "^7.0.0-bridge.0",
    "babel-eslint": "^10.0.3",
    "babel-jest": "^26.3.0",
    "babel-loader": "^8.0.6",
    "babel-plugin-import": "^1.13.3",
    "caporal": "^1.3.0",
    "chokidar": "^3.4.0",
    "clean-webpack-plugin": "^2.0.0",
    "commitizen": "^4.2.3",
    "concurrently": "^5.0.2",
    "connect": "^3.7.0",
    "copy-webpack-plugin": "^6.4.0",
    "cross-env": "^6.0.3",
    "css-loader": "^3.4.0",
    "csstype": "^2.5.5",
    "dotenv-safe": "^8.2.0",
    "dotenv-webpack": "^6.0.0",
    "envalid": "^7.2.2",
    "enzyme": "^3.11.0",
    "enzyme-adapter-react-16": "^1.15.2",
    "eslint": "^7.23.0",
    "eslint-config-airbnb-typescript": "^12.3.1",
    "eslint-config-prettier": "^8.1.0",
    "eslint-loader": "^4.0.2",
    "eslint-plugin-graphql": "^4.0.0",
    "eslint-plugin-import": "^2.22.1",
    "eslint-plugin-jest": "^24.3.3",
    "eslint-plugin-jsdoc": "^32.3.0",
    "eslint-plugin-jsx-a11y": "^6.4.1",
    "eslint-plugin-markdown": "^2.0.1",
    "eslint-plugin-no-null": "^1.0.2",
    "eslint-plugin-prettier": "^3.3.1",
    "eslint-plugin-react": "^7.23.1",
    "eslint-plugin-react-hooks": "^4.2.0",
    "eslint-plugin-simple-import-sort": "^7.0.0",
    "express": "^4.17.1",
    "extract-text-webpack-plugin": "^4.0.0-beta.0",
    "file-loader": "^5.0.2",
    "freeport-async": "^2.0.0",
    "fs-extra": "^8.1.0",
    "html-loader": "^0.5.5",
    "html-webpack-plugin": "^3.2.0",
    "http-proxy-middleware": "^0.20.0",
    "husky": "^5.0.9",
    "ignore-loader": "^0.1.2",
    "image-size": "^0.8.3",
    "ip": "^1.1.5",
    "isomorphic-style-loader": "^5.1.0",
    "istanbul": "1.0.0-alpha.2",
    "jest": "^26.0.0",
    "jest-css-modules-transform": "^3.1.0",
    "jest-dom": "^4.0.0",
    "jest-junit": "^12.2.0",
    "jest-matcher-utils": "^26.0.0",
    "jest-raw-loader": "^1.0.1",
    "jest-transform-graphql": "^2.1.0",
    "jsdom": "^15.2.1",
    "lerna": "^4.0.0",
    "lint-staged": "^9.5.0",
    "lodash": "^4.17.15",
    "lodash-es": "^4.17.15",
    "lodash-webpack-plugin": "^0.11.5",
    "markdownlint-cli": "^0.27.0",
    "merge": "^1.2.1",
    "mime": "^2.4.4",
    "mini-css-extract-plugin": "^0.9.0",
    "minilog": "^3.1.0",
    "mkdirp": "^0.5.1",
    "mocha": "^6.2.2",
    "mocha-steps": "^1.3.0",
    "module": "^1.2.5",
    "morgan": "^1.9.1",
    "nock": "^11.7.0",
    "node-dev": "^4.0.0",
    "node-sass": "^4.13.0",
    "nodemon": "^2.0.2",
    "openurl": "^1.1.1",
    "pm2": "^4.2.1",
    "postcss-loader": "^3.0.0",
    "prettier": "^2.2.1",
    "qrcode-terminal": "^0.12.0",
    "raw-loader": "^4.0.0",
    "react-addons-test-utils": "^16.0.0-alpha.3",
    "react-hot-loader": "^4.12.18",
    "react-test-renderer": "^16.12.0",
    "redux-devtools-extension": "^2.13.8",
    "redux-mock-store": "^1.5.4",
    "remap-istanbul": "^0.13.0",
    "resolve-url-loader": "^3.1.1",
    "rimraf": "^3.0.0",
    "rollup": "^2.53.2",
    "rollup-plugin-string": "^3.0.0",
    "sass-loader": "^8.0.0",
    "shelljs": "^0.8.3",
    "simple-git": "^2.42.0",
    "sinon": "^8.0.1",
    "source-list-map": "^2.0.1",
    "source-map-loader": "^0.2.4",
    "source-map-support": "^0.5.16",
    "standard-version": "^7.0.1",
    "style-loader": "^1.1.1",
    "svg-url-loader": "^3.0.3",
    "tcomb": "^3.2.29",
    "ts-jest": "^26.0.0",
    "ts-loader": "^6.2.1",
    "ts-node": "^8.5.4",
    "tslib": "^1.10.0",
    "tslint": "^6.1.3",
    "typedoc": "^0.15.5",
    "typescript": "4.2.3",
    "uglify-es": "^3.3.9",
    "uglifyjs-webpack-plugin": "^2.2.0",
    "url-loader": "^3.0.0",
    "wait-on": "^4.0.0",
    "webpack": "4.46.0",
    "webpack-bundle-analyzer": "^4.5.0",
    "webpack-cli": "^3.3.10",
    "webpack-dev-middleware": "^4.1.0",
    "webpack-dev-server": "^3.11.2",
    "webpack-hot-middleware": "^2.25.0",
    "webpack-manifest-plugin": "^2.2.0",
    "webpack-merge": "^5.4.0",
    "webpack-node-externals": "^3.0.0",
    "webpack-sources": "^1.4.3",
    "webpack-virtual-modules": "^0.4.3",
    "ws": "^7.2.1"
  },
  "engines": {
    "node": ">=12.18.4 < 15.0.0",
    "yarn": ">=1.22"
  },
  "cacheDirectories": [
    ".cache"
  ]
}
\`\`\`

## packages/sample-core/README.md

\`\`\`md


## To run tests

    `npm link`
    `npm link @xtermstack/xterm-core`
    `yarn install`
    `tsc`
    `yarn test`

\`\`\`

## packages/sample-core/package.json

\`\`\`json
{
  "name": "@sample-stack/core",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "webpack",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "cross-env ENV_FILE=../../config/test/test.env jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}

\`\`\`

## packages/sample-platform/browser/package.json

\`\`\`json
{
  "name": "@sample-stack/platform-browser",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "webpack",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "modulePaths": [
      "node_modules"
    ],
    "roots": [
      "src"
    ],
    "testEnvironment": "node",
    "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "dependencies": {
    "@sample-stack/core": "link:../../sample-core"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}

\`\`\`

## packages/sample-platform/server/README.md

\`\`\`md


## To run tests

    `npm link`
    `npm link @xtermstack/xterm-core`
    `yarn install`
    `tsc`
    `yarn test`

\`\`\`

## packages/sample-platform/server/package.json

\`\`\`json
{
  "name": "@sample-stack/platform-server",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "webpack",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "modulePaths": [
      "node_modules"
    ],
    "roots": [
      "src"
    ],
    "testEnvironment": "node",
    "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "dependencies": {
    "@sample-stack/core": "link:../../sample-core"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}

\`\`\`

## packages/sample-store/README.md

\`\`\`md


## To run tests

    `npm link`
    `npm link @xtermstack/xterm-core`
    `yarn install`
    `tsc`
    `yarn test`

\`\`\`

## packages/sample-store/package.json

\`\`\`json
{
  "name": "@sample-stack/store",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "webpack",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "cross-env ENV_FILE=../../config/test/test.env jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "modulePaths": [
      "node_modules"
    ],
    "roots": [
      "src"
    ],
    "testEnvironment": "node",
    "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "dependencies": {
    "@sample-stack/core": "link:../sample-core",
    "sequelize": "^5.21.3"
  },
  "peerDependencies": {
    "inversify": "*"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}

\`\`\`

## packages-modules/counter/browser/package.json

\`\`\`json
{
  "name": "@sample-stack/counter-module-browser",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "rollup -c rollup.config.js",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "cross-env ENV_FILE=../../config/test/test.env jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "modulePaths": [
      "node_modules"
    ],
    "roots": [
      "src"
    ],
    "testEnvironment": "node",
    "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "dependencies": {
    "@sample-stack/platform-browser": "link:../../../packages/sample-platform/browser",
    "antd": "~4.15.3"
  },
  "devDependencies": {},
  "peerDependencies": {
    "@common-stack/client-react": "*",
    "@rollup/plugin-graphql": "*",
    "@rollup/plugin-image": "*",
    "@rollup/plugin-typescript": "*",
    "react": "*",
    "react-native": "*",
    "react-redux": "*",
    "react-router": "*",
    "react-router-dom": "*",
    "redux": "*",
    "redux-observable": "*",
    "rollup-plugin-string": "*",
    "rxjs": "*"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}
\`\`\`

## packages-modules/counter/browser/src/connected-react-router/README.md

\`\`\`md
# Connected React Router TypeScript Example

You can try changing counter value and editing some components. Components will be updated while preserving counter state.

In Hello link, you will see that the HelloChild component can access router state (URL path) without passing as props via its parent.


Reference:

https://github.com/supasate/connected-react-router/tree/master/examples/typescript
\`\`\`

## packages-modules/counter/browser/src/fela/README.md

\`\`\`md
<h1><img alt="Fela" src="docs/res/logo.png" width="203"/></h1>

Fela is a small, high-performant and framework-agnostic toolbelt to handle state-driven styling in JavaScript.<br>
It is dynamic by design and renders your styles depending on your application state.

Code Reference:

https://github.com/rofrischmann/fela/tree/master/examples/example-typescript
\`\`\`

## packages-modules/counter/electron/package.json

\`\`\`json
{
  "name": "@sample-stack/counter-module-electron",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "webpack",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "cross-env ENV_FILE=../../config/test/test.env jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "modulePaths": [
      "node_modules"
    ],
    "roots": [
      "src"
    ],
    "testEnvironment": "node",
    "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "dependencies": {
    "@sample-stack/counter-module-browser": "link:../browser"
  },
  "devDependencies": {
    "@open-wc/building-rollup": "^1.10.0",
    "@rollup/plugin-graphql": "1.0.0",
    "@rollup/plugin-image": "^2.0.6",
    "@rollup/plugin-typescript": "^6.1.0",
    "rollup": "latest"
  },
  "peerDependencies": {
    "@common-stack/client-react": "*",
    "native-base": "*",
    "react": "*",
    "react-native": "*",
    "react-redux": "*",
    "react-router": "*",
    "react-router-dom": "*",
    "redux": "*",
    "redux-observable": "*",
    "rxjs": "*"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}
\`\`\`

## packages-modules/counter/mobile/package.json

\`\`\`json
{
  "name": "@sample-stack/counter-module-mobile",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "tsc",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "cross-env ENV_FILE=../../config/test/test.env jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "modulePaths": [
      "node_modules"
    ],
    "roots": [
      "src"
    ],
    "testEnvironment": "node",
    "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "dependencies": {
    "@sample-stack/platform-browser": "link:../../../packages/sample-platform/browser",
    "antd": "~4.15.3"
  },
  "peerDependencies": {
    "@common-stack/client-react": "*",
    "native-base": "*",
    "react": "*",
    "react-native": "*",
    "react-redux": "*",
    "react-router": "*",
    "react-router-dom": "*",
    "redux": "*"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}
\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/README.md

\`\`\`md
# Connected React Router TypeScript Example

You can try changing counter value and editing some components. Components will be updated while preserving counter state.

In Hello link, you will see that the HelloChild component can access router state (URL path) without passing as props via its parent.


Reference:

https://github.com/supasate/connected-react-router/tree/master/examples/typescript
\`\`\`

## packages-modules/counter/server/package.json

\`\`\`json
{
  "name": "@sample-stack/counter-module-server",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "webpack",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "cross-env ENV_FILE=../../config/test/test.env jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "modulePaths": [
      "node_modules"
    ],
    "roots": [
      "src"
    ],
    "testEnvironment": "node",
    "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "peerDependencies": {
    "@cdm-logger/server": "*",
    "@common-stack/core": "*",
    "@common-stack/server-core": "*",
    "apollo-server-caching": "*",
    "dataloader": "*",
    "inversify": "*",
    "moleculer": "*"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}

\`\`\`

## portable-devices/desktop/package.json

\`\`\`json
{
  "name": "sample-stack-desktop-device",
  "version": "0.0.1",
  "private": true,
  "description": "App is based on Electron, React, Redux and NodeJS as a back end",
  "homepage": "https://github.com/cdmbase/fullstack-pro#readme",
  "bugs": {
    "url": "https://github.com/cdmbase/fullstack-pro/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/cdmbase/fullstack-pro.git"
  },
  "license": "MIT",
  "author": {
    "name": "CDMBase LLC",
    "email": "jteidforyou@gmail.com"
  },
  "main": "index.js",
  "scripts": {
    "build": "cross-env NODE_OPTIONS='--max_old_space_size=4096' NODE_ENV=production electron-webpack",
    "build:clean": "rimraf dist",
    "electron": "electron dist/main/main.js",
    "package": "electron-builder",
    "release": "yarn build && electron-builder build --mac",
    "release:linux": "yarn build && electron-builder build --linux",
    "release:mac": "yarn build && electron-builder build --mac",
    "release:win": "electron-builder build --win",
    "start": "cross-env NODE_ENV=production electron dist/main/main.js",
    "start:dev": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env electron dist/main/main.js",
    "start:staging": "cross-env NODE_ENV=staging ENV_FILE=../../config/staging/staging.env electron dist/main/main.js",
    "start:prod": "cross-env NODE_ENV=production ENV_FILE=../../config/development/dev.env electron dist/main/main.js",
    "test": "echo Skipped.",
    "watch": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env electron-webpack dev",
    "watch:staging": "cross-env ENV_FILE=../../config/staging/staging.env electron-webpack dev"
  },
  "resolutions": {
    "webpack-sources": "^1.1.0"
  },
  "dependencies": {
    "@ant-design/compatible": "^1.0.5",
    "@ant-design/icons": "^4.2.2",
    "@cdm-logger/client": "^7.0.8",
    "@cdm-logger/server": "^7.0.7",
    "@cdm-logger/electron": "^7.0.7",
    "@common-stack/client-core": "0.1.11",
    "@common-stack/client-react": "0.1.11",
    "@common-stack/core": "0.1.11",
    "@common-stack/server-core": "0.1.11",
    "@sample-stack/core": "link:../../packages/sample-core",
    "@sample-stack/counter-module-browser": "link:../../packages-modules/counter/browser",
    "@sample-stack/counter-module-electron": "link:../../packages-modules/counter/electron",
    "@sample-stack/platform-browser": "link:../../packages/sample-platform/browser",
    "antd": "~4.15.3",
    "@apollo/client": "~3.3.21",
    "apollo-link-debounce": "^2.1.0",
    "apollo-link-logger": "^1.2.3",
    "apollo-logger": "^0.3.3",
    "aws-sdk": "^2.880.0",
    "browser-bunyan": "^1.6.3",
    "check-internet-connected": "^2.0.5",
    "classnames": "^2.2.6",
    "connected-react-router": "^6.9.1",
    "cors": "^2.8.5",
    "cross-env": "^6.0.3",
    "dotenv": "^8.2.0",
    "electron-json-storage": "^2.0.0",
    "electron-positioner": "^4.1.0",
    "electron-redux": "^1.5.4",
    "electron-updater": "^4.3.9",
    "envalid": "^7.2.2",
    "esm": "^3.2.25",
    "fela": "11.6.0",
    "fela-beautifier": "^11.6.0",
    "fela-dom": "11.6.0",
    "fela-font-renderer": "^5.0.25",
    "fela-perf": "^11.6.0",
    "fela-plugin-fallback-value": "^11.6.0",
    "fela-plugin-logger": "^11.6.0",
    "fela-plugin-lvha": "^5.0.16",
    "fela-plugin-prefixer": "^11.6.0",
    "fela-plugin-unit": "^11.6.0",
    "fela-plugin-validator": "^11.6.0",
    "fela-preset-web": "^11.6.0",
    "graphql": "^14.7.0",
    "graphql-tag": "^2.11.0",
    "history": "^4.10.1",
    "immutability-helper": "^3.0.1",
    "inversify": "^5.0.1",
    "inversify-binding-decorators": "^4.0.0",
    "isomorphic-fetch": "^2.2.1",
    "js-cookie": "^2.2.1",
    "lodash": "^4.17.15",
    "os-name": "^4.0.0",
    "pify": "^2.3.0",
    "ramda": "^0.26.1",
    "react": "17.0.1",
    "react-dom": "17.0.1",
    "react-fela": "11.6.0",
    "react-helmet": "^6.1.0",
    "react-loadable": "^5.5.0",
    "react-redux": "^7.1.3",
    "react-router": "^5.2.1",
    "react-router-config": "^5.1.1",
    "react-router-dom": "^5.3.0",
    "react-transition-group": "^4.3.0",
    "redux": "^4.0.5",
    "redux-logger": "^3.0.6",
    "redux-observable": "^1.2.0",
    "redux-persist": "^6.0.0",
    "redux-thunk": "^2.3.0",
    "reflect-metadata": "^0.1.13",
    "reselect": "^4.0.0",
    "rxjs": "^6.5.3",
    "rxjs-compat": "^6.5.3",
    "rxjs-hooks": "^0.5.2",
    "source-map-support": "^0.5.19",
    "sqlite3": "^5.0.2",
    "subscriptions-transport-ws": "0.9.18",
    "typeorm": "^0.2.32"
  },
  "devDependencies": {
    "@jest-runner/electron": "^3.0.1",
    "cross-env": "^6.0.3",
    "electron": "11.4.10",
    "electron-builder": "^22.11.7",
    "electron-debug": "^3.1.0",
    "electron-devtools-installer": "^3.2.0",
    "electron-is": "^3.0.0",
    "electron-log": "^4.3.5",
    "electron-webpack": "^2.8.2",
    "electron-webpack-ts": "^4.0.1",
    "pm2": "^4.2.1",
    "rimraf": "^3.0.0",
    "workspaces-utils": "^1.2.1"
  },
  "buildAbout": {
    "appName": "Fullstack-Pro",
    "apiApp": "https://time-tracker-api.herokuapp.com/"
  }
}
\`\`\`

## portable-devices/mobile/package.json

\`\`\`json
{
  "name": "sample-stack-mobile-device",
  "version": "0.0.1",
  "private": true,
  "main": "index.js",
  "scripts": {
    "android": "expo run:android",
    "build": "yarn easBuild --profile development",
    "build:all": "yarn build -p all",
    "build:android": "yarn build -p android --clear-cache",
    "build:auto": "yarn build:all --non-interactive",
    "build:clean": "rimraf build .expo .tmp",
    "build:configure": "eas build:configure",
    "build:ios": "yarn build -p ios --clear-cache",
    "build:preview": "yarn easBuild --profile preview -p all --non-interactive",
    "cli": "node ../../tools/cli",
    "eas-build-post-install": "lerna exec --scope=@sample-stack/core --scope=@sample-stack/counter-module-mobile yarn build",
    "easBuild": "eas build",
    "eslint": "eslint --fix --ext js --ext jsx --ext json src",
    "exp-login": "cross-env NODE_ENV=production expo login -u $EXP_USERNAME -p $EXP_PASSWORD --non-interactive",
    "exp-publish": "yarn exp-login && yarn expo p --non-interactive",
    "ios": "expo run:ios",
    "lint": "yarn eslint && yarn tslint",
    "start": "expo start --dev-client",
    "submit": "eas submit",
    "test": "yarn tests && yarn lint",
    "tests": "jest",
    "tests:watch": "jest --watch",
    "tslint": "tslint --fix -p tsconfig.json -c ../../tslint.json",
    "watch": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env expo start --clear",
    "watch:android": "expo start --android",
    "watch:ios": "expo start --ios"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@apollo/client": "~3.3.21",
    "@cdm-logger/client": "^7.0.8",
    "@codler/react-native-keyboard-aware-scroll-view": "1.0.0",
    "@common-stack/client-core": "^0.1.11",
    "@common-stack/client-react": "^0.1.11",
    "@common-stack/core": "^0.1.11",
    "@expo/vector-icons": "^12.0.0",
    "@react-native-async-storage/async-storage": "~1.15.0",
    "@react-native-community/cameraroll": "^4.0.4",
    "@react-native-community/masked-view": "^0.1.10",
    "@react-native-community/netinfo": "6.0.2",
    "@react-native-community/picker": "^1.8.1",
    "@react-native-community/segmented-control": "^2.2.2",
    "@react-native-community/slider": "^4.1.7",
    "@react-native-community/viewpager": "^5.0.11",
    "@sample-stack/counter-module-mobile": "link:../../packages-modules/counter/mobile",
    "apollo-link-debounce": "^2.1.0",
    "apollo-link-logger": "^1.2.3",
    "apollo-logger": "^0.3.3",
    "browser-bunyan": "^1.6.3",
    "connected-react-router": "^6.9.1",
    "eas-cli": "^0.36.1",
    "expo": "~43.0.3",
    "expo-app-loading": "~1.2.1",
    "expo-asset": "~8.4.3",
    "expo-cli": "^4.13.0",
    "expo-constants": "~12.1.3",
    "expo-file-system": "~13.0.3",
    "expo-font": "~10.0.3",
    "expo-image-picker": "~11.0.3",
    "expo-keep-awake": "~10.0.0",
    "expo-linking": "~2.4.2",
    "expo-localization": "~11.0.0",
    "expo-notifications": "~0.13.3",
    "expo-permissions": "~13.0.3",
    "expo-random": "12.0.1",
    "expo-secure-store": "~11.0.3",
    "expo-splash-screen": "~0.13.5",
    "expo-status-bar": "~1.1.0",
    "expo-web-browser": "~10.0.3",
    "fela": "11.6.0",
    "fela-beautifier": "^11.6.0",
    "fela-dom": "11.6.0",
    "fela-font-renderer": "^5.0.25",
    "fela-native": "^11.6.1",
    "fela-perf": "^11.6.0",
    "fela-plugin-fallback-value": "^11.6.0",
    "fela-plugin-logger": "^11.6.0",
    "fela-plugin-lvha": "^5.0.16",
    "fela-plugin-prefixer": "^11.6.0",
    "fela-plugin-unit": "^11.6.0",
    "fela-plugin-validator": "^11.6.0",
    "fela-preset-web": "^11.6.0",
    "history": "^4.10.1",
    "immutability-helper": "^3.0.1",
    "inversify": "^5.0.1",
    "isomorphic-fetch": "^2.2.1",
    "lodash": "^4.17.4",
    "metro-minify-terser": "^0.56.0",
    "minilog": "^3.1.0",
    "native-base": "~3.2.2",
    "prop-types": "^15.6.0",
    "ramda": "^0.26.1",
    "react": "17.0.1",
    "react-dom": "17.0.1",
    "react-fela": "11.6.0",
    "react-helmet": "^6.1.0",
    "react-loadable": "^5.5.0",
    "react-native": "0.64.3",
    "react-native-dotenv": "^3.3.0",
    "react-native-gesture-handler": "~2.1.0",
    "react-native-keyboard-aware-scroll-view": "^0.9.3",
    "react-native-keyboard-spacer": "^0.4.1",
    "react-native-mime-types": "^2.3.0",
    "react-native-modal": "^11.6.1",
    "react-native-reanimated": "^2.2.0",
    "react-native-safe-area-context": "3.3.2",
    "react-native-screens": "~3.8.0",
    "react-native-simple-picker": "^3.1.2",
    "react-native-svg": "~12.1.1",
    "react-native-swipe-list-view": "^3.2.6",
    "react-native-web": "0.17.1",
    "react-redux": "^7.1.3",
    "react-router": "^5.2.1",
    "react-router-config": "^5.1.1",
    "react-router-dom": "^5.3.0",
    "react-router-native": "^5.2.1",
    "redux": "^4.0.5",
    "redux-logger": "^3.0.6",
    "redux-observable": "^1.2.0",
    "redux-persist": "^6.0.0",
    "redux-thunk": "^2.3.0",
    "reselect": "^4.0.0",
    "rxjs": "^6.5.3",
    "rxjs-compat": "^6.5.3",
    "rxjs-hooks": "^0.5.2",
    "sentry-expo": "~4.0.0",
    "subscriptions-transport-ws": "0.9.18"
  },
  "devDependencies": {
    "@babel/core": "^7.12.9",
    "@testing-library/react-native": "^5.0.3",
    "@types/expo": "^33.0.1",
    "@types/react": "^17.0.35",
    "@types/react-native": "~0.64.12",
    "@types/react-native-dotenv": "^0.2.0",
    "@types/react-native-keyboard-spacer": "^0.4.1",
    "@types/react-router-native": "^5.1.0",
    "babel-preset-expo": "8.5.1",
    "cross-env": "^6.0.3",
    "eslint-plugin-react-native": "^3.8.1",
    "expo-dev-client": "^0.6.3",
    "jest-expo": "^43.0.0",
    "lerna": "^4.0.0"
  },
  "peerDependencies": {
    "webpack": "*"
  }
}

\`\`\`

## servers/backend-server/README.md

\`\`\`md
# webpack-apollo-server
Starter kit for apollo server using webpack and typescript

What does it include:
----
    1. exported schema as example for GraphQL Schema
    2. Working Apollo Server (webpack + tslint + tsloader)
    3. Typescript 2.0.0 => ES6
    4. Dockerfile to make the apollo-server a container.
    5. unit testing (mocha-webpack+chai) + coverage report (mocha-istanbul-spec+istanbul).
    6. working with graphql-tools
    7. standard-version for auto SemVer.

Notes
----
Please note that you will need to rename the library name in some files:

    1. package.json (ofcourse ;))

Useful commands:
----
    yarn build       - build the library files (Required for start:watch)
    yarn build:watch - build the library files in watchmode (Useful for development)
    npm test            - run tests once
    yarn test:watch  - run tests in watchmode (Useful for development)
    yarn test:growl  - run tests in watchmode with growl notification (even more useful for development)

How to run it:
----
\`\`\`bash
    npm start
\`\`\`

Files explained:
----
    1. src                         - directory is used for typescript code that is part of the project
        1a. main.ts                - Main server file. (Starting Apollo server)
        1b. main.spec.ts           - Tests file for main
        1c. schema                 - Module used to build schema
            - index.ts             - simple logic to merge all modules into a schema using graphql-tools
            - modules/             - directory for modules to be used with graphql-tools
        1c. schema.spec.ts         - Basic test for schema.
        1c. main.test.ts           - Main for tests runner.
    3. package.json                - file is used to describe the library
    4. tsconfig.json               - configuration file for the library compilation
    6. tslint.json                 - configuration file for the linter
    7. typings.json                - typings needed for the server
    8. webpack.config.js           - configuration file of the compilation automation process for the library
    9. webpack.config.test.js      - configuration file of the compilation when testing
    10. Dockerfile                 - Dockerfile used to describe how to make a container out of apollo server
    11. mocha-webpack.opts         - Options file for mocha-webpack

Output files explained:
----
    1. node_modules - directory npm creates with all the dependencies of the module (result of yarn install)
    2. dist         - directory contains the compiled server (javascript)
    3. html-report  - output of npm test, code coverage html report.


Database
----
Connects to memory database through Knex

Database configuration is set in `db-config.json`

Setup
----
Create a database and fill the data
\`\`\`
yarn db:seed         
\`\`\`
What files to be customized? 
----
Customizable files for a specific project would be the following
\`\`\`
src/container
src/middleware/graphql.ts
\`\`\`

The Person type - dynamic/parametrized query and drill down:
----
The person type was added to demonstrate a database like access, parametrized queries, resolvers and drill down.
The data is currently hard coded but simulates a storage. Each person has an id, name and sex. It also has a dynamic
field called matches. For demonstration purposes, this field will retrieve all members of the other sex by using a
resolver.

Since this is a computed field the query can be infinitely nested, for example, try in the graphiql editor this query:

    {
       getPerson(id: "1") {
         id,
         name
         sex
         matches {
           id
           name
           sex
           matches {
             id
             name
             sex
             matches {
               id
               name
               sex
             }
           }
         }
       }
     }

It will return a nested, alternating male/femal results.

To list all persons, use the `persons` query:

    {
      persons {
        id
        name
      }
    }

There is also an example of a mutation - `addPerson(name: String, sex: String)`, to use it:

    mutation {
        addPerson(name: "kuku", sex: "male"){
            id
            name
        }
    }

Note that the query generates a random id and that the added persons are transient,
i.e. not persisted and will be gone once you shut down the server.
\`\`\`

## servers/backend-server/package.json

\`\`\`json
{
  "name": "sample-stack-backend-server",
  "version": "0.0.1",
  "private": true,
  "description": "Starter kit for apollo server using webpack and typescript",
  "keywords": [
    "apollo",
    "apollo-server",
    "backend",
    "express",
    "graphiql",
    "graphql",
    "typescript",
    "webpack"
  ],
  "homepage": "https://github.com/cdmbase/fullstack-pro#readme",
  "bugs": {
    "url": "https://github.com/cdmbase/fullstack-pro/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/cdmbase/fullstack-pro.git"
  },
  "license": "MIT",
  "author": "CDMBase LLC",
  "main": "dist/index.js",
  "typings": "dist/main.d.ts",
  "scripts": {
    "build": "cross-env NODE_ENV=production zen build -x",
    "build:clean": "rimraf dist .awcache",
    "build:debug": "cross-env NODE_ENV=development zen build -x",
    "db:migrate": "knex -- migrate:latest --cwd . --knexfile ./knexfile.js",
    "db:migrate:rollback": "knex -- migrate:rollback  --cwd . --knexfile ./knexfile.js",
    "db:seed": "yarn db:migrate && knex -- seed:run  --cwd . --knexfile ./knexfile.js",
    "docker:build": "yarn build && docker build . -t $npm_package_name:$npm_package_version",
    "docker:build:debug": "yarn build:debug && docker build . -t $npm_package_name:$npm_package_version",
    "docker:run": "docker run  --env-file ../../config/staging/docker-staging.env -p 8080:8080 -it $npm_package_name:$npm_package_version",
    "docker:run:debug": "cross-env NODE_ENV=development docker run  --env-file ../../config/staging/docker-staging.env -p 8080:8080 -it $npm_package_name:$npm_package_version",
    "proddb:migrate": "NODE_ENV=production yarn db:migrate",
    "proddb:migrate:rollback": "NODE_ENV=production yarn db:migrate:rollback",
    "proddb:seed": "NODE_ENV=production yarn db:seed",
    "prepublish": "yarn build:clean",
    "stagedb:migrate": "cross-env ENV_FILE=../../config/test/test.env NODE_ENV=test yarn db:migrate",
    "stagedb:migrate:rollback": "cross-env ENV_FILE=../../config/test/test.env NODE_ENV=test yarn db:migrate:rollback",
    "stagedb:seed": "cross-env ENV_FILE=../../config/test/test.env NODE_ENV=test yarn db:seed",
    "start": "cross-env NODE_ENV=production pm2-runtime  dist/index.js",
    "start:staging": "cross-env NODE_ENV=staging ENV_FILE=../../config/staging/staging.env node --harmony dist",
    "start:test": "cross-env NODE_ENV=test ENV_FILE=../../config/test/test.env node --harmony dist",
    "test": "jest",
    "test:notify": "yarn test:watch -- --notify",
    "test:watch": "npm test -- --watch",
    "preupver": "npm test",
    "upver": "standard-version",
    "watch": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env yarn zen:watch",
    "watch:debug": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env yarn zen:watch -- -v",
    "watch:staging": "cross-env NODE_ENV=test ENV_FILE=../../config/staging/staging.env yarn zen:watch",
    "watch:test": "cross-env NODE_ENV=test ENV_FILE=../../config/test/test.env yarn zen:watch",
    "zen:watch": "zen watch -x"
  },
  "dependencies": {
    "@apollo/client": "~3.3.21",
    "@cdm-logger/server": "^7.0.7",
    "@common-stack/core": "0.1.11",
    "@common-stack/server-core": "0.1.11",
    "@graphql-tools/links": "^7.0.0",
    "@sample-stack/core": "link:../../packages/sample-core",
    "@sample-stack/counter-module-server": "link:../../packages-modules/counter/server",
    "@sample-stack/platform-server": "link:../../packages/sample-platform/server",
    "@sample-stack/store": "link:../../packages/sample-store",
    "apollo-datasource": "^0.7.0",
    "apollo-datasource-rest": "^0.8.0",
    "apollo-errors": "^1.9.0",
    "apollo-logger": "^0.3.3",
    "apollo-server-cache-memcached": "^0.6.7",
    "apollo-server-cache-redis": "^1.2.3",
    "apollo-server-caching": "^0.5.3",
    "apollo-server-core": "^2.21.1",
    "apollo-server-express": "^2.21.1",
    "apollo-server-plugin-response-cache": "^0.6.0",
    "app-root-path": "^3.0.0",
    "body-parser": "^1.19.0",
    "cors": "^2.8.5",
    "dataloader": "^2.0.0",
    "dotenv": "^8.2.0",
    "envalid": "^7.2.2",
    "esm": "^3.2.25",
    "express": "^4.17.1",
    "graphql": "^14.7.0",
    "graphql-bigint": "^1.0.0",
    "graphql-nats-subscriptions": "^1.5.0",
    "graphql-subscriptions": "^1.2.0",
    "graphql-tools": "^6.0.0",
    "graphql-type-json": "^0.3.1",
    "inversify": "^5.0.1",
    "ioredis": "^4.14.0",
    "isomorphic-fetch": "^2.2.1",
    "knex": "^0.20.4",
    "lodash": "^4.17.15",
    "moleculer": "^0.14.2",
    "moleculer-zipkin": "0.2.2",
    "mongoose": "^5.13.5",
    "morgan": "^1.9.1",
    "nats": "^1.3.2",
    "react": "17.0.1",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^6.5.3",
    "rxjs-compat": "^6.5.3",
    "subscriptions-transport-ws": "0.9.18",
    "universal-cookie-express": "^4.0.1",
    "ws": "^7.2.1"
  },
  "devDependencies": {
    "cross-env": "^6.0.3",
    "pm2": "^4.2.1",
    "rimraf": "^3.0.0"
  },
  "peerDependencies": {
    "@cdm-logger/core": "*",
    "apollo-server-errors": "*",
    "mongodb": "*"
  },
  "typescript": {
    "definition": "dist/main.d.ts"
  }
}
\`\`\`

## servers/frontend-server/package.json

\`\`\`json
{
  "name": "sample-stack-frontend-server",
  "version": "0.0.1",
  "private": true,
  "description": "Sample Client server",
  "homepage": "https://github.com/cdmbase/fullstack-pro#readme",
  "bugs": {
    "url": "https://github.com/cdmbase/fullstack-pro/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/cdmbase/fullstack-pro.git"
  },
  "license": "MIT",
  "author": "CDMBase LLC",
  "main": "index.js",
  "scripts": {
    "prebuild": "yarn build:clean",
    "build": "cross-env NODE_ENV=production zen build",
    "build:clean": "rimraf dist .awcache",
    "build:debug": "cross-env DEBUGGING=true NODE_ENV=production zen build",
    "build:debug:verbose": "yarn build:debug -- -v",
    "build:dev": "cross-env NODE_ENV=development zen build",
    "docker:build": "cross-env NODE_OPTIONS='--max_old_space_size=4096' yarn build && docker build . -t $npm_package_name:$npm_package_version",
    "docker:build:debug": "yarn build:debug && docker build . -t $npm_package_name:$npm_package_version",
    "docker:run": "docker run  --env-file ../../config/staging/docker-staging.env  -p 3010:3010  -it $npm_package_name:$npm_package_version",
    "jest": "./node_modules/.bin/jest",
    "start": "cross-env NODE_ENV=production pm2-runtime  dist/index.js",
    "start:dev": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env node --harmony dist",
    "start:staging": "cross-env NODE_ENV=staging ENV_FILE=../../config/staging/staging.env node --harmony dist",
    "start:test": "cross-env NODE_ENV=test ENV_FILE=../../config/test/test.env node --harmony dist",
    "test": "jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env yarn zen:watch",
    "watch:debug": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env yarn zen:watch -- -v",
    "watch:ssr": "cross-env SSR=true && yarn watch",
    "watch:staging": "cross-env ENV_FILE=../../config/staging/staging.env yarn zen:watch",
    "watch:test": "cross-env ENV_FILE=../../config/test/test.env yarn zen:watch",
    "zen:watch": "zen watch -x"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js"
    ],
    "testRegex": "/__tests__/.*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "dependencies": {
    "@apollo/client": "~3.3.21",
    "@apollo/react-components": "^4.0.0",
    "@apollo/react-hoc": "^4.0.0",
    "@cdm-logger/client": "^7.0.8",
    "@cdm-logger/server": "^7.0.7",
    "@common-stack/client-core": "0.1.11",
    "@common-stack/client-react": "0.1.11",
    "@common-stack/core": "0.1.11",
    "@common-stack/server-core": "0.1.11",
    "@sample-stack/core": "link:../../packages/sample-core",
    "@sample-stack/counter-module-browser": "link:../../packages-modules/counter/browser",
    "@sample-stack/platform-browser": "link:../../packages/sample-platform/browser",
    "apollo-link-debounce": "^2.1.0",
    "apollo-link-logger": "^1.2.3",
    "apollo-logger": "^0.3.3",
    "browser-bunyan": "^1.6.3",
    "classnames": "^2.2.6",
    "connected-react-router": "^6.9.1",
    "cors": "^2.8.5",
    "dotenv": "^8.2.0",
    "envalid": "^7.2.2",
    "error-stack-parser": "^2.0.4",
    "esm": "^3.2.25",
    "express": "^4.17.1",
    "fela": "11.6.0",
    "fela-beautifier": "^11.6.0",
    "fela-dom": "11.6.0",
    "fela-font-renderer": "^5.0.25",
    "fela-perf": "^11.6.0",
    "fela-plugin-fallback-value": "^11.6.0",
    "fela-plugin-logger": "^11.6.0",
    "fela-plugin-lvha": "^5.0.16",
    "fela-plugin-prefixer": "^11.6.0",
    "fela-plugin-unit": "^11.6.0",
    "fela-plugin-validator": "^11.6.0",
    "fela-preset-web": "^11.6.0",
    "graphql": "^14.7.0",
    "graphql-tag": "^2.11.0",
    "history": "^4.10.1",
    "immutability-helper": "^3.0.1",
    "inversify": "^5.0.1",
    "isomorphic-fetch": "^2.2.1",
    "js-cookie": "^2.2.1",
    "lodash": "^4.17.15",
    "ramda": "^0.26.1",
    "react": "17.0.1",
    "react-dom": "17.0.1",
    "react-fela": "11.6.0",
    "react-helmet": "^6.1.0",
    "react-loadable": "^5.5.0",
    "react-redux": "^7.1.3",
    "react-router": "^5.2.1",
    "react-router-config": "^5.1.1",
    "react-router-dom": "^5.3.0",
    "react-transition-group": "^4.3.0",
    "redux": "^4.0.5",
    "redux-logger": "^3.0.6",
    "redux-observable": "^1.2.0",
    "redux-persist": "^6.0.0",
    "redux-thunk": "^2.3.0",
    "reflect-metadata": "^0.1.13",
    "reselect": "^4.0.0",
    "rxjs": "^6.5.3",
    "rxjs-compat": "^6.5.3",
    "rxjs-hooks": "^0.5.2",
    "serialize-javascript": "^4.0.0",
    "sourcemapped-stacktrace": "^1.1.11",
    "subscriptions-transport-ws": "0.9.18",
    "universal-cookie-express": "^4.0.1"
  },
  "devDependencies": {
    "@babel/polyfill": "7.7.0",
    "cross-env": "^6.0.3",
    "pm2": "^4.2.1",
    "raf": "3.4.1",
    "rimraf": "^3.0.0"
  },
  "peerDependencies": {
    "body-parser": "*"
  }
}
\`\`\`

## servers/moleculer-server/README.md

\`\`\`md
[![Moleculer](https://badgen.net/badge/Powered%20by/Moleculer/0e83cd)](https://moleculer.services)

# servers

## NPM scripts
- `yarn dev` - Start development mode (load all services locally with hot-reload & REPL)
- `yarn build`- Uses typescript to transpile service to javascript
- `npm start` - Start production mode (set `SERVICES` env variable to load certain services) (previous build needed)
- `yarn cli`: Start a CLI and connect to production. Don't forget to set production namespace with `--ns` argument in script
- `yarn ci` - Run continuous test mode with watching
- `npm test` - Run tests & generate coverage report
\`\`\`

## servers/moleculer-server/package.json

\`\`\`json
{
  "name": "sample-stack-moleculer-server",
  "version": "0.0.1",
  "private": true,
  "description": "My Moleculer microservices project",
  "keywords": [
    "microservices",
    "moleculer"
  ],
  "author": "",
  "scripts": {
    "prebuild": "yarn build:clean",
    "build": "cross-env NODE_ENV=production yarn build:dist",
    "build:clean": "rimraf dist",
    "build:debug": "cross-env DEBUGGING=true NODE_ENV=production yarn build:dist",
    "build:dist": "webpack",
    "build:watch": "yarn build:dist -- --watch",
    "cli": "moleculer connect --config ./dist/moleculer.config.js",
    "cli:dev": " cross-env ENV_FILE=../../config/development/dev.env yarn cli",
    "cli:docker": " cross-env NODE_ENV=staging ENV_FILE=../../config/staging/docker-staging.env  yarn cli",
    "cli:staging": " cross-env NODE_ENV=staging ENV_FILE=../../config/staging/staging.env  yarn cli",
    "cli:test": " cross-env NODE_ENV=test ENV_FILE=../../config/test/test.env  yarn cli",
    "docker:build": "yarn build && docker build . -t $npm_package_name:$npm_package_version",
    "docker:run": "docker run -it --env-file ../../config/staging/docker-staging.env  $npm_package_name:$npm_package_version",
    "jest": "./node_modules/.bin/jest",
    "start": "node dist/index.js",
    "start:dev": "cross-env ENV_FILE=../../config/development/dev.env nodemon dist",
    "start:staging": "cross-env NODE_ENV=staging ENV_FILE=../../config/staging/staging.env node --harmony dist",
    "start:test": "cross-env NODE_ENV=test ENV_FILE=../../config/test/test.env nodemon dist",
    "pretest": "yarn build",
    "test": "jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn start:dev"
  },
  "dependencies": {
    "@cdm-logger/client": "^7.0.8",
    "@cdm-logger/server": "^7.0.7",
    "@common-stack/client-core": "0.1.11",
    "@common-stack/core": "0.1.11",
    "@common-stack/server-core": "0.1.11",
    "@sample-stack/core": "link:../../packages/sample-core",
    "@sample-stack/counter-module-server": "link:../../packages-modules/counter/server",
    "@sample-stack/platform-server": "link:../../packages/sample-platform/server",
    "apollo-datasource": "^0.7.0",
    "apollo-logger": "^0.3.3",
    "apollo-server-cache-memcached": "^0.6.7",
    "apollo-server-cache-redis": "^1.2.3",
    "apollo-server-caching": "^0.5.3",
    "apollo-server-errors": "^2.4.2",
    "dotenv": "^8.2.0",
    "envalid": "^7.2.2",
    "esm": "^3.2.25",
    "graphql": "^14.7.0",
    "graphql-bigint": "^1.0.0",
    "graphql-nats-subscriptions": "^1.5.0",
    "graphql-subscriptions": "^1.2.0",
    "graphql-tag": "^2.11.0",
    "graphql-type-json": "^0.3.1",
    "helmet": "^3.21.2",
    "inversify": "^5.0.1",
    "inversify-logger-middleware": "^3.1.0",
    "ioredis": "^4.14.1",
    "iterall": "1.3.0",
    "lodash": "^4.17.15",
    "moleculer": "^0.14.2",
    "moleculer-zipkin": "0.2.2",
    "mongoose": "^5.13.5",
    "nats": "^1.3.2",
    "reflect-metadata": "^0.1.13"
  },
  "devDependencies": {
    "cross-env": "^6.0.3",
    "pm2": "^4.2.1",
    "rimraf": "^3.0.0"
  },
  "peerDependencies": {
    "@cdm-logger/core": "*"
  },
  "engines": {
    "node": ">= 8.x.x"
  }
}

\`\`\`

## tools/templates/module/browser/package.json

\`\`\`json
{
    "name": "@adminide-stack/$module$-browser",
    "version": "0.0.1",
    "description": "Sample core for higher packages to depend on",
    "main": "lib/index.js",
    "scripts": {
        "jest": "./node_modules/.bin/jest",
        "test": "cross-env ENV_FILE=../../config/test/test.env jest",
        "test:debug": "npm test -- --runInBand",
        "test:watch": "npm test -- --watch",
        "prepublish": "yarn build",
        "watch": "yarn build:lib:watch",
        "build": "yarn build:clean && yarn build:lib",
        "build:clean": "rimraf lib",
        "build:lib": "webpack",
        "build:lib:watch": "yarn build:lib -- --watch",
        "schema:download": "./node_modules/.bin/apollo-codegen download-schema http://localhost:8080/graphql --output schema.json ",
        "schema:generate": "./node_modules/.bin/apollo-codegen generate src/browser/graphql/**/*.gql --schema schema.json --target typescript --output src/browser/graphql/schema.ts",
        "githubschema:download": "./node_modules/.bin/apollo-codegen download-schema https://api.github.com/graphql --output githubapi-schema.json  --header 'Authorization: Bearer 0ec1b5e245de6061066262daf4aac2135fddd683'",
        "githubschema:generate": "./node_modules/.bin/apollo-codegen generate src/browser/graphql/**/*.gql --schema githubapi-schema.json --target typescript --output src/browser/graphql/github-schema.ts"
    },
    "jest": {
        "testEnvironment": "node",
        "roots": [
            "src"
        ],
        "modulePaths": [
            "node_modules"
        ],
        "moduleFileExtensions": [
            "ts",
            "tsx",
            "js",
            "json"
        ],
        "transform": {
            "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$"
    },
    "author": "CDMBase LLC",
    "license": "ISC",
    "devDependencies": {
        "cross-env": "^5.2.0",
        "jest": "^22.4.2",
        "rimraf": "^2.6.1",
        "webpack": "4.46.0"
    },
    "dependencies": {
    },
    "typings": "lib/index.d.ts",
    "typescript": {
        "definition": "lib/index.d.ts"
    }
}

\`\`\`

## tools/templates/module/server/package.json

\`\`\`json
{
    "name": "@adminide-stack/$module$-server",
    "version": "0.0.1",
    "description": "Sample core for higher packages to depend on",
    "main": "lib/index.js",
    "scripts": {
        "jest": "./node_modules/.bin/jest",
        "test": "cross-env ENV_FILE=../../config/test/test.env jest",
        "test:debug": "npm test -- --runInBand",
        "test:watch": "npm test -- --watch",
        "prepublish": "yarn build",
        "watch": "yarn build:lib:watch",
        "build": "yarn build:clean && yarn build:lib",
        "build:clean": "rimraf lib",
        "build:lib": "webpack",
        "build:lib:watch": "yarn build:lib -- --watch"
    },
    "jest": {
        "testEnvironment": "node",
        "roots": [
            "src"
        ],
        "modulePaths": [
            "node_modules"
        ],
        "moduleFileExtensions": [
            "ts",
            "tsx",
            "js",
            "json"
        ],
        "transform": {
            "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$"
    },
    "author": "CDMBase LLC",
    "license": "ISC",
    "devDependencies": {
        "apollo": "^2.9.0",
        "cross-env": "^5.2.0",
        "jest": "^22.4.2",
        "rimraf": "^2.6.1",
        "webpack": "4.46.0"
    },
    "typings": "lib/index.d.ts",
    "typescript": {
        "definition": "lib/index.d.ts"
    },
    "dependencies": {
    }
}

\`\`\`

## .eslintrc.js

\`\`\`js
const common = {
    env: {
        node: true,
        es6: true,
        'jest/globals': true,
    },
    plugins: ['prettier', 'jest', 'markdown'],
    extends: ['airbnb-base', 'prettier', 'plugin:jest/all'],
    rules: {
        'prettier/prettier': 'error',
        'jest/no-disabled-tests': 'warn',
        'jest/no-focused-tests': 'error',
        'jest/no-identical-title': 'error',
        'jest/prefer-to-have-length': 'warn',
        'jest/valid-expect': 'error',
        'jest/expect-expect': 'off',
        'jest/prefer-expect-assertions': 'off',
        'jest/no-test-return-statement': 'off',
        'import/prefer-default-export': 'off',
        'import/extensions': 'off',
        'no-console': 'off',
        'no-iterator': 'off',
        'no-restricted-syntax': 'off',
        'no-await-in-loop': 'off',
        'consistent-return': 'off',
        'no-shadow': 'off',
        'no-unused-vars': 'off',
    },
};

module.exports = {
    root: true,
    overrides: [
        {
            /*
        eslint-plugin-markdown only finds javascript code block snippet.
        For specific spec, refer to https://github.com/eslint/eslint-plugin-markdown
        */
            files: ['**/*.js', '**/*.md'],
            ...common,
        },
        {
            files: ['**/*.ts'],
            parser: '@typescript-eslint/parser',
            env: common.env,
            plugins: [...common.plugins, '@typescript-eslint'],
            extends: [
                ...common.extends,
                'plugin:@typescript-eslint/recommended',
                'plugin:import/errors',
                'plugin:import/warnings',
                'plugin:import/typescript',
            ],
            rules: {
                ...common.rules,
                '@typescript-eslint/explicit-function-return-type': 'off',
            },
            settings: {
                'import/resolver': {
                    node: {
                        extensions: ['.js', '.jsx', '.ts', '.d.ts', '.tsx', '.graphql', '.gql'],
                    },
                    typescript: {
                        // alwaysTryTypes: true,
                        // paths: './tsconfig.json',
                    },
                },
            },
        },
    ],
};

\`\`\`

## .markdownlint.json

\`\`\`json
{
    "default": true,
    "MD013": false,
    "MD042": false,
    "MD033": false
}
\`\`\`

## .vscode/extensions.json

\`\`\`json
{
"recommendations": [
    "dbaeumer.vscode-eslint"
]
}
\`\`\`

## .vscode/launch.json

\`\`\`json
{
    // Use IntelliSense to learn about possible Node.js debug attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            // Name of configuration; appears in the launch configuration drop down menu.
            "name": "Run jest",
            // Type of configuration. Possible values: "node", "mono".
            "type": "node",
            "request": "launch",
            // Workspace relative or absolute path to the program.
            "program": "${workspaceRoot}/node_modules/jest-cli/bin/jest.js",
            // Automatically stop program after launch.
            "stopOnEntry": false,
            // Command line arguments passed to the program.
            "args": [
                "--runInBand",
                "--testPathPattern",
                "index.test"
            ],
            // Workspace relative or absolute path to the working directory of the program being debugged. Default is the current workspace.
            "cwd": "${workspaceRoot}/packages/sample-graphql-schema",
            // Workspace relative or absolute path to the runtime executable to be used. Default is the runtime executable on the PATH.
            "runtimeExecutable": null,
            // Environment variables passed to the program.
            "env": {
                "NODE_ENV": "development"
            },
            "console": "integratedTerminal",
            "sourceMaps": false
        }
    ]
}
\`\`\`

## .vscode/settings.json

\`\`\`json
{
    "typescript.tsdk": "node_modules/typescript/lib"
}
\`\`\`

## babel.config.js

\`\`\`js
module.exports = {
    compact: false,
    presets: [
        '@babel/preset-typescript',
        '@babel/preset-react',
        ['@babel/preset-env', { modules: 'commonjs', loose: true }],
    ],
    plugins: [
        'react-hot-loader/babel',
        '@babel/plugin-transform-modules-commonjs',
        '@babel/plugin-transform-destructuring',
        '@babel/plugin-transform-for-of',
        '@babel/plugin-transform-regenerator',
        '@babel/plugin-transform-runtime',
        '@babel/plugin-syntax-dynamic-import',
        '@babel/plugin-proposal-class-properties',
        ['@babel/plugin-proposal-decorators', { legacy: true }],
        '@babel/plugin-proposal-object-rest-spread',
        //   ['styled-components', { ssr: true }],
        ['import', { libraryName: '@ant-design/react-native' }],
    ],
    env: {
        production: {
            compact: true,
        },
    },
};

\`\`\`

## commitlint.config.js

\`\`\`js
module.exports = {
    extends: ['@commitlint/config-conventional'],
    rules: {
        'header-max-length': [0, 'always', 100], // corresponding to maxHeaderWidth of commitizen
    },
};

\`\`\`

## config/development/settings.json

\`\`\`json
{
  "database": {
    "client": "sqlite3",
    "connection": {
      "filename": "dev-db.sqlite3"
    },
    "useNullAsDefault": true
  }
}
\`\`\`

## husky.config.js

\`\`\`js
module.exports = {
    hooks: {
        'pre-commit': 'lint-staged',
        //'pre-push': 'yarn test', // when production ready
    },
};
\`\`\`

## jest-mongodb-config.js

\`\`\`js
module.exports = {
    mongodbMemoryServerOptions: {
      instance: {
        dbName: 'jest'
      },
      binary: {
        version: '4.0.12', // Version of MongoDB
        skipMD5: true
      },
      autoStart: false
    }
  };
\`\`\`

## jest-transform-i18next.js

\`\`\`js
const fs = require('fs');
const path = require('path');

module.exports = {
    process() {
        const pathname = arguments[1];
        const dir = path.dirname(pathname);
        const locales = fs.readdirSync(dir);
        const result = {};
        for (const locale of locales) {
            if (fs.statSync(path.join(dir, locale)).isDirectory()) {
                const localeFiles = fs.readdirSync(path.join(dir, locale));
                for (const localeFile of localeFiles) {
                    if (localeFile.indexOf('.json') >= 0) {
                        result[locale] = JSON.parse(fs.readFileSync(path.join(dir, locale, localeFile), 'utf8'));
                    }
                }
            }
        }
        return {
            code: `module.exports = ${JSON.stringify(result)};`,
        };
    },
};

\`\`\`

## jest.config.base.js

\`\`\`js
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable @typescript-eslint/no-var-requires */
const { defaults } = require('jest-config');

module.exports = {
    testEnvironment: 'node',
    setupFiles: [
        // needed for UI to mock canvas load
        // "jest-canvas-mock"
    ],
    preset: 'ts-jest',
    testMatch: null,
    testRegex: '.*test*\\.(ts|tsx|js)$',
    testPathIgnorePatterns: ['/node_modules/', '/dist/'],
    transform: {
        '\\.(gql)$': 'jest-transform-graphql',
        '\\.(graphql|graphqls)$': 'jest-raw-loader',
        '\\.(ts|tsx)$': 'ts-jest',
        // Use our custom transformer only for the *.js and *.jsx files
        '\\.(js|jsx)?$': './transform.js',
        // future need to test with
        //  "^.+\\.(js|jsx|ts|tsx)$": "./transform.js",
        '.+\\.(css|styl|less|sass|scss)$': 'jest-css-modules-transform',
    },
    roots: ['packages', 'packages-modules', 'servers'],
    moduleFileExtensions: [
        'tsx', // TODO can be removed as default extension includes
        'ts', // TODO can be removed as default extension includes
        ...defaults.moduleFileExtensions,
        'js', // TODO can be removed as default extension includes
        'jsx', // TODO can be removed as default extension includes
        'json',
        'gql',
        'graphql',
    ],
    moduleNameMapper: {
        '^__mocks__/(.*)$': '<rootDir>/../../__mocks__/$1',
        // we'll use commonjs version of lodash for tests 👌
        // because we don't need to use any kind of tree shaking right?!
        '^lodash-es$': '<rootDir>/node_modules/lodash/index.js',
    },
    transformIgnorePatterns: ['/node_modules/(?!(babel-runtime|antd)).*/', '<rootDir>/node_modules/(?!lodash-es/.*)'],
    clearMocks: true,
    verbose: true,
    // projects: ['<rootDir>'], // TODO need to test with it https://github.com/bryan-hunter/yarn-workspace-lerna-monorepo/blob/master/jest.config.base.js
    coverageDirectory: '<rootDir>/coverage/',
    coveragePathIgnorePatterns: ['<rootDir>/build/', '<rootDir>/lib/', '<rootDir>/dist/', '<rootDir>/node_modules/'],
    globals: {
        __BACKEND_URL__: 'http://localhost:3010',
        __GRAPHQL_URL__: 'http://localhost:8085/graphql',
        'ts-jest': {
            // tsConfig: "<rootDir>/src/__tests__/tsconfig.json",
            // https://github.com/kulshekhar/ts-jest/issues/766
            diagnostics: {
                warnOnly: true,
            },
            // "skipBabel": true
        },
    },
};

\`\`\`

## jest.config.js

\`\`\`js
const merge = require('merge')
const baseConfig = require('./jest.config.base');
const mongodbConfig = require('./jest.config.mongodb')
module.exports = merge.recursive(
    baseConfig,
    mongodbConfig,
    {
        globals: {

        }
    },
    // https://baltuta.eu/posts/typescript-lerna-monorepo-more-tools 
    // {
    //     roots: ['<rootDir>'],
    //     projects: [
    //         '<rootDir>/packages/ui',
    //         '<rootDir>/packages/api',
    //         '<rootDir>/packages/diceroll'
    //     ],
    // }

);
\`\`\`

## jest.config.mongodb.js

\`\`\`js
module.exports = {
    preset: '@shelf/jest-mongodb',
};

\`\`\`

## lerna.json

\`\`\`json
{
  "changelog": {
    "repo": "cdmbase/lerna-bootstrap",
    "labels": {
      "tag: breaking change": ":boom: Breaking Change",
      "tag: new feature": ":rocket: New Feature",
      "tag: bug fix": ":bug: Bug Fix",
      "tag: polish": ":nail_care: Polish",
      "tag: documentation": "Documentation",
      "tag: internal": ":house: Internal"
    }
  },
  "command": {
    "publish": {
      "registry": "https://registry.npmjs.org",
      "graphType": "all",
      "allowBranch": [
        "publish",
        "devpublish"
      ],
      "message": "chore(release): publish",
      "ignoreChanges": [
        "**/__fixtures__/**",
        "**/__tests__/**",
        "**/*.md",
        "**/example/**"
      ]
    },
    "version": {
      "allowBranch": [
        "master",
        "develop",
        "publish",
        "devpublish"
      ],
      "conventionalCommits": true,
      "message": "chore: release package(s)"
    }
  },
  "npmClient": "yarn",
  "useWorkspaces": true,
  "packages": [
    "packages-modules/**",
    "packages/**",
    "servers/*",
    "portable-devices/*"
  ],
  "version": "0.0.0"
}
\`\`\`

## lint-staged.config.js

\`\`\`js
module.exports = {
    '*.{js,jsx,ts,tsx,json,md}': ['prettier --write', 'git add'],
    // '*.{ts,tsx}': ['eslint --fix'], // this can be tested
};
\`\`\`

## packages/sample-core/jest.config.js

\`\`\`js
const base = require('../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    name: packageJson.name,
    displayName: packageJson.name,
};

\`\`\`

## packages/sample-core/src/index.ts

\`\`\`ts
export interface PersonType {
    name: string;
    id: string;
    sex: string;
    matches: [PersonType];
}
export interface SomeType {
    testInt: number;
    testFloat: number;
    fixedString: string;
}

\`\`\`

## packages/sample-core/tsconfig.json

\`\`\`json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "../lib",
    "declarationDir": "lib"
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
\`\`\`

## packages/sample-core/webpack.config.js

\`\`\`js
const nodeExternals = require('webpack-node-externals');
const webpack = require('webpack');
const path = require('path');
const fs = require('fs');

const webpackOpts = {
    mode: 'development',
    entry: './src/index.ts',
    target: 'node',
    output: {
        path: path.join(__dirname, 'lib'),
        filename: 'index.js',
        libraryTarget: 'commonjs2',
    },
    resolve: {
        extensions: ['.ts', '.js'],
    },
    plugins: [
        new webpack.LoaderOptionsPlugin({
            options: {
                test: /\.ts$/,
                ts: {
                    compiler: 'typescript',
                    configFile: 'tsconfig.json',
                },
                tslint: {
                    emitErrors: true,
                    failOnHint: true,
                },
            },
        }),
    ],
    devtool: 'source-map',
    module: {
        rules: [
            {
                test: /\.ts$/,
                loaders: 'ts-loader',
            },
        ],
    },
    externals: [
        nodeExternals({ modulesDir: '../../node_modules' }),
        nodeExternals(),
    ],
};

module.exports = webpackOpts;

\`\`\`

## packages/sample-platform/browser/jest.config.js

\`\`\`js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    name: packageJson.name,
    displayName: packageJson.name,
};

\`\`\`

## packages/sample-platform/browser/src/api.ts

\`\`\`ts
// Simulate a flaky API around otherwise an otherwise synchronous `f()`.
const flakify = <T>(f: () => T): Promise<T> =>
    new Promise((resolve, reject) =>
        // We'll always take 200 * (1d10 + 1) ms to respond
        window.setTimeout(() => {
            try {
                // And ~20% of the time we'll fail
                if (Math.random() < 0.2) {
                    throw new Error('Failed arbitrarily');
                }

                resolve(f());
            } catch (e) {
                return reject(e);
            }
        }, 200 + Math.random() * 2000),
    );

export type Api = {
    save(x: { value: number }): Promise<null>;
    load(): Promise<{ value: number }>;
};

export const api: Api = {
    save: (counter) =>
        flakify(() => {
            localStorage.setItem('__counterValue', counter.value.toString());
            return null;
        }),
    load: () =>
        flakify(() => {
            const value = parseInt(localStorage.getItem('__counterValue'), 10);
            return { value };
        }),
};

\`\`\`

## packages/sample-platform/browser/src/components/Counter.tsx

\`\`\`tsx
import * as React from 'react';

export interface ICounterProps {
    label: string;
    counter: { value: number };
    isSaving: boolean;
    isLoading: boolean;
    error: string;
    increment: (n: number) => void;
    save: (n: number) => void;
    load: () => void;
}

export interface ICounterState {
}

export class CounterComponent extends React.Component<ICounterProps, ICounterState> {

    private _onClickIncrement = (e: React.SyntheticEvent<HTMLButtonElement>) => {
        e.preventDefault();
        this.props.increment(1);
    }

    private _onClickSave = (e: React.SyntheticEvent<HTMLButtonElement>) => {
        e.preventDefault();
        if (!this.props.isSaving) {
            this.props.save(this.props.counter.value);
        }
    }

    private _onClickLoad = (e: React.SyntheticEvent<HTMLButtonElement>) => {
        e.preventDefault();
        if (!this.props.isLoading) {
            this.props.load();
        }
    }

    public render(): JSX.Element {
        const { counter, label, isSaving, isLoading, error } = this.props;
        return (
            <form>
                <legend>{label}</legend>
                <pre>{JSON.stringify({ counter, isSaving, isLoading }, null, 2)}</pre>
                <button onClick={this._onClickIncrement}>click me!</button>
                <button disabled={isSaving} onClick={this._onClickSave}>{isSaving ? 'saving...' : 'save'}</button>
                <button disabled={isLoading} onClick={this._onClickLoad}>{isLoading ? 'loading...' : 'load'}</button>
                {error ? <div className="error">{error}</div> : null}
            </form>);
    }
}



\`\`\`

## packages/sample-platform/browser/src/components/NavBar.tsx

\`\`\`tsx
import * as React from 'react';
import { Link } from 'react-router-dom';

const NavBar = () => (
    <div>
        <div><Link to="/">Home</Link> <Link to="/hello">Hello</Link> <Link to="/counter">Counter</Link></div>
    </div>
);

export { NavBar };

\`\`\`

## packages/sample-platform/browser/src/components/index.ts

\`\`\`ts
export * from './Counter';

\`\`\`

## packages/sample-platform/browser/src/containers/Clock.tsx

\`\`\`tsx

\`\`\`

## packages/sample-platform/browser/src/containers/Counter.tsx

\`\`\`tsx
import {
  incrementCounter,
  loadCount,
  saveCount,
  Action,
  Store,
} from '../redux';
import { connect } from 'react-redux';
import * as redux from 'redux';
import { CounterComponent, ICounterProps } from '../components';

export type CounterOwnProps = {
  label: string;
  store?: Store.Sample;
};

const mapStateToProps = (state: Store.Sample) => ({
  counter: state['@sample-stack/counter'],
  isSaving: state['@sample-stack/isSaving'],
  isLoading: state['@sample-stack/isLoading'],
  error: state['@sample-stack/error'],
  
});

const mapDispatchToProps = (dispatch: Function) => ({
  increment: (n: number) =>
    dispatch(incrementCounter(n)),
  load: () =>
    dispatch(loadCount(null)),
  save: (value: number) =>
    dispatch(saveCount({ value })),
});

// const stateProps = mapStateToProps;
// const dispatchProps = returntypeof(mapDispatchToProps);
// type StateProps = typeof stateProps;
// type DispatchProps = typeof dispatchProps;

// https://github.com/DefinitelyTyped/DefinitelyTyped/issues/8787
export const Counter =
connect<any, any, any>(mapStateToProps, mapDispatchToProps)(CounterComponent);


\`\`\`

## packages/sample-platform/browser/src/containers/Loading.tsx

\`\`\`tsx
import * as React from 'react';

interface Props {}

const Loading: React.SFC<Props> = () => (
    <div>Loading</div>
);

// export const displayLoadingState = branch(
//     props => props.data.loading,
//     renderComponent(Loading)
// );

\`\`\`

## packages/sample-platform/browser/src/containers/PersonList.tsx

\`\`\`tsx
import * as React from 'react';
import { graphql } from '@apollo/react-hoc';
import compose from 'lodash/flowRight';
import { PERSONS_QUERY } from '../graphql';

export interface IPersonListProps {
    persons;
}
const PersonListComponent: React.SFC<IPersonListProps> = ({ persons }) => (
    <div>
        <h2>Persons:</h2>
       {persons && persons.map((person, i) => <div key={i}>{person.name}</div>)}
    </div>
);

export const PersonList: React.ComponentClass<{}> =
    compose(
        graphql<{}, any, {}, {}>(PERSONS_QUERY),
        // flattenProp('data'),
    )(PersonListComponent);

\`\`\`

## packages/sample-platform/browser/src/containers/ServerCounter.tsx

\`\`\`tsx
import * as React from 'react';
import update from 'immutability-helper';
import { graphql } from '@apollo/react-hoc';
import compose from 'lodash/flowRight';
import { CounterComponent, ICounterProps } from '../components';
import { COUNT_SUBSCRIPTION, COUNT_QUERY, ADD_COUNT_MUTATION,} from '../graphql';
import { logger } from '@cdm-logger/client';
type SubscriptionProps = {
    subscribeToMore: Function;
};

// class WithSubscriptionCounter extends React.Component<SubscriptionProps & ICounterProps, {}> {

//     public subscription;

//     constructor(props) {
//         super(props);
//     }

//     public componentWillReceiveProps(nextProps) {
//         if (!nextProps.loading) {
//             if (this.subscription) {
//                 this.subscription();
//                 this.subscription = null;
//             }

//             // Subscribe or re-subscribe
//             if (!this.subscription) {
//                 this.subscribeToCount();
//             }
//         }
//     }

//     public componentWillUnmount() {
//         if (this.subscription) {
//             this.subscription();
//         }
//     }

//     private subscribeToCount() {
//         const { subscribeToMore } = this.props;
//         this.subscription = subscribeToMore({
//             document: onCountUpdated,
//             variables: {},
//             updateQuery: (prev, { subscriptionData: { data: { countUpdated: { amount } } } }) => {
//                 return update(prev, {
//                     count: {
//                         amount: {
//                             $set: amount,
//                         },
//                     },
//                 });
//             },
//         });
//     }

//     public render() {
//         const { ICounerProps } = this.props;
//         return <CounterComponent />;
//     }
// }


// save(amount) {
//     return () => mutate({
//         variables: { amount },
//         updateQueries,
//     });
// },

type countOptions = any & {
    countData: any;
};

const updateQueries = {
    counter: (prev, { mutationResult }) => {
        const newAmount = mutationResult.data.addCount.amount;
        return update(prev, {
            count: {
                amount: {
                    $set: newAmount,
                },
            },
        });
    },
};

export const CounterWithApollo: React.ComponentClass = (compose(
    graphql<{}, any, {}, {}>(ADD_COUNT_MUTATION, {
        props: ({ ownProps, mutate }) => ({
            save: (amount) => {
                return () => mutate({
                    variables: { amount },
                    // optimisticResponse: {
                    //     __typename: 'Mutation',

                    // },
                });
            },
        }),
    }),
    graphql<{}, any, {}, {}>(ADD_COUNT_MUTATION, {
        props: ({ ownProps, mutate }) => ({
            increment: (amount) => {
                return () => mutate({
                    variables: { amount },
                    // updateQueries,
                });
            },
        }),
    }),
)(graphql<ICounterProps, countOptions, {}, {}>(COUNT_QUERY, {
    name: 'countData',
    props: ({ countData }: any) => {
        const newlog = logger.child({ childName: 'UIController' });
        newlog.debug('count data : (%j)', countData);
        return {
            subscribeToCount: params => {
                // logger.debug('count subscript data (%j)', params);
                return countData.subscribeToMore({
                    document: COUNT_SUBSCRIPTION,
                    variables: {},
                    updateQuery: (prev: any, { subscriptionData }) => {
                        const payload = subscriptionData.data && subscriptionData.data.subscribeToWorkspace;
                        if (!payload) {
                            return prev;
                        }
                        return payload;
                    },
                });
            },
            counter: countData.count && countData.count.amount,
            isLoading: countData.loading,
            isSaving: false,
            load: () => countData.count.amount,
            error: countData.error,
        };
    },
})(CounterComponent as any))
);

\`\`\`

## packages/sample-platform/browser/src/containers/__tests__/ApolloProvider.test.tsx

\`\`\`tsx
// import * as React from 'react';
// import { shallow } from 'enzyme';
// import { createStore } from 'redux';
// import * as PropTypes from 'prop-types';

// declare function require(name: string);
// import * as TestUtils from 'react-addons-test-utils';

// import ApolloClient from 'apollo-client';
// import { ApolloProvider } from 'react-apollo';
// import { InMemoryCache } from 'apollo-cache-inmemory';
// import { ApolloLink, Observable } from 'apollo-link';
// import { addTypenameToDocument } from 'apollo-utilities';

// interface ChildContext {
//     store: Object;
//     client: Object;
// }

// describe('<ApolloProvider /> Component', () => {

//     class Child extends React.Component<any, { store: any, client: any }> {
//         public static contextTypes: React.ValidationMap<any> = {
//             client: PropTypes.object.isRequired,
//             store: PropTypes.object.isRequired,
//         };

//         public context: ChildContext;

//         public render() {
//             return <div />;
//         }
//     }

//     const cache = new InMemoryCache();
//     const client = new ApolloClient();
//     const store = createStore(() => ({}));

//     it('should render children components', () => {
//         const wrapper = shallow(
//             <ApolloProvider store={store} client={client}>
//                 <div className="unique" />
//             </ApolloProvider>,
//         );

//         expect(wrapper.contains(<div className="unique" />)).toBe(true);
//     });
// });

\`\`\`

## packages/sample-platform/browser/src/containers/__tests__/Counter.test.tsx

\`\`\`tsx
// import 'jest';
// import * as React from 'react';
// import { shallow, mount } from 'enzyme';
// import * as Sinon from 'sinon';
// import * as TestUtils from 'react-dom/test-utils';
// import { createStore, combineReducers } from 'redux';
// import configureStore from 'redux-mock-store';
// import { Counter } from '../Counter';
// import { reducers, Store } from '@sample-stack/platform-browser';
// import { Provider } from 'react-redux';
// import './setup';


// describe('components/Counter', () => {
//   it('renders', () => {
//     const store: any = createStore(combineReducers<Store.Sample>(reducers));

//     expect(shallow(
//       <Counter label="a counter!" store={store} />,
//     ).shallow()).toMatchSnapshot();
//   });

//   describe('COUNTER --- react-redux clicking "increment"', () => {
//     let counter;
//     let store;

//     beforeEach(() => {
//       store = createStore(combineReducers(reducers));
//       counter = mount(
//         <Provider store={store}>
//           <Counter label="a counter!'" />
//         </Provider>,
//       );
//     });


//     it('+++ check Props after increments counter', () => {
//       const increment = counter.find('button').first();
//       increment.simulate('click');
//       increment.simulate('click');
//       increment.simulate('click');


//       const getText = () => counter.find('pre').text();
//       expect(JSON.parse(getText()).counter.value).toBe(3);

//     });
//   });
// });

\`\`\`

## packages/sample-platform/browser/src/containers/__tests__/PersonList.test.tsx

\`\`\`tsx
// import 'jest';
// import * as React from 'react';
// import { shallow, mount } from 'enzyme';
// import ApolloClient from 'apollo-client';
// import { MockedProvider } from 'react-apollo/test-utils';
// import './setup';

// declare function require(name: string);
// import * as TestUtils from 'react-addons-test-utils';
// import { createStore, combineReducers, applyMiddleware } from 'redux';
// import gql from 'graphql-tag';

// import { PersonList } from '../PersonList';
// import { reducers, Store } from '@sample-stack/platform-browser';
// import { ApolloProvider, graphql, createNetworkInterface } from 'react-apollo';
// import { database } from '@sample-stack/graphql-schema';
// import { mockNetworkInterface } from 'apollo-test-utils';
// import { PERSONS_QUERY } from '@sample-stack/platform-browser';

// describe('components/PersonList', () => {
//   it('renders correctly', (done) => {
//     const networkInterface = mockNetworkInterface({
//       request: { query: PERSONS_QUERY, variables: {} }, result: { data: database.persons },
//     });

//     const client = new ApolloClient({
//       networkInterface: networkInterface,
//     });


//     const store = createStore(combineReducers({
//       ...reducers,
//       apollo: client.reducer(),
//     }), applyMiddleware(client.middleware()));


//     expect(mount(
//       <ApolloProvider client={client} store={store}>
//         <PersonList />
//       </ApolloProvider>,
//     )).toMatchSnapshot();
//   });
// });

\`\`\`

## packages/sample-platform/browser/src/containers/__tests__/redux.test.tsx

\`\`\`tsx
// import * as React from 'react';
// import * as renderer from 'react-test-renderer';
// import { mount, shallow } from 'enzyme';
// import { createStore, combineReducers, applyMiddleware } from 'redux';
// import { connect } from 'react-redux';
// import { print } from 'graphql';
// import gql from 'graphql-tag';

// declare function require(name: string);

// import ApolloClient from 'apollo-client';
// import { ApolloProvider, graphql } from 'react-apollo';
// import { mockNetworkInterface } from 'react-apollo/test-utils';

// describe('redux integration', () => {
//     it('updates child props on state change', (done) => {
//         const query = gql`query people($first: Int) { allPeople(first: $first) { people { name } } }`;
//         const data = { allPeople: { people: [{ name: 'Luke Skywalker' }] } };
//         const variables = { first: 1 };

//         const data2 = { allPeople: { people: [{ name: 'Leia Skywalker' }] } };
//         const variables2 = { first: 2 };

//         const networkInterface = mockNetworkInterface(
//             { request: { query, variables }, result: { data } },
//             { request: { query, variables: variables2 }, result: { data: data2 } },
//         );


//         const client = new ApolloClient({ networkInterface, addTypename: false });
//         let wrapper;

//         function counter(state = 1, action) {
//             switch (action.type) {
//                 case 'INCREMENT':
//                     return state + 1;
//                 default:
//                     return state;
//             }
//         }

//         // Typscript workaround
//         const apolloReducer = client.reducer() as () => any;

//         const store = createStore(
//             combineReducers({
//                 counter,
//                 apollo: apolloReducer,
//             }),
//             applyMiddleware(client.middleware()),
//         );


//         class Component extends React.Component<any, any> {
//             public componentWillReceiveProps(nextProps) {
//                 // trigger redux action
//                 if (nextProps.first === 1) {
//                     this.props.dispatch({ type: 'INCREMENT' });
//                 }

//                 if (nextProps.first === 2) {
//                     if (nextProps.data.loading) { return; }
//                     expect(nextProps.data.allPeople.people).toContain(data2.allPeople.people);
//                     done();
//                 }

//             }
//             public render() {
//                 return null;
//             }
//         }
//         const Container: React.ComponentClass<{}> = compose(
//             connect((state) => ({ first: state.counter })),
//             graphql(query),
//             flattenProp('data'),
//             pure,
//         )(Component);

//         wrapper = renderer.create(
//             <ApolloProvider client={client} store={store}>
//                 <Container />
//             </ApolloProvider>,
//         );
//     });

// });

\`\`\`

## packages/sample-platform/browser/src/containers/__tests__/setup.ts

\`\`\`ts
/* setup.js */

const { jsdom } = require('jsdom');

const exposedProperties = ['window', 'navigator', 'document'];

(<any>global).document = jsdom('');
(<any>global).window = document.defaultView;
Object.keys(document.defaultView).forEach((property) => {
    if (typeof global[property] === 'undefined') {
        exposedProperties.push(property);
        global[property] = document.defaultView[property];
    }
});

(<any>global).navigator = {
    userAgent: 'node.js',
};

\`\`\`

## packages/sample-platform/browser/src/containers/__tests__/utils.ts

\`\`\`ts
/**
 * Call this helper inside async test to let promises finish, because they are allways async.
 */
export const nextTick = () =>
    new Promise((resolve) => setTimeout(resolve, 200));

\`\`\`

## packages/sample-platform/browser/src/containers/index.ts

\`\`\`ts
export * from './Counter';
export * from './PersonList';
// export * from './Loading';
export * from './ServerCounter';

\`\`\`

## packages/sample-platform/browser/src/graphql/index.ts

\`\`\`ts
export * from './mutations';
export * from './queries';
export * from './subscriptions';

\`\`\`

## packages/sample-platform/browser/src/graphql/mutations/index.ts

\`\`\`ts
export const ADD_PERSON_MUTATION = require('./addPerson');
export const ADD_COUNT_MUTATION = require('./addCount');

\`\`\`

## packages/sample-platform/browser/src/graphql/queries/index.ts

\`\`\`ts
export const PERSON_QUERY = require('./person');
export const PERSONS_QUERY = require('./persons');
export const COUNT_QUERY = require('./count');

\`\`\`

## packages/sample-platform/browser/src/graphql/subscriptions/index.ts

\`\`\`ts
export const COUNT_SUBSCRIPTION = require('./count');

\`\`\`

## packages/sample-platform/browser/src/index.ts

\`\`\`ts
import PlatformModule from './module';
export * from './graphql';
export * from './components';
export * from './containers';


export default PlatformModule;

\`\`\`

## packages/sample-platform/browser/src/inversify-containers/index.ts

\`\`\`ts
export * from './module';

\`\`\`

## packages/sample-platform/browser/src/inversify-containers/module.ts

\`\`\`ts
import { ContainerModule, interfaces, Container } from 'inversify';

export const platformModule: () => interfaces.ContainerModule = () =>
    new ContainerModule((bind: interfaces.Bind) => {});

\`\`\`

## packages/sample-platform/browser/src/module.ts

\`\`\`ts
import { Feature } from '@common-stack/client-react';

import { interfaces } from 'inversify';
import { ApolloClient } from '@apollo/client';
import { ClientTypes as BrowserTypes } from '@common-stack/client-core';
import { platformModule } from './inversify-containers';

const platformServiceGen = (container: interfaces.Container) => ({
    apolloClient: container.get<ApolloClient<any>>(BrowserTypes.ApolloClient),
    cache: container.get<any>(BrowserTypes.InMemoryCache),
    utility: container.get(BrowserTypes.UtilityClass),
});
export default new Feature({
    createContainerFunc: platformModule,
    createServiceFunc: platformServiceGen,
});

\`\`\`

## packages/sample-platform/browser/src/redux/__mocks__/api.ts

\`\`\`ts
export const api = {
    save: jest.fn(),
    load: jest.fn(),
};

\`\`\`

## packages/sample-platform/browser/src/redux/actions/__tests__/sampleActions.test.ts

\`\`\`ts
import 'jest';

import { createStore } from 'redux';
import * as apiExports from '../../api';
import * as actions from '../sampleActions';

jest.mock('../../api');

const api: jest.Mocked<apiExports.Api> = apiExports.api as any;

describe('actions', () => {
    const store = () => {
        const reducer = jest.fn();
        const { dispatch } = createStore(reducer);
        reducer.mockReset(); // ignore @@redux/INIT
        return { dispatch, reducer };
    };

    const eventually = (assertFn) =>
        new Promise((resolve, reject) => {
            setTimeout(() => {
                try {
                    assertFn();
                } catch (e) {
                    return reject(e);
                }
                resolve();
            }, 1);
        });

    const expectTypes = (reducer, types) => () =>
        expect(reducer.mock.calls.map((x) => x[1].type)).toEqual(types);

    describe('.saveCount', () => {
        beforeEach(() => {
            api.save.mockReturnValue(Promise.resolve(null));
        });

        it('sends an API request', () => {
            actions.saveCount({ value: 14 })(jest.fn());
            expect(api.save.mock.calls).toHaveLength(1);
        });

        describe('when API request succeeds', () => {
            it('dispatches @@sample-stack/SAVE_COUNT_SUCCESS', () => {
                const { dispatch, reducer } = store();
                actions.saveCount({ value: 14 })(dispatch);
                return eventually(
                    expectTypes(reducer, [
                        '@@sample-stack/SAVE_COUNT_REQUEST',
                        '@@sample-stack/SAVE_COUNT_SUCCESS',
                    ]),
                );
            });
        });

        describe('when API request fails', () => {
            beforeEach(() => {
                api.save.mockReturnValue(
                    Promise.reject(new Error('something terrible happened')),
                );
            });

            it('dispatches @@sample-stack/SAVE_COUNT_ERROR', () => {
                const { dispatch, reducer } = store();
                actions.saveCount({ value: 14 })(dispatch);
                return eventually(
                    expectTypes(reducer, [
                        '@@sample-stack/SAVE_COUNT_REQUEST',
                        '@@sample-stack/SAVE_COUNT_ERROR',
                    ]),
                );
            });

            it('includes error message with @@sample-stack/SAVE_COUNT_ERROR', () => {
                const { dispatch, reducer } = store();
                actions.saveCount({ value: 14 })(dispatch);
                return eventually(() => {
                    expect(reducer.mock.calls[1][1].error.message).toEqual(
                        'something terrible happened',
                    );
                });
            });

            it('includes request with @@sample-stack/SAVE_COUNT_ERROR for convenience', () => {
                const { dispatch, reducer } = store();
                actions.saveCount({ value: 14 })(dispatch);
                return eventually(() => {
                    expect(reducer.mock.calls[1][1].request).toEqual({
                        value: 14,
                    });
                });
            });
        });
    });

    describe('.loadCount', () => {
        beforeEach(() => {
            api.load.mockReturnValue(Promise.resolve({ value: 14 }));
        });

        it('sends an API request', () => {
            actions.loadCount(null)(jest.fn());
            expect(api.load.mock.calls).toHaveLength(1);
        });

        describe('when API request succeeds', () => {
            it('dispatches @sample-stack/LOAD_COUNT_SUCCESS', () => {
                const { dispatch, reducer } = store();
                actions.loadCount(null)(dispatch);
                return eventually(
                    expectTypes(reducer, [
                        '@@sample-stack/LOAD_COUNT_REQUEST',
                        '@@sample-stack/LOAD_COUNT_SUCCESS',
                    ]),
                );
            });

            it('includes new value with LOAD_COUNT_SUCCESS', () => {
                const { dispatch, reducer } = store();
                actions.loadCount(null)(dispatch);
                return eventually(() => {
                    expect(reducer.mock.calls[1][1].response).toEqual({
                        value: 14,
                    });
                });
            });
        });

        describe('when API request fails', () => {
            beforeEach(() => {
                api.load.mockReturnValue(
                    Promise.reject(new Error('something terrible happened')),
                );
            });

            it('dispatches @@sample-stack/LOAD_COUNT_ERROR', () => {
                const { dispatch, reducer } = store();
                actions.loadCount(null)(dispatch);
                return eventually(
                    expectTypes(reducer, [
                        '@@sample-stack/LOAD_COUNT_REQUEST',
                        '@@sample-stack/LOAD_COUNT_ERROR',
                    ]),
                );
            });

            it('includes error message with @@sample-stack/LOAD_COUNT_ERROR', () => {
                const { dispatch, reducer } = store();
                actions.loadCount(null)(dispatch);
                return eventually(() => {
                    expect(reducer.mock.calls[1][1].error.message).toEqual(
                        'something terrible happened',
                    );
                });
            });
        });
    });
});

\`\`\`

## packages/sample-platform/browser/src/redux/actions/index.ts

\`\`\`ts
export * from './sampleActions';

\`\`\`

## packages/sample-platform/browser/src/redux/actions/sampleActions.ts

\`\`\`ts
import * as redux from 'redux';

import { api } from '../../api';
import { Store } from '../reducers/index';

export type Q<T> = { request: T };
export type S<T> = { response: T };
export type E = { error: Error };

export type QEmpty = Q<null>;
export type QValue = Q<{ value: number }>;

export type Action =
    // UI actions
    | { type: '@@sample-stack/INCREMENT_COUNTER'; delta: number }
    | { type: '@@sample-stack/RESET_COUNTER' }

    // API Requests
    | ({ type: '@@sample-stack/SAVE_COUNT_REQUEST' } & QValue)
    | ({ type: '@@sample-stack/SAVE_COUNT_SUCCESS' } & QValue & S<{}>)
    | ({ type: '@@sample-stack/SAVE_COUNT_ERROR' } & QValue & E)
    | ({ type: '@@sample-stack/LOAD_COUNT_REQUEST' } & QEmpty)
    | ({ type: '@@sample-stack/LOAD_COUNT_SUCCESS' } & QEmpty &
          S<{ value: number }>)
    | ({ type: '@@sample-stack/LOAD_COUNT_ERROR' } & QEmpty & E);

export const incrementCounter = (delta: number): Action => ({
    type: '@@sample-stack/INCREMENT_COUNTER',
    delta,
});

export const resetCounter = (): Action => ({
    type: '@@sample-stack/RESET_COUNTER',
});

export type ApiActionGroup<_Q, _S> = {
    request: (q?: _Q) => Action & Q<_Q>;
    success: (s: _S, q?: _Q) => Action & Q<_Q> & S<_S>;
    error: (e: Error, q?: _Q) => Action & Q<_Q> & E;
};

const _saveCount: ApiActionGroup<{ value: number }, {}> = {
    request: (request) => ({
        type: '@@sample-stack/SAVE_COUNT_REQUEST',
        request,
    }),
    success: (response, request) => ({
        type: '@@sample-stack/SAVE_COUNT_SUCCESS',
        request,
        response,
    }),
    error: (error, request) => ({
        type: '@@sample-stack/SAVE_COUNT_ERROR',
        request,
        error,
    }),
};

const _loadCount: ApiActionGroup<null, { value: number }> = {
    request: (request) => ({
        type: '@@sample-stack/LOAD_COUNT_REQUEST',
        request: null,
    }),
    success: (response, request) => ({
        type: '@@sample-stack/LOAD_COUNT_SUCCESS',
        request: null,
        response,
    }),
    error: (error, request) => ({
        type: '@@sample-stack/LOAD_COUNT_ERROR',
        request: null,
        error,
    }),
};

type apiFunc<Q, S> = (q: Q) => Promise<S>;

function apiActionGroupFactory<Q, S>(
    x: ApiActionGroup<Q, S>,
    go: apiFunc<Q, S>,
) {
    return (request: Q) => (dispatch: redux.Dispatch) => {
        dispatch(x.request(request));
        go(request)
            .then((response) => dispatch(x.success(response, request)))
            .catch((e: Error) => dispatch(x.error(e, request)));
    };
}

export const saveCount = apiActionGroupFactory(_saveCount, api.save);
export const loadCount = apiActionGroupFactory(_loadCount, api.load);

\`\`\`

## packages/sample-platform/browser/src/redux/index.ts

\`\`\`ts
export * from './actions';
export * from './reducers';

\`\`\`

## packages/sample-platform/browser/src/redux/reducers/Store.ts

\`\`\`ts
export namespace Store {
    export type Counter = { value: number };

    export type Sample = {
        '@sample-stack/counter': Counter;
        '@sample-stack/isSaving': boolean;
        '@sample-stack/isLoading': boolean;
        '@sample-stack/error': string;
    };
}

\`\`\`

## packages/sample-platform/browser/src/redux/reducers/__tests__/sampleReducers.test.ts

\`\`\`ts
import 'jest';
import { createStore, combineReducers } from 'redux';

import { reducers } from '../sampleReducers';
import { Store } from '../Store';

import { incrementCounter } from '../../actions';

describe('reducers/counter', () => {
    it('starts at 0', () => {
        const store = createStore(combineReducers<Store.Sample>(reducers));
        const counter = store.getState()['@sample-stack/counter'];
        expect(counter.value).toEqual(0);
    });

    it('increments', (done) => {
        const store = createStore(combineReducers<Store.Sample>(reducers));
        store.subscribe(() => {
            const counter = store.getState()['@sample-stack/counter'];
            expect(counter.value).toEqual(3);
            done();
        });
        store.dispatch(incrementCounter(3));
    });

    it('restores state', (done) => {
        const store = createStore(combineReducers<Store.Sample>(reducers));
        store.subscribe(() => {
            const counter = store.getState()['@sample-stack/counter'];
            expect(counter.value).toEqual(14);
            done();
        });
        store.dispatch({
            type: '@@sample-stack/LOAD_COUNT_SUCCESS',
            request: {},
            response: { value: 14 },
        });
    });
});

\`\`\`

## packages/sample-platform/browser/src/redux/reducers/index.ts

\`\`\`ts
import { reducers as sampleReducers } from './sampleReducers';

export { Store } from './Store';

export const reducers = {
    ...sampleReducers,
};

\`\`\`

## packages/sample-platform/browser/src/redux/reducers/sampleReducers.ts

\`\`\`ts
import { combineReducers, Action as reduxAction } from 'redux';
import { Action } from '../actions';
import { Store } from './Store';

function isSaving(state = false, action: Action): boolean {
    switch (action.type) {
        case '@@sample-stack/SAVE_COUNT_REQUEST':
            return true;
        case '@@sample-stack/SAVE_COUNT_SUCCESS':
        case '@@sample-stack/SAVE_COUNT_ERROR':
            return false;
        default:
            return state;
    }
}

function isLoading(state = false, action: Action): boolean {
    switch (action.type) {
        case '@@sample-stack/LOAD_COUNT_REQUEST':
            return true;
        case '@@sample-stack/LOAD_COUNT_SUCCESS':
        case '@@sample-stack/LOAD_COUNT_ERROR':
            return false;
        default:
            return state;
    }
}

function error(state = '', action: Action): string {
    switch (action.type) {
        case '@@sample-stack/LOAD_COUNT_REQUEST':
        case '@@sample-stack/SAVE_COUNT_REQUEST':
            return '';
        case '@@sample-stack/LOAD_COUNT_ERROR':
        case '@@sample-stack/SAVE_COUNT_ERROR':
            return action.error.toString();
        default:
            return state;
    }
}

const initialState: Store.Counter = {
    value: 0,
};

function counter(
    state: Store.Counter = initialState,
    action: Action,
): Store.Counter {
    switch (action.type) {
        case '@@sample-stack/INCREMENT_COUNTER':
            const { delta } = action;
            return { value: state.value + delta };

        case '@@sample-stack/RESET_COUNTER':
            return { value: 0 };

        case '@@sample-stack/LOAD_COUNT_SUCCESS':
            return { value: action.response.value };

        default:
            return state;
    }
}

export const reducers = {
    '@sample-stack/counter': counter,
    '@sample-stack/isSaving': isSaving,
    '@sample-stack/isLoading': isLoading,
    '@sample-stack/error': error,
};

\`\`\`

## packages/sample-platform/browser/src/services/index.ts

\`\`\`ts

\`\`\`

## packages/sample-platform/browser/tsconfig.json

\`\`\`json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "esModuleInterop": true,
    "rootDir": "./src",
    "outDir": "../lib",
    "declarationDir": "lib"
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
\`\`\`

## packages/sample-platform/browser/webpack.config.js

\`\`\`js
const nodeExternals = require('webpack-node-externals');
const webpack = require('webpack');
const path = require('path');
const fs = require('fs');

const webpackOpts = {
    mode: 'development',
    entry: './src/index.ts',
    target: 'node',
    output: {
        path: path.join(__dirname, 'lib'),
        filename: 'index.js',
        libraryTarget: 'commonjs2',
    },
    node: {
        __dirname: false,
    },
    resolve: {
        extensions: ['.ts', '.tsx', '.graphql', '.gql'],
    },
    plugins: [
        new webpack.LoaderOptionsPlugin({
            options: {
                test: /\.tsx?$/,
                ts: {
                    compiler: 'typescript',
                    configFile: 'tsconfig.json',
                },
                tslint: {
                    emitErrors: true,
                    failOnHint: true,
                },
            },
        }),
    ],
    devtool: 'source-map',
    module: {
        rules: [
            {
                test: /\.tsx?$/,
                loaders: 'ts-loader',
            },
            {
                test: /\.graphql?/,
                exclude: /node_modules/,
                use: 'raw-loader',
            },
            {
                test: /\.(gql)$/,
                exclude: /node_modules/,
                use: ['graphql-tag/loader'],
            },
        ],
    },
    externals: [nodeExternals({ modulesDir: '../../../node_modules' }), nodeExternals()],
};

module.exports = webpackOpts;

\`\`\`

## packages/sample-platform/server/jest.config.js

\`\`\`js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    name: packageJson.name,
    displayName: packageJson.name,
};

\`\`\`

## packages/sample-platform/server/src/index.ts

\`\`\`ts

\`\`\`

## packages/sample-platform/server/tsconfig.json

\`\`\`json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "experimentalDecorators": true,
    "preserveConstEnums": true,
    "rootDir": "./src",
    "outDir": "../lib",
    "declarationDir": "lib"
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js",
  ],
}
\`\`\`

## packages/sample-platform/server/webpack.config.js

\`\`\`js
const nodeExternals = require('webpack-node-externals');
const webpack = require('webpack');
const path = require('path');
const glob = require('glob');
const fs = require('fs');

const webpackOpts = {
    mode: 'development',
    entry: {
        index: './src/index.ts',
    },
    target: 'node',
    output: {
        path: path.join(__dirname, 'lib'),
        filename: '[name].js',
        libraryTarget: 'commonjs2',
    },
    resolve: {
        extensions: ['.ejs', '.ts', '.tsx', '.graphql', '.gql'],
    },
    plugins: [
        new webpack.LoaderOptionsPlugin({
            options: {
                test: /\.ts$/,
                ts: {
                    compiler: 'typescript',
                    configFile: 'tsconfig.json',
                },
                tslint: {
                    emitErrors: true,
                    failOnHint: true,
                },
            },
        }),
    ],
    devtool: 'source-map',
    module: {
        rules: [
            {
                test: /\.ts$/,
                loaders: 'ts-loader',
            },
            {
                test: /\.graphql?/,
                exclude: /node_modules/,
                use: 'raw-loader',
            },
            {
                test: /\.(gql)$/,
                exclude: /node_modules/,
                use: ['graphql-tag/loader'],
            },
            {
                test: /\.ejs$/,
                exclude: /node_modules/,
                use: 'raw-loader',
            },
        ],
    },
    externals: [
        nodeExternals({ modulesDir: '../../../node_modules' }),
        nodeExternals(),
    ],
};

module.exports = webpackOpts;

\`\`\`

## packages/sample-store/src/__tests__/counter-hemera-repository.test.ts

\`\`\`ts
// import 'reflect-metadata';

// import * as Hemera from 'nats-hemera';
// import * as Nats from 'nats';
// import * as HemeraTestSuite from 'hemera-testsuite';
// import * as HemeraSqlStore from 'hemera-sql-store';
// import { CounterRemoteRepository } from '../repository/counter-hemera-repository';
// import { createCounter, dropCounter, Counter_Table } from '../database-store/migrations/counter';
// import * as knex from 'knex';
// import { logger } from '@cdm-logger/server';

// require('dotenv').config({ path: process.env.ENV_FILE });

// import 'jest';

// describe('Hemera-sql-store', function () {
//     let PORT = 6242;
//     let authUrl = 'nats://localhost:' + PORT;
//     let server;
//     let hemera;
//     let testDatabase = process.env.DB_DATABASE;
//     let testTable = Counter_Table;
//     let repo: CounterRemoteRepository;

//     beforeAll(async (done) => {
//         server = HemeraTestSuite.start_server(PORT, () => {
//             const nats = Nats.connect(authUrl);
//             hemera = new Hemera(nats, {});
//             hemera.use(require('hemera-safe-promises'));
//             hemera.use(HemeraSqlStore, {
//                 knex: {
//                     dialect: 'mysql',
//                     connection: {
//                         host: process.env.DB_HOST,
//                         user: process.env.DB_USER,
//                         password: process.env.DB_PASSWORD,
//                         database: testDatabase,
//                     },
//                     pool: {
//                         min: 0,
//                         max: 7,
//                     },
//                 },
//             });
//             hemera.ready(async () => {
//                 await createCounter(hemera.sqlStore.useDb(testDatabase));
//                 repo = new CounterRemoteRepository(hemera);
//                 done();
//             });
//         });
//     });

//     afterAll(async () => {
//         await dropCounter(hemera.sqlStore.useDb(testDatabase));
//         hemera.close();
//         server.kill();
//     });

//     it('create', async (done) => {
//         const count = { id: 1, amount: 1 };
//         try {
//             const addCoutOutput = await repo.create(count);
//             expect(addCoutOutput).toEqual([1]);
//             done();
//         } catch (err) {
//             logger.error(err);
//             done.fail();
//         }
//     });

//     it('getById', async (done) => {
//         try {
//             const count = await repo.getById(1);
//             expect(count[0].amount).toEqual(1);
//             done();
//         } catch (err) {
//             logger.error(err);
//             done.fail();
//         }
//     });
//     it('getCount', async (done) => {
//         try {
//             const count = await repo.getCount();
//             done();
//         } catch (err) {
//             logger.error(err);
//             done.fail();
//         }
//     });

//     it('addCount', async (done) => {
//         try {
//             await repo.addCount(1);
//             done();
//         } catch (err) {
//             logger.error(err);
//             done.fail();
//         }
//     });
// });

\`\`\`

## packages/sample-store/src/__tests__/counter-repository.test.ts

\`\`\`ts
import 'reflect-metadata';
import 'jest';

import { Container } from 'inversify';
import * as Knex from 'knex';

import { TYPES } from '../constants';
import { DbConfig } from '../db-helpers';
import { CounterRepository, ICounterRepository } from '../repository';

const DEFAULT_DB_CONFIG = require('./db/config.json');

describe('dI Test', () => {
    let container: Container;
    let knex;
    beforeAll(async () => {
        knex = Knex(DEFAULT_DB_CONFIG);
        await knex.migrate.latest();
        await knex.seed.run();

        const dbConfig = new DbConfig(DEFAULT_DB_CONFIG);
        container = new Container();

        container.bind<DbConfig>('DefaultDbConfig').toConstantValue(dbConfig);

        // container...
        container
            .bind<ICounterRepository>(TYPES.ICounterRepository)
            .to(CounterRepository);
    });

    afterAll(() => {
        knex.destroy();
    });

    it('counter', async () => {
        const repository = container.get<ICounterRepository>(
            TYPES.ICounterRepository,
        );
        expect(repository).toBeInstanceOf(CounterRepository);
        try {
            const count = await repository.getById(1);
            expect(count.amount).toEqual(5);
        } catch (e) {
            expect(e).toBeUndefined();
        }
    });

    it('add counter', async () => {
        const repository = container.get<ICounterRepository>(
            TYPES.ICounterRepository,
        );
        try {
            await repository.addCount(2);
            const cnt = await repository.getCount();
            expect(cnt.amount).toEqual(7);
        } catch (e) {
            expect(e).toBeUndefined();
        }
    });
});

\`\`\`

## packages/sample-store/src/__tests__/db/config.json

\`\`\`json
{
    "client": "sqlite3",
    "connection": {
        "filename": "packages/sample-store/__tests__/db/test-db.sqlite3"
    },
    "seeds": {
        "directory": "packages/sample-store/__tests__/db/seeds"
    },
    "migrations": {
        "directory": "packages/sample-store/__tests__/db/migrations"
    },
    "useNullAsDefault": true
}
\`\`\`

## packages/sample-store/src/__tests__/db/migrations/counter.ts

\`\`\`ts
import * as Knex from 'knex';

export async function up(knex: Knex) {
    return knex.schema.createTable('count', (table) => {
        table.increments();
        table.timestamps();
        table.integer('amount').notNullable();
    });
}

export async function down(knex: Knex) {
    return knex.schema.dropTable('count');
}

\`\`\`

## packages/sample-store/src/__tests__/db/seeds/counter.ts

\`\`\`ts
import * as Knex from 'knex';

const initialAmount = 5;

export async function seed(knex: Knex) {
    await knex('count').truncate();

    return knex('count').insert({ amount: initialAmount });
}

\`\`\`

## packages/sample-store/src/constants/constants.ts

\`\`\`ts
export const TYPES = {
    ICounterRepository: Symbol('ICounterRepository'),
};

\`\`\`

## packages/sample-store/src/constants/index.ts

\`\`\`ts
export * from './constants';

\`\`\`

## packages/sample-store/src/container/index.ts

\`\`\`ts
export * from './module';

\`\`\`

## packages/sample-store/src/container/module.ts

\`\`\`ts
import { TaggedType } from '@common-stack/core';
import { ContainerModule, interfaces } from 'inversify';

import { TYPES } from '../constants';
import { DbConfig } from '../db-helpers';
import { CounterRepository, ICounterRepository } from '../repository';

export const repositoryModule: (
    config: DbConfig,
) => interfaces.ContainerModule = (dbConfig) =>
    new ContainerModule((bind: interfaces.Bind) => {
        bind<DbConfig>('DefaultDbConfig').toConstantValue(dbConfig);
        bind<ICounterRepository>(TYPES.ICounterRepository)
            .to(CounterRepository)
            .whenTargetIsDefault();

        // bind<ICounterRepository>(TYPES.ICounterRepository)
        //     .to(CounterRemoteRepository)
        //     .whenTargetNamed(TaggedType.MICROSERVICE);
    });

\`\`\`

## packages/sample-store/src/database-store/migrations/counter.ts

\`\`\`ts
import * as Knex from 'knex';

export const Counter_Table = 'count';
export const createCounter = async (driver) =>
    driver.schema.createTable(Counter_Table, (table) => {
        table.increments();
        table.timestamps(false, true);
        table.integer('amount').notNull();
    });
export const dropCounter = async (driver) =>
    driver.schema.dropTable(Counter_Table);

export async function up(knex: Knex) {
    return createCounter(knex);
}

export async function down(knex: Knex) {
    return dropCounter(knex);
}

\`\`\`

## packages/sample-store/src/database-store/migrations/index.ts

\`\`\`ts
// empty file on purpose
exports.up = function () {};
exports.down = function () {};

\`\`\`

## packages/sample-store/src/database-store/seeds/counter.ts

\`\`\`ts
import * as Knex from 'knex';

const initialAmount = 5;

export async function seed(knex: Knex) {
    await knex('count').truncate();

    return knex('count').insert({ amount: initialAmount });
}

\`\`\`

## packages/sample-store/src/database-store/seeds/index.ts

\`\`\`ts
// empty file on purpose
// empty file on purpose
exports.seed = function () {};

\`\`\`

## packages/sample-store/src/db-helpers/abstract-repository.ts

\`\`\`ts
import { inject, injectable } from 'inversify';
import * as Knex from 'knex';

import { DbConfig } from './db-config';

let _db: Knex;

/**
 * Returns an instance of database
 */
const getDb = (config: DbConfig): Knex => {
    if (!_db) {
        _db = Knex(config.getConfiguration());
    }

    return _db;
};

@injectable()
export abstract class AbstractRepository {
    @inject('DefaultDbConfig')
    public dbConfig: DbConfig;

    public abstract readonly tableName: string;

    /**
     * Returns an instance of database
     */
    public getDb(): Knex {
        return getDb(this.dbConfig);
    }

    /**
     * Returns a IQueryBuilder instance of Table
     */
    public getTable(): Knex.QueryBuilder {
        return this.getDb().table(this.tableName);
    }
}

\`\`\`

## packages/sample-store/src/db-helpers/db-config.ts

\`\`\`ts
import { Config } from 'knex';

export class DbConfig {
    constructor(private config: Config) {}

    public getConfiguration(): Config {
        return this.config;
    }
}

\`\`\`

## packages/sample-store/src/db-helpers/entity.ts

\`\`\`ts
export interface IEntity {
    id: number;
}

\`\`\`

## packages/sample-store/src/db-helpers/index.ts

\`\`\`ts
export * from './entity';
export * from './db-config';
export * from './abstract-repository';
export * from './repository';

\`\`\`

## packages/sample-store/src/db-helpers/repository.ts

\`\`\`ts
export interface IRepository<T> {
    getById(id: number): Promise<T>;

    find(filter: string, pageNumber: number, count: number): Promise<T[]>;

    create(dto: T): Promise<T>;

    update(dto: T): Promise<T>;
}

\`\`\`

## packages/sample-store/src/index.ts

\`\`\`ts
export * from './constants';
export * from './repository';
export * from './models';
export * from './container';
export * from './db-helpers';

\`\`\`

## packages/sample-store/src/models/counter.ts

\`\`\`ts
import { DataTypes, Sequelize } from 'sequelize';

export default (sequelize: Sequelize, dataTypes: typeof DataTypes) => {
    // const count = sequelize.define('count', {
    //     name: dataTypes.STRING,
    // });
};

\`\`\`

## packages/sample-store/src/models/index.ts

\`\`\`ts
export * from './interfaces';
export * from './counter';

\`\`\`

## packages/sample-store/src/models/interfaces/count-model.ts

\`\`\`ts
import { IEntity } from '../../db-helpers';

export class ICount implements IEntity {
    public id: number;

    public amount: number;
}

\`\`\`

## packages/sample-store/src/models/interfaces/index.ts

\`\`\`ts
export * from './count-model';

\`\`\`

## packages/sample-store/src/repository/counter-hemera-repository.ts

\`\`\`ts
// import { AbstractRepository } from '../db-helpers';
// import { ICounterRepository } from './interfaces';
// import { ICount } from '../models';
// import { injectable, inject, named } from 'inversify';
// import * as Hemera from 'nats-hemera';
// import HemeraJoi from 'hemera-joi';
// import * as Nats from 'nats';
// import { Counter_Table } from '../database-store/migrations/counter';

// const NATS_HEMERA_DATBASE_MANAGER = 'sql-store';

// @injectable()
// export class CounterRemoteRepository implements ICounterRepository {

//     constructor(
//         @inject('Hemera') private hemera: Hemera<any, any>,
//     ) {
//     }
//     // Set the table name to count
//     public readonly tableName: string = Counter_Table;
//     private topic = NATS_HEMERA_DATBASE_MANAGER;

//     public async getById(id) {
//         const result = await this.hemera.act<ICount>(
//             {
//                 topic: NATS_HEMERA_DATBASE_MANAGER,
//                 cmd: 'findById',
//                 collection: this.tableName,
//                 id,
//             },
//         );
//         return result.data;
//     }

//     public async find(filter: string, pageNumber: number = 1, count: number = 20): Promise<ICount[]> {
//         const result = await this.hemera.act<ICount[]>(
//             {
//                 topic: NATS_HEMERA_DATBASE_MANAGER,
//                 cmd: 'find',
//                 collection: this.tableName,
//                 query: {},
//             },
//         );
//         return result.data;
//     }

//     public async create(data: ICount): Promise<ICount> {
//         const result = await this.hemera.act<ICount>(
//             {
//                 topic: NATS_HEMERA_DATBASE_MANAGER,
//                 cmd: 'create',
//                 collection: this.tableName,
//                 data,
//             },
//         );
//         return result.data;
//     }

//     public async update(data: ICount): Promise<ICount> {
//         const result = await this.hemera.act<ICount>(
//             {
//                 topic: NATS_HEMERA_DATBASE_MANAGER,
//                 cmd: 'update',
//                 collection: this.tableName,
//                 query: {
//                     id: data.id,
//                 },
//                 data: {
//                     amount: data.amount,
//                 },
//             },
//         );
//         return result.data;
//     }

//     public async getCount(): Promise<ICount> {
//         return this.getById(1);
//     }

//     public async  addCount(amount) {
//         return this.update({ id: 1, amount: amount });
//     }

// }

\`\`\`

## packages/sample-store/src/repository/counter-repository.ts

\`\`\`ts
import { injectable } from 'inversify';

import { Counter_Table } from '../database-store/migrations/counter';
import { AbstractRepository } from '../db-helpers';
import { ICount } from '../models';
import { ICounterRepository } from './interfaces';

@injectable()
export class CounterRepository
    extends AbstractRepository
    implements ICounterRepository {
    // Set the table name to count
    public readonly tableName: string = Counter_Table;

    public async getById(id: number): Promise<ICount> {
        return this.getTable().where({ id }).first();
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    public async find(
        filter: string,
        pageNumber = 1,
        count = 20,
    ): Promise<ICount[]> {
        return this.getTable().where('amount', 'like', `%${filter}`).select();
    }

    public async create(dto: ICount): Promise<ICount> {
        return this.create(dto);
    }

    public async update(dto: ICount): Promise<ICount> {
        return this.getTable().update(dto);
    }

    public async getCount(): Promise<ICount> {
        return this.getTable().first();
    }

    public async addCount(amount) {
        await this.getTable().increment('amount', amount);
    }
}

\`\`\`

## packages/sample-store/src/repository/index.ts

\`\`\`ts
export * from './counter-repository';
export * from './interfaces';
// export * from './counter-hemera-repository';

\`\`\`

## packages/sample-store/src/repository/interfaces/counter-repository.ts

\`\`\`ts
import { IRepository } from '../../db-helpers';
import { ICount } from '../../models';

export interface ICounterRepository extends IRepository<ICount> {
    getCount: () => Promise<ICount>;

    addCount: (int) => void;
}

\`\`\`

## packages/sample-store/src/repository/interfaces/index.ts

\`\`\`ts
export * from './counter-repository';

\`\`\`

## packages/sample-store/tsconfig.json

\`\`\`json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "rootDirs": ["./src", "../../database"],
    "outDir": "../lib",
    "declarationDir": "lib"
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
\`\`\`

## packages/sample-store/webpack.config.js

\`\`\`js
const nodeExternals = require('webpack-node-externals');
const webpack = require('webpack');
const path = require('path');
const glob = require('glob');

function globEntries1(globPath) {
    const files = glob.sync(globPath);
    const entries = {};

    for (let i = 0; i < files.length; i += 1) {
        const entry = files[i];
        const pathObj = path.parse(entry);
        entries[
            path.join(
                pathObj.dir.replace(
                    new RegExp('^./src/database-store', ''),
                    'store',
                ),
                pathObj.name,
            )
        ] = entry;
    }
    return entries;
}

const webpackOpts = {
    mode: 'development',
    entry: {
        index: './src/index.ts',
        ...globEntries1('./src/database-store/**/*.ts'),
    },
    target: 'node',
    output: {
        path: path.join(__dirname, 'lib'),
        filename: '[name].js',
        libraryTarget: 'commonjs2',
        library: '@sample-stack/store',
    },
    resolve: {
        extensions: ['.ts', '.js'],
    },
    plugins: [
        new webpack.LoaderOptionsPlugin({
            options: {
                test: /\.ts$/,
                ts: {
                    compiler: 'typescript',
                    configFile: 'tsconfig.json',
                },
                tslint: {
                    emitErrors: true,
                    failOnHint: true,
                },
            },
        }),
    ],
    devtool: 'source-map',
    module: {
        rules: [
            {
                test: /\.ts$/,
                loaders: 'ts-loader',
            },
        ],
    },
    externals: [
        nodeExternals({ modulesDir: '../../node_modules' }),
        nodeExternals(),
    ],
};

module.exports = webpackOpts;

\`\`\`

## packages-modules/counter/browser/jest.config.js

\`\`\`js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    testEnvironment: 'jsdom', // This is overriden, from the base testEnvironment
    name: packageJson.name,
    displayName: packageJson.name,
};
\`\`\`

## packages-modules/counter/browser/rollup.config.js

\`\`\`js
import graphql from '@rollup/plugin-graphql';
import image from '@rollup/plugin-image';
import typescript from '@rollup/plugin-typescript';
import { string } from 'rollup-plugin-string';

const bundle = (config) => ({
    ...config,
    input: 'src/index.ts',
    // marking all node modules as external
    external: (id) => !/^[./]/.test(id),
});
const globals = { react: 'React' };

export default [
    bundle({
        plugins: [
            image(),
            graphql({
                include: '**/*.gql',
            }),
            string({
                include: '**/*.graphql',
            }),
            typescript({ noEmitOnError: true }),
        ],
        output: [
            {
                dir: 'lib',
                format: 'es',
                name: 'Counter',
                compact: true,
                exports: 'named',
                sourcemap: true,
                preserveModules: true,
                chunkFileNames: '[name]-[hash].[format].js',
                globals,
            },
        ],
    }),
];

\`\`\`

## packages-modules/counter/browser/src/apollo-server-n-client/components/CounterView.tsx

\`\`\`tsx
import * as React from 'react';
import { Helmet } from 'react-helmet';


/**
 * @description Plain`CounterView` component without any data dependency.
 */
const CounterView = ({
  loading,
  counter,
  addCounter,
  counterState,
  addCounterState,
  onReduxIncrement,
  reduxCount,
  getCounterLoading,
  addCounterWs,
  getCounter,
  syncCachedCounter,
  cachedData,
}: any) => {

  const renderMetaData = () => (
    <Helmet>
      <title>Counter</title>
      <meta name="description" content="Counter example page" />
    </Helmet>
  );
  if (loading) {
    return (
      <div>
        {renderMetaData()}
        <div className="text-center">Loading Page...</div>
      </div>
    );
  } else {
  return (
    <div>
      {renderMetaData()}
      <section>
          <p>
            Current counter, is {counter.amount} and cached data. This is being stored
            server-side in the database and using Apollo subscription for
            real-time updates.
          </p>
          <button id="graphql-button" color="primary" onClick={addCounter(1)}>
            Click to increase counter
          </button>
          <button id="graphql-button" color="primary" onClick={() => addCounterWs({ variables: { amount: 1 } })}>
            Click to increase counter via websocket
          </button>
        </section>
      <section>
        <p>
          Get Counter Cache
            {getCounterLoading ? "Loading Counter Data..." : cachedData ? <span style={{ fontStyle: 'bold' }}> {cachedData.counterCache.amount}</span> : null}
          <br />
          <button id="get-cached-counter" onClick={() => getCounter()}>
            Click to get cached counter
            </button>
          <button id="sync-cached-counter" onClick={() => syncCachedCounter()}>
            Synch Counter with Cache
            </button>
        </p>
      </section>
      <section>
        <p>
          Current reduxCount, is {reduxCount}. This is being stored
            client-side with Redux.
          </p>
        <button
          id="redux-button"
          color="primary"
          onClick={onReduxIncrement(1)}
        >
          Click to increase reduxCount
          </button>
      </section>
      <section>
        <p>
          Current apolloLinkStateCount, is {counterState}. This is being
            stored client-side with Apollo Link State.
          </p>
        <button
          id="apollo-link-button"
          color="primary"
          onClick={addCounterState(1)}
        >
          Click to increase apolloLinkState
          </button>
      </section>
    </div>
  );
  }
};

export default CounterView;

\`\`\`

## packages-modules/counter/browser/src/apollo-server-n-client/compute.tsx

\`\`\`tsx
import * as React from 'react';
import { IMenuPosition } from '@common-stack/client-react';

import Counter from './containers/Counter';
import { Dashboard } from '../common/components/Dashboard';
import { getFilteredMenus, getFilteredRoutes } from '../utils';

export const counterPageStore: any[] = [
    {
        exact: false,
        icon: 'export',
        key: 'dashboard',
        component: Dashboard,
        tab: 'Apollo Server & Client',
        position: IMenuPosition.MIDDLE,
        name: 'Apollo Server & Client',
        path: '/apollo-server-n-client',
    },
    {
        key: 'counter',
        name: 'Counter',
        icon: 'appstore-o',
        component: Counter,
        position: IMenuPosition.MIDDLE,
        path: '/apollo-server-n-client/counter',
    },
];

const selectedRoutesAndMenus = ['dashboard', 'counter'];

// get menus
const filteredMenus = getFilteredMenus(counterPageStore, selectedRoutesAndMenus);

// get routes
const filteredRoutes = getFilteredRoutes(counterPageStore, selectedRoutesAndMenus);

export { filteredMenus, filteredRoutes };

\`\`\`

## packages-modules/counter/browser/src/apollo-server-n-client/containers/Counter.tsx

\`\`\`tsx
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/restrict-plus-operands */
import React, { useEffect } from 'react';
import update from 'immutability-helper';
import { useDispatch, useSelector } from 'react-redux';
import CounterView from '../components/CounterView';
import {
    useCounterQueryQuery,
    useAddCounterMutation,
    useAddCounterStateMutation,
    useCounterStateQuery,
    useAddCounter_WsMutation, 
    useSyncCachedCounterMutation, 
    useCounterCacheQueryLazyQuery
} from '../generated-model';
import {
    OnCounterUpdatedDocument,
} from '../../common/generated-models';

/**
 * 
 * @description Counter Component with Data dependency.
 */
const CounterWithApollo: React.SFC<any> = (props) => {
    const [addCounterMutation] = useAddCounterMutation();
    const { loading, error, data: counterData, subscribeToMore, } = useCounterQueryQuery();
    const [addCounterStateMutation] = useAddCounterStateMutation();
    const { data: couterStateData } = useCounterStateQuery();
    const dispatch = useDispatch();
    const reduxCount = useSelector(state => (state as any).counter.reduxCount);
    const [getCounter, { loading: getCounterLoading, data: cachedData }] = useCounterCacheQueryLazyQuery({ fetchPolicy: 'network-only' });
    const [addCounterWs] = useAddCounter_WsMutation();
    const [syncCachedCounter] = useSyncCachedCounterMutation();

    useEffect(() => {
        const unsubscribe = subscribeToMore(getSubscriptionOptions({}));
        return () => unsubscribe();
    }, [subscribeToMore]);

    const onReduxIncrement = (value) => () => {
        dispatch({
            type: 'COUNTER_INCREMENT',
            value: Number(value),
        });
    }
    const addCounter = (amount) => () => {
        addCounterMutation({
            variables: { amount },
            // Update the Cache of the Query that need to be display when it's dependent mutation gets called.
            // This is needed for two reasons
            // a). When update the Optimistically update cache, this get executes
            // b). When the mutation response from Server, this gets update.
            // Note: Optimistically update wont' work when network is offline.
            update: (cache, { data: { addCounter } }) => {
                // update the query's cache manually
                // recommend to be done using fields but it can be done directly updating the cache
                cache.modify({
                    fields: {
                        counter(prev) {
                            return { amount: addCounter.amount };
                        }
                    }
                })
            },
            // Optimistically update the amount to the locally cached
            // before the server responds
            // You can verify it by setting the "Network conditions" in devtools to `Slow 3G`.
            // You will see the data gets updated before the server responds.
            optimisticResponse: {
                // __typename: 'Mutation',
                addCounter: {
                    __typename: 'Counter',
                    amount: counterData?.counter.amount + amount,
                }
            }
        })
    }

    const addCounterState = (amount) => () => {
        addCounterStateMutation({
            variables: { amount }
        });
    }
    const getSubscriptionOptions = ({ }) => {
        return {
            document: OnCounterUpdatedDocument,
            variables: {},
            updateQuery: (prev,
                {
                    subscriptionData: {
                        data: {
                            counterUpdated: { amount },
                        },
                    }
                }) => {
                return update(prev, {
                    counter: {
                        amount: {
                            $set: amount,
                        },
                    },
                });
            }
        }
    }

    return <CounterView
        loading={loading}
        counter={counterData?.counter}
        counterState={couterStateData?.counterState?.counter}
        addCounter={addCounter}
        addCounterState={addCounterState}
        reduxCount={reduxCount}
        onReduxIncrement={onReduxIncrement}
        getCounterLoading={getCounterLoading}
        addCounterWs={addCounterWs}
        getCounter={getCounter}
        syncCachedCounter={syncCachedCounter}
        cachedData={cachedData}
    />
}

export default CounterWithApollo;
\`\`\`

## packages-modules/counter/browser/src/apollo-server-n-client/generated-model.tsx

\`\`\`tsx
/* tslint:disable */
import * as SchemaTypes from '../generated-models';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
import * as React from 'react';
import * as ApolloReactComponents from '@apollo/client/react/components';
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
const defaultOptions =  {}

export const AddCounterStateDocument = gql`
    mutation addCounterState($amount: Int!) {
  addCounterState(amount: $amount) @client {
    counter
  }
}
    `;
export type AddCounterStateMutationFn = Apollo.MutationFunction<SchemaTypes.AddCounterStateMutation, SchemaTypes.AddCounterStateMutationVariables>;
export type AddCounterStateComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<SchemaTypes.AddCounterStateMutation, SchemaTypes.AddCounterStateMutationVariables>, 'mutation'>;

    export const AddCounterStateComponent = (props: AddCounterStateComponentProps) => (
      <ApolloReactComponents.Mutation<SchemaTypes.AddCounterStateMutation, SchemaTypes.AddCounterStateMutationVariables> mutation={AddCounterStateDocument} {...props} />
    );
    

/**
 * __useAddCounterStateMutation__
 *
 * To run a mutation, you first call `useAddCounterStateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCounterStateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCounterStateMutation, { data, loading, error }] = useAddCounterStateMutation({
 *   variables: {
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useAddCounterStateMutation(baseOptions?: Apollo.MutationHookOptions<SchemaTypes.AddCounterStateMutation, SchemaTypes.AddCounterStateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SchemaTypes.AddCounterStateMutation, SchemaTypes.AddCounterStateMutationVariables>(AddCounterStateDocument, options);
      }
export type AddCounterStateMutationHookResult = ReturnType<typeof useAddCounterStateMutation>;
export type AddCounterStateMutationResult = Apollo.MutationResult<SchemaTypes.AddCounterStateMutation>;
export type AddCounterStateMutationOptions = Apollo.BaseMutationOptions<SchemaTypes.AddCounterStateMutation, SchemaTypes.AddCounterStateMutationVariables>;
export const AddCounterDocument = gql`
    mutation addCounter($amount: Int!) {
  addCounter(amount: $amount) {
    amount
  }
}
    `;
export type AddCounterMutationFn = Apollo.MutationFunction<SchemaTypes.AddCounterMutation, SchemaTypes.AddCounterMutationVariables>;
export type AddCounterComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<SchemaTypes.AddCounterMutation, SchemaTypes.AddCounterMutationVariables>, 'mutation'>;

    export const AddCounterComponent = (props: AddCounterComponentProps) => (
      <ApolloReactComponents.Mutation<SchemaTypes.AddCounterMutation, SchemaTypes.AddCounterMutationVariables> mutation={AddCounterDocument} {...props} />
    );
    

/**
 * __useAddCounterMutation__
 *
 * To run a mutation, you first call `useAddCounterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCounterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCounterMutation, { data, loading, error }] = useAddCounterMutation({
 *   variables: {
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useAddCounterMutation(baseOptions?: Apollo.MutationHookOptions<SchemaTypes.AddCounterMutation, SchemaTypes.AddCounterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SchemaTypes.AddCounterMutation, SchemaTypes.AddCounterMutationVariables>(AddCounterDocument, options);
      }
export type AddCounterMutationHookResult = ReturnType<typeof useAddCounterMutation>;
export type AddCounterMutationResult = Apollo.MutationResult<SchemaTypes.AddCounterMutation>;
export type AddCounterMutationOptions = Apollo.BaseMutationOptions<SchemaTypes.AddCounterMutation, SchemaTypes.AddCounterMutationVariables>;
export const AddCounter_WsDocument = gql`
    mutation AddCounter_WS($amount: Int!) {
  addCounter(amount: $amount) {
    amount
  }
}
    `;
export type AddCounter_WsMutationFn = Apollo.MutationFunction<SchemaTypes.AddCounter_WsMutation, SchemaTypes.AddCounter_WsMutationVariables>;
export type AddCounter_WsComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<SchemaTypes.AddCounter_WsMutation, SchemaTypes.AddCounter_WsMutationVariables>, 'mutation'>;

    export const AddCounter_WsComponent = (props: AddCounter_WsComponentProps) => (
      <ApolloReactComponents.Mutation<SchemaTypes.AddCounter_WsMutation, SchemaTypes.AddCounter_WsMutationVariables> mutation={AddCounter_WsDocument} {...props} />
    );
    

/**
 * __useAddCounter_WsMutation__
 *
 * To run a mutation, you first call `useAddCounter_WsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCounter_WsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCounterWsMutation, { data, loading, error }] = useAddCounter_WsMutation({
 *   variables: {
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useAddCounter_WsMutation(baseOptions?: Apollo.MutationHookOptions<SchemaTypes.AddCounter_WsMutation, SchemaTypes.AddCounter_WsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SchemaTypes.AddCounter_WsMutation, SchemaTypes.AddCounter_WsMutationVariables>(AddCounter_WsDocument, options);
      }
export type AddCounter_WsMutationHookResult = ReturnType<typeof useAddCounter_WsMutation>;
export type AddCounter_WsMutationResult = Apollo.MutationResult<SchemaTypes.AddCounter_WsMutation>;
export type AddCounter_WsMutationOptions = Apollo.BaseMutationOptions<SchemaTypes.AddCounter_WsMutation, SchemaTypes.AddCounter_WsMutationVariables>;
export const SyncCachedCounterDocument = gql`
    mutation SyncCachedCounter {
  syncCachedCounter
}
    `;
export type SyncCachedCounterMutationFn = Apollo.MutationFunction<SchemaTypes.SyncCachedCounterMutation, SchemaTypes.SyncCachedCounterMutationVariables>;
export type SyncCachedCounterComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<SchemaTypes.SyncCachedCounterMutation, SchemaTypes.SyncCachedCounterMutationVariables>, 'mutation'>;

    export const SyncCachedCounterComponent = (props: SyncCachedCounterComponentProps) => (
      <ApolloReactComponents.Mutation<SchemaTypes.SyncCachedCounterMutation, SchemaTypes.SyncCachedCounterMutationVariables> mutation={SyncCachedCounterDocument} {...props} />
    );
    

/**
 * __useSyncCachedCounterMutation__
 *
 * To run a mutation, you first call `useSyncCachedCounterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSyncCachedCounterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [syncCachedCounterMutation, { data, loading, error }] = useSyncCachedCounterMutation({
 *   variables: {
 *   },
 * });
 */
export function useSyncCachedCounterMutation(baseOptions?: Apollo.MutationHookOptions<SchemaTypes.SyncCachedCounterMutation, SchemaTypes.SyncCachedCounterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SchemaTypes.SyncCachedCounterMutation, SchemaTypes.SyncCachedCounterMutationVariables>(SyncCachedCounterDocument, options);
      }
export type SyncCachedCounterMutationHookResult = ReturnType<typeof useSyncCachedCounterMutation>;
export type SyncCachedCounterMutationResult = Apollo.MutationResult<SchemaTypes.SyncCachedCounterMutation>;
export type SyncCachedCounterMutationOptions = Apollo.BaseMutationOptions<SchemaTypes.SyncCachedCounterMutation, SchemaTypes.SyncCachedCounterMutationVariables>;
export const CounterCacheQueryDocument = gql`
    query counterCacheQuery {
  counterCache {
    amount
  }
}
    `;
export type CounterCacheQueryComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<SchemaTypes.CounterCacheQueryQuery, SchemaTypes.CounterCacheQueryQueryVariables>, 'query'>;

    export const CounterCacheQueryComponent = (props: CounterCacheQueryComponentProps) => (
      <ApolloReactComponents.Query<SchemaTypes.CounterCacheQueryQuery, SchemaTypes.CounterCacheQueryQueryVariables> query={CounterCacheQueryDocument} {...props} />
    );
    

/**
 * __useCounterCacheQueryQuery__
 *
 * To run a query within a React component, call `useCounterCacheQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useCounterCacheQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCounterCacheQueryQuery({
 *   variables: {
 *   },
 * });
 */
export function useCounterCacheQueryQuery(baseOptions?: Apollo.QueryHookOptions<SchemaTypes.CounterCacheQueryQuery, SchemaTypes.CounterCacheQueryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SchemaTypes.CounterCacheQueryQuery, SchemaTypes.CounterCacheQueryQueryVariables>(CounterCacheQueryDocument, options);
      }
export function useCounterCacheQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SchemaTypes.CounterCacheQueryQuery, SchemaTypes.CounterCacheQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SchemaTypes.CounterCacheQueryQuery, SchemaTypes.CounterCacheQueryQueryVariables>(CounterCacheQueryDocument, options);
        }
export type CounterCacheQueryQueryHookResult = ReturnType<typeof useCounterCacheQueryQuery>;
export type CounterCacheQueryLazyQueryHookResult = ReturnType<typeof useCounterCacheQueryLazyQuery>;
export type CounterCacheQueryQueryResult = Apollo.QueryResult<SchemaTypes.CounterCacheQueryQuery, SchemaTypes.CounterCacheQueryQueryVariables>;
export const CounterStateDocument = gql`
    query CounterState {
  counterState @client {
    counter
  }
}
    `;
export type CounterStateComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<SchemaTypes.CounterStateQuery, SchemaTypes.CounterStateQueryVariables>, 'query'>;

    export const CounterStateComponent = (props: CounterStateComponentProps) => (
      <ApolloReactComponents.Query<SchemaTypes.CounterStateQuery, SchemaTypes.CounterStateQueryVariables> query={CounterStateDocument} {...props} />
    );
    

/**
 * __useCounterStateQuery__
 *
 * To run a query within a React component, call `useCounterStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useCounterStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCounterStateQuery({
 *   variables: {
 *   },
 * });
 */
export function useCounterStateQuery(baseOptions?: Apollo.QueryHookOptions<SchemaTypes.CounterStateQuery, SchemaTypes.CounterStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SchemaTypes.CounterStateQuery, SchemaTypes.CounterStateQueryVariables>(CounterStateDocument, options);
      }
export function useCounterStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SchemaTypes.CounterStateQuery, SchemaTypes.CounterStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SchemaTypes.CounterStateQuery, SchemaTypes.CounterStateQueryVariables>(CounterStateDocument, options);
        }
export type CounterStateQueryHookResult = ReturnType<typeof useCounterStateQuery>;
export type CounterStateLazyQueryHookResult = ReturnType<typeof useCounterStateLazyQuery>;
export type CounterStateQueryResult = Apollo.QueryResult<SchemaTypes.CounterStateQuery, SchemaTypes.CounterStateQueryVariables>;
export const CounterQueryDocument = gql`
    query counterQuery {
  counter {
    amount
  }
}
    `;
export type CounterQueryComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<SchemaTypes.CounterQueryQuery, SchemaTypes.CounterQueryQueryVariables>, 'query'>;

    export const CounterQueryComponent = (props: CounterQueryComponentProps) => (
      <ApolloReactComponents.Query<SchemaTypes.CounterQueryQuery, SchemaTypes.CounterQueryQueryVariables> query={CounterQueryDocument} {...props} />
    );
    

/**
 * __useCounterQueryQuery__
 *
 * To run a query within a React component, call `useCounterQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useCounterQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCounterQueryQuery({
 *   variables: {
 *   },
 * });
 */
export function useCounterQueryQuery(baseOptions?: Apollo.QueryHookOptions<SchemaTypes.CounterQueryQuery, SchemaTypes.CounterQueryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SchemaTypes.CounterQueryQuery, SchemaTypes.CounterQueryQueryVariables>(CounterQueryDocument, options);
      }
export function useCounterQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SchemaTypes.CounterQueryQuery, SchemaTypes.CounterQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SchemaTypes.CounterQueryQuery, SchemaTypes.CounterQueryQueryVariables>(CounterQueryDocument, options);
        }
export type CounterQueryQueryHookResult = ReturnType<typeof useCounterQueryQuery>;
export type CounterQueryLazyQueryHookResult = ReturnType<typeof useCounterQueryLazyQuery>;
export type CounterQueryQueryResult = Apollo.QueryResult<SchemaTypes.CounterQueryQuery, SchemaTypes.CounterQueryQueryVariables>;
export const OnCounterUpdatedDocument = gql`
    subscription onCounterUpdated {
  counterUpdated {
    amount
  }
}
    `;
export type OnCounterUpdatedComponentProps = Omit<ApolloReactComponents.SubscriptionComponentOptions<SchemaTypes.OnCounterUpdatedSubscription, SchemaTypes.OnCounterUpdatedSubscriptionVariables>, 'subscription'>;

    export const OnCounterUpdatedComponent = (props: OnCounterUpdatedComponentProps) => (
      <ApolloReactComponents.Subscription<SchemaTypes.OnCounterUpdatedSubscription, SchemaTypes.OnCounterUpdatedSubscriptionVariables> subscription={OnCounterUpdatedDocument} {...props} />
    );
    

/**
 * __useOnCounterUpdatedSubscription__
 *
 * To run a query within a React component, call `useOnCounterUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnCounterUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnCounterUpdatedSubscription({
 *   variables: {
 *   },
 * });
 */
export function useOnCounterUpdatedSubscription(baseOptions?: Apollo.SubscriptionHookOptions<SchemaTypes.OnCounterUpdatedSubscription, SchemaTypes.OnCounterUpdatedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<SchemaTypes.OnCounterUpdatedSubscription, SchemaTypes.OnCounterUpdatedSubscriptionVariables>(OnCounterUpdatedDocument, options);
      }
export type OnCounterUpdatedSubscriptionHookResult = ReturnType<typeof useOnCounterUpdatedSubscription>;
export type OnCounterUpdatedSubscriptionResult = Apollo.SubscriptionResult<SchemaTypes.OnCounterUpdatedSubscription>;
\`\`\`

## packages-modules/counter/browser/src/apollo-server-n-client/graphql/__tests__/apollo-client-test-helper.ts

\`\`\`ts
/* eslint-disable no-use-before-define */
/* eslint-disable import/no-extraneous-dependencies */
import { ApolloClient, ApolloClientOptions, ApolloLink } from '@apollo/client';
import { InMemoryCache } from '@apollo/client/cache';
// import * as schema from '../schema/schema.graphql';
import { resolvers } from '../resolvers';
import { dataIdFromObject } from '../id-generation';

const defaultSchema = `
type Query {
    dummy: Int
}
type Mutation {
    dummy: Int
}
`;

const cache = new InMemoryCache({
    dataIdFromObject: (object) => getDataIdFromObject(object),
});

const  params: ApolloClientOptions<any> = {
    cache,
    resolvers,
    // typeDefs: defaultSchema.concat(schema as any), // if client schema exist
};
const links = [];

const client = new ApolloClient({
    queryDeduplication: true,
    link: ApolloLink.from(links),
    cache,
});

function getDataIdFromObject(result: any) {
    if (dataIdFromObject[result.__typename]) {
        return dataIdFromObject[result.__typename](result);
    }
    return result.id || result._id;
}

export { client, getDataIdFromObject };

\`\`\`

## packages-modules/counter/browser/src/apollo-server-n-client/graphql/__tests__/apollo-client.test.ts

\`\`\`ts
import { client } from './apollo-client-test-helper';
import { AddCounterDocument } from '../../../generated-models';
import 'jest';

describe('Apollo Client tests', () => {
    it('client test', async () => {
        const result = await client.mutate({
            mutation: AddCounterDocument,
            variables: { amount: 1 },
            // data: {},
        });
        expect(result).toEqual({ data: { addCounterState: null }, errors: undefined });
    });
});

\`\`\`

## packages-modules/counter/browser/src/apollo-server-n-client/graphql/id-generation.ts

\`\`\`ts
/**
 * All the unique identifier to be used when normilizing the data in the store.
 * Refer: https://www.apollographql.com/docs/angular/basics/caching#configuration
 * We define it as Object and use a helper method to convert.
 * ex: const dataIdFromObject = {
 *  'ICounter': (result) => result.__typename + ':' + result._id,
 * }
 */
export const dataIdFromObject = {};

\`\`\`

## packages-modules/counter/browser/src/apollo-server-n-client/graphql/index.ts

\`\`\`ts
export * from './resolvers';

\`\`\`

## packages-modules/counter/browser/src/apollo-server-n-client/graphql/resolvers/index.ts

\`\`\`ts
export * from './resolvers';

\`\`\`

## packages-modules/counter/browser/src/apollo-server-n-client/graphql/resolvers/resolvers.ts

\`\`\`ts
/* eslint-disable import/no-unresolved */
/* eslint-disable import/no-extraneous-dependencies */
import { IClientStateDefault } from '@common-stack/client-core';
import { InMemoryCache } from '@apollo/client/cache';
import { CounterStateDocument } from '../../../generated-models';

const TYPE_NAME = 'CounterState';

const stateDefault: IClientStateDefault = {
    type: 'query',
    query: CounterStateDocument,
    data: {
        counterState: {
            counter: 1,
            __typename: TYPE_NAME,
        },
    },
};

const resolvers = {
    Query: {
        counterState: (_, args, { cache }) => {
            const {
                counterState: { counter },
            } = cache.readQuery({ query: CounterStateDocument });
            return {
                counter,
                __typename: TYPE_NAME,
            };
        },
    },
    Mutation: {
        addCounterState: async (_, { amount }, { cache }: { cache: InMemoryCache }) => {
            const {
                counterState: { counter },
            } = cache.readQuery({ query: CounterStateDocument });
            const newAmount = amount + counter;

            await cache.writeQuery({
                query: CounterStateDocument,
                data: {
                    counterState: {
                        counter: newAmount,
                        __typename: TYPE_NAME,
                    },
                },
            });

            return null;
        },
    },
};

export { stateDefault, resolvers };

\`\`\`

## packages-modules/counter/browser/src/apollo-server-n-client/index.ts

\`\`\`ts
import { Feature } from '@common-stack/client-react';
import repository from './module';

export default new Feature(repository);

\`\`\`

## packages-modules/counter/browser/src/apollo-server-n-client/module.tsx

\`\`\`tsx
import { reducers } from './redux';
import { resolvers, stateDefault } from './graphql';

import { Feature } from '@common-stack/client-react';
import { filteredMenus, filteredRoutes } from './compute';

export default new Feature({
  menuConfig: filteredMenus,
  routeConfig: filteredRoutes,
  reducer: { counter: reducers },
  clientStateParams: { resolvers, defaults: [stateDefault] },
});

\`\`\`

## packages-modules/counter/browser/src/apollo-server-n-client/redux/index.ts

\`\`\`ts
export * from './reducers';

\`\`\`

## packages-modules/counter/browser/src/apollo-server-n-client/redux/reducers/index.ts

\`\`\`ts
const defaultState = {
    reduxCount: 1,
};

export const reducers = function (state = defaultState, action) {
    switch (action.type) {
        case 'COUNTER_INCREMENT':
            return {
                ...state,
                reduxCount: state.reduxCount + action.value,
            };

        default:
            return state;
    }
};

\`\`\`

## packages-modules/counter/browser/src/common/components/Dashboard.tsx

\`\`\`tsx
import * as React from 'react';
import { renderRoutes } from 'react-router-config';

export const Dashboard = (props) =>  <>{renderRoutes(props.route.routes, { matchPath: props.route.path })}</>;

\`\`\`

## packages-modules/counter/browser/src/common/components/Home.tsx

\`\`\`tsx
import * as React from 'react';

export const Home = () => (
    <div>
        <h1>FullStack-Pro</h1>
    </div>
);

\`\`\`

## packages-modules/counter/browser/src/common/compute.tsx

\`\`\`tsx
import * as React from 'react';
import { IMenuPosition } from '@common-stack/client-react';

import { Home } from '../common/components/Home';
import { getFilteredMenus, getFilteredRoutes } from '../utils';

export const commonPageStore: any[] = [
    {
        path: '/',
        key: 'home',
        exact: true,
        name: 'Home',
        component: Home,
        position: IMenuPosition.MIDDLE,
    },
];

const selectedRoutesAndMenus = ['home'];

// get menus
const filteredMenus = getFilteredMenus(commonPageStore, selectedRoutesAndMenus);

// get routes
const filteredRoutes = getFilteredRoutes(commonPageStore, selectedRoutesAndMenus);

export { filteredMenus, filteredRoutes };

\`\`\`

## packages-modules/counter/browser/src/common/generated-models.ts

\`\`\`ts
/* tslint:disable */

import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';

import gql from 'graphql-tag';
import { MyContext } from './interfaces/context';

export type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    AnyObject: any;
    JSON: any;
    JSONObject: any;
    Date: any;
    Time: any;
    DateTime: any;
};

export type ClientCounter = {
    counter?: Maybe<Scalars['Int']>;
};

export type Counter = {
    amount: Scalars['Int'];
};

export type FieldError = {
    field: Scalars['String'];
    message: Scalars['String'];
};

export type Mutation = {
    dummy?: Maybe<Scalars['Int']>;
    addCounterState?: Maybe<ClientCounter>;
    addCounter?: Maybe<Counter>;
};

export type MutationAddCounterStateArgs = {
    amount: Scalars['Int'];
};

export type MutationAddCounterArgs = {
    amount?: Maybe<Scalars['Int']>;
};

export type Node = {
    id: Scalars['ID'];
};

export type Query = {
    dummy?: Maybe<Scalars['Int']>;
    counterState?: Maybe<ClientCounter>;
    counter?: Maybe<Counter>;
};

export type Subscription = {
    dummy?: Maybe<Scalars['Int']>;
    counterUpdated?: Maybe<Counter>;
};

export type AddCounterStateMutationVariables = {
    amount: Scalars['Int'];
};

export type AddCounterStateMutation = { __typename?: 'Mutation' } & {
    addCounterState: Maybe<{ __typename?: 'ClientCounter' } & Pick<ClientCounter, 'counter'>>;
};

export type AddCounterMutationVariables = {
    amount: Scalars['Int'];
};

export type AddCounterMutation = { __typename?: 'Mutation' } & {
    addCounter: Maybe<{ __typename?: 'Counter' } & Pick<Counter, 'amount'>>;
};

export type CounterStateQueryVariables = {};

export type CounterStateQuery = { __typename?: 'Query' } & {
    counterState: Maybe<{ __typename?: 'ClientCounter' } & Pick<ClientCounter, 'counter'>>;
};

export type CounterQueryQueryVariables = {};

export type CounterQueryQuery = { __typename?: 'Query' } & {
    counter: Maybe<{ __typename?: 'Counter' } & Pick<Counter, 'amount'>>;
};

export type OnCounterUpdatedSubscriptionVariables = {};

export type OnCounterUpdatedSubscription = { __typename?: 'Subscription' } & {
    counterUpdated: Maybe<{ __typename?: 'Counter' } & Pick<Counter, 'amount'>>;
};

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => Promise<TResult> | TResult;

export type StitchingResolver<TResult, TParent, TContext, TArgs> = {
    fragment: string;
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ResolverFn<TResult, TParent, TContext, TArgs>
    | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs>;
    resolve?: SubscriptionResolveFn<TResult, TParent, TContext, TArgs>;
}

export type SubscriptionResolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ((...args: any[]) => SubscriptionResolverObject<TResult, TParent, TContext, TArgs>)
    | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
    parent: TParent,
    context: TContext,
    info: GraphQLResolveInfo,
) => Maybe<TTypes>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
    next: NextResolverFn<TResult>,
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
    Query: {};
    Int: Scalars['Int'];
    ClientCounter: ClientCounter;
    Counter: Counter;
    Mutation: {};
    Subscription: {};
    String: Scalars['String'];
    Boolean: Scalars['Boolean'];
    AnyObject: Scalars['AnyObject'];
    JSON: Scalars['JSON'];
    JSONObject: Scalars['JSONObject'];
    FieldError: FieldError;
    Node: Node;
    ID: Scalars['ID'];
    Date: Scalars['Date'];
    Time: Scalars['Time'];
    DateTime: Scalars['DateTime'];
};

export interface AnyObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['AnyObject'], any> {
    name: 'AnyObject';
}

export type ClientCounterResolvers<ContextType = MyContext, ParentType = ResolversTypes['ClientCounter']> = {
    counter?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
};

export type CounterResolvers<ContextType = MyContext, ParentType = ResolversTypes['Counter']> = {
    amount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
};

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
    name: 'Date';
}

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
    name: 'DateTime';
}

export type FieldErrorResolvers<ContextType = MyContext, ParentType = ResolversTypes['FieldError']> = {
    field?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
    name: 'JSON';
}

export interface JsonObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSONObject'], any> {
    name: 'JSONObject';
}

export type MutationResolvers<ContextType = MyContext, ParentType = ResolversTypes['Mutation']> = {
    dummy?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    addCounterState?: Resolver<
        Maybe<ResolversTypes['ClientCounter']>,
        ParentType,
        ContextType,
        MutationAddCounterStateArgs
    >;
    addCounter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType, MutationAddCounterArgs>;
};

export type NodeResolvers<ContextType = MyContext, ParentType = ResolversTypes['Node']> = {
    __resolveType: TypeResolveFn<null, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type QueryResolvers<ContextType = MyContext, ParentType = ResolversTypes['Query']> = {
    dummy?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    counterState?: Resolver<Maybe<ResolversTypes['ClientCounter']>, ParentType, ContextType>;
    counter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
};

export type SubscriptionResolvers<ContextType = MyContext, ParentType = ResolversTypes['Subscription']> = {
    dummy?: SubscriptionResolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    counterUpdated?: SubscriptionResolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
};

export interface TimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Time'], any> {
    name: 'Time';
}

export type Resolvers<ContextType = MyContext> = {
    AnyObject?: GraphQLScalarType;
    ClientCounter?: ClientCounterResolvers<ContextType>;
    Counter?: CounterResolvers<ContextType>;
    Date?: GraphQLScalarType;
    DateTime?: GraphQLScalarType;
    FieldError?: FieldErrorResolvers<ContextType>;
    JSON?: GraphQLScalarType;
    JSONObject?: GraphQLScalarType;
    Mutation?: MutationResolvers<ContextType>;
    Node?: NodeResolvers;
    Query?: QueryResolvers<ContextType>;
    Subscription?: SubscriptionResolvers<ContextType>;
    Time?: GraphQLScalarType;
};

/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
 */
export type IResolvers<ContextType = MyContext> = Resolvers<ContextType>;
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export const AddCounterStateDocument = gql`
    mutation addCounterState($amount: Int!) {
        addCounterState(amount: $amount) @client {
            counter
        }
    }
`;
export const AddCounterDocument = gql`
    mutation addCounter($amount: Int!) {
        addCounter(amount: $amount) {
            amount
        }
    }
`;
export const CounterStateDocument = gql`
    query CounterState {
        counterState @client {
            counter
        }
    }
`;
export const CounterQueryDocument = gql`
    query counterQuery {
        counter {
            amount
        }
    }
`;
export const OnCounterUpdatedDocument = gql`
    subscription onCounterUpdated {
        counterUpdated {
            amount
        }
    }
`;

\`\`\`

## packages-modules/counter/browser/src/common/index.ts

\`\`\`ts
import { Feature } from '@common-stack/client-react';
import common from './module';

export default new Feature(common);

\`\`\`

## packages-modules/counter/browser/src/common/interfaces/context.ts

\`\`\`ts
import { DataProxy } from '@apollo/client/cache';
import { ApolloClient } from '@apollo/client';

export interface MyContext {
    cache: DataProxy;
    getCacheKey: (options: { __typename: string; resource?: string; id?: string }) => string;
    apolloClient: ApolloClient<any>;
}

\`\`\`

## packages-modules/counter/browser/src/common/module.tsx

\`\`\`tsx
import * as  React from 'react';

import { Feature } from '@common-stack/client-react';
import { filteredMenus, filteredRoutes } from './compute';

export default new Feature({
  menuConfig: filteredMenus,
  routeConfig: filteredRoutes,
});

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/__tests__/connected-react-router-module.test.ts

\`\`\`ts
import Module from '../module';

import 'jest';

describe('connector modules', () => {
    it('module configuredRoutes', () => {
        const configuredRoutes = Module.getConfiguredRoutes();

        expect(configuredRoutes).toMatchSnapshot();
    });

    it('module routes', () => {
        const routes = Module.getRoutes();

        expect(routes).toMatchSnapshot();
    });
});

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/components/Counter.tsx

\`\`\`tsx
/* eslint-disable react/button-has-type */
import * as React from 'react';
import { Dispatch } from 'redux';
import { connect } from 'react-redux';
import { RouteComponentProps } from 'react-router';
import { increment, decrement } from '../redux';
import { State } from '../interfaces';

const CounterComponent: React.SFC<StateProps & DispatchProps> = (props) => (
    <div>
        Counter: {props.count}
        <button onClick={props.increment}>+</button>
        <button onClick={props.decrement}>-</button>
    </div>
);

interface StateProps {
    count: number;
}

interface DispatchProps {
    increment: () => void;
    decrement: () => void;
}

const mapStateToProps = (state: State) => ({
    count: state.connectedReactRouterCounter,
});

const mapDispatchToProps = (dispatch: Dispatch) => ({
    increment: () => dispatch(increment()),
    decrement: () => dispatch(decrement()),
});

export const Counter = connect<StateProps, DispatchProps>(
    mapStateToProps,
    mapDispatchToProps,
)(CounterComponent);

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/components/Hello.tsx

\`\`\`tsx
import * as React from 'react';
import { HelloChild } from './HelloChild';

const Hello = () => (
    <div>
        <div>Hello</div>
        <HelloChild />
    </div>
);

export { Hello };

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/components/HelloChild.tsx

\`\`\`tsx

import * as React from 'react';
import { connect } from 'react-redux';
import { Link } from 'react-router-dom';
import { State } from '../interfaces';
import { CONNECTED_REACT_ROUTER_ROUTES_TYPES } from '../constants';

interface HelloChildProps {
    pathname: string;
    search: string;
    hash: string;
}

const HelloChildComponent = ({ pathname, search, hash }: HelloChildProps) => (
    <div>
        Hello-Child
    <ul>
            <li><Link to={`${CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO}?color=Blue&size=40`}>with query string</Link></li>
            <li><Link to={`${CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO}#lovelove`}>with hash</Link></li>
        </ul>
        <div>
            pathname: {pathname}
        </div>
        <div>
            search: {search}
        </div>
        <div>
            hash: {hash}
        </div>
    </div>
);

const mapStateToProps = (state: State) => ({
    pathname: state.router.location.pathname,
    search: state.router.location.search,
    hash: state.router.location.hash,
});

export const HelloChild = connect(mapStateToProps)(HelloChildComponent);

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/components/Home.tsx

\`\`\`tsx
import * as React from 'react';

const Home = () => (
    <div>
        Home
  </div>
);

export { Home };

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/components/NavBar.tsx

\`\`\`tsx
import * as React from 'react';
import { Counter } from './Counter';

const NavBar = () => (
    <div>
        <Counter/>
    </div>
);

export default NavBar;

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/components/NoMatch.tsx

\`\`\`tsx
import * as React from 'react';

const NoMatch = () => (
  <div>
    No Match
  </div>
);

export default NoMatch;

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/compute.tsx

\`\`\`tsx
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import * as React from 'react';
import { IMenuPosition, IRoute } from '@common-stack/client-react';

import { Hello } from './components/Hello';
import { Counter } from './components/Counter';
import { Dashboard } from '../common/components/Dashboard';
import { getFilteredMenus, getFilteredRoutes } from '../utils';
import { CONNECTED_REACT_ROUTER_ROUTES_TYPES } from './constants';

export const counterPageStore: IRoute[] = [
    {
        exact: false,
        icon: 'export',
        component: Dashboard,
        position: IMenuPosition.MIDDLE,
        name: 'Connected React Router',
        key: CONNECTED_REACT_ROUTER_ROUTES_TYPES.HOME,
        path: CONNECTED_REACT_ROUTER_ROUTES_TYPES.HOME,
    },
    {
        exact: true,
        icon: 'export',
        name: 'Hello',
        component: Hello,
        position: IMenuPosition.MIDDLE,
        key: CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO,
        path: CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO,
    },
    {
        exact: true,
        icon: 'export',
        name: 'Counter',
        component: Counter,
        position: IMenuPosition.MIDDLE,
        key: CONNECTED_REACT_ROUTER_ROUTES_TYPES.COUNTER,
        path: CONNECTED_REACT_ROUTER_ROUTES_TYPES.COUNTER,
    },
];

const selectedRoutesAndMenus = [
    CONNECTED_REACT_ROUTER_ROUTES_TYPES.HOME,
    CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO,
    CONNECTED_REACT_ROUTER_ROUTES_TYPES.COUNTER,
];

// get routes
const filteredRoutes = getFilteredRoutes(counterPageStore, selectedRoutesAndMenus);

// get menus
const filteredMenus = getFilteredMenus(counterPageStore, selectedRoutesAndMenus);

export { filteredRoutes, filteredMenus };

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/constants/action-types.ts

\`\`\`ts
export const enum CONNECTED_REACT_ROUTER_ACTION_TYPES {
    INCREMENT = '@connected-react-router/INCREMENT',
    DECREMENT = '@connected-react-router/DECREMENT',
}

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/constants/index.ts

\`\`\`ts
export * from './action-types';
export * from './routes-types';

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/constants/routes-types.ts

\`\`\`ts
export enum CONNECTED_REACT_ROUTER_ROUTES_TYPES {
    ROOT = '/',
    HOME = '/connected-react-router',
    HELLO = '/connected-react-router/hello',
    COUNTER = '/connected-react-router/counter',
}

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/electron-module.tsx

\`\`\`tsx
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Feature } from '@common-stack/client-react';
import { IMenuPosition, IRoute } from '@common-stack/client-react';
import { Counter } from './components/Counter';
import { connectedReactRouterCounter } from './redux';
import { CONNECTED_REACT_ROUTER_ROUTES_TYPES } from './constants';
import { getFilteredRoutes } from '../utils';


export const counterPageStore: IRoute[] = [
    {
        exact: true,
        icon: 'export',
        name: 'Counter',
        component: Counter,
        position: IMenuPosition.MIDDLE,
        key: CONNECTED_REACT_ROUTER_ROUTES_TYPES.ROOT,
        path: CONNECTED_REACT_ROUTER_ROUTES_TYPES.ROOT,
    },
];

const selectedRoutesAndMenus = [
    CONNECTED_REACT_ROUTER_ROUTES_TYPES.ROOT,
];
// get routes
const filteredRoutes = getFilteredRoutes(counterPageStore, selectedRoutesAndMenus);

export const ElectronTrayModule = new Feature({
    routeConfig: filteredRoutes,
    reducer: { connectedReactRouterCounter },
});


\`\`\`

## packages-modules/counter/browser/src/connected-react-router/index.electron.ts

\`\`\`ts
export { ElectronTrayModule } from './electron-module';

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/index.ts

\`\`\`ts
import { Feature } from '@common-stack/client-react';
import repository from './module';
import { Counter } from './components/Counter';

export { Counter };
export default new Feature(repository);

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/interfaces/index.ts

\`\`\`ts
export * from './state';

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/interfaces/state.ts

\`\`\`ts
import { RouterState } from 'connected-react-router';

export interface State {
    connectedReactRouterCounter: number;
    router: RouterState;
}

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/module.tsx

\`\`\`tsx
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import * as React from 'react';
import { Feature } from '@common-stack/client-react';
import { Counter } from './components/Counter';
import NavBar from './components/NavBar';
import { connectedReactRouterCounter } from './redux';
import { filteredRoutes, filteredMenus } from './compute';

export default new Feature({
    navItem: <Counter />, // used in electron
    menuConfig: filteredMenus,
    routeConfig: filteredRoutes,
    reducer: { connectedReactRouterCounter },
});

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/redux/actions/counter.ts

\`\`\`ts
import { CONNECTED_REACT_ROUTER_ACTION_TYPES } from '../../constants';

export const increment = () => ({
    type: CONNECTED_REACT_ROUTER_ACTION_TYPES.INCREMENT,
});

export const decrement = () => ({
    type: CONNECTED_REACT_ROUTER_ACTION_TYPES.DECREMENT,
});

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/redux/actions/index.ts

\`\`\`ts
export * from './counter';

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/redux/index.ts

\`\`\`ts
export * from './actions';
export * from './reducers';

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/redux/reducers/counter.ts

\`\`\`ts
import { Action } from 'redux';
import { CONNECTED_REACT_ROUTER_ACTION_TYPES } from '../../constants';

const connectedReactRouterCounter = (state = 0, action: Action) => {
    switch (action.type) {
        case CONNECTED_REACT_ROUTER_ACTION_TYPES.INCREMENT:
            return state + 1;
        case CONNECTED_REACT_ROUTER_ACTION_TYPES.DECREMENT:
            return state - 1;
        default:
            return state;
    }
};

export { connectedReactRouterCounter };

\`\`\`

## packages-modules/counter/browser/src/connected-react-router/redux/reducers/index.ts

\`\`\`ts
export * from './counter';

\`\`\`

## packages-modules/counter/browser/src/fela/components/CompledWithTheme.tsx

\`\`\`tsx
import * as React from 'react';


import { ThemeProvider } from 'react-fela';
import { Complex } from './ComplexComponent';
import { theme } from '../theme';


const extendStyles = {
    container: {
        borderColor: 'black',
        borderRadius: '10px',
        borderStyle: 'solid',
    },
};


export const ComplexWithTheme: React.FunctionComponent<{}> = props => {


    return (
        <ThemeProvider theme={theme}>
            <Complex fontScale={10} extend={extendStyles} />
        </ThemeProvider>
    );

};

\`\`\`

## packages-modules/counter/browser/src/fela/components/ComplexComponent.tsx

\`\`\`tsx
import * as React from 'react';
import { connect, FelaWithStylesProps, Rules } from 'react-fela';
import { Theme } from '../interfaces';


interface OwnProps {
    fontScale: number;
}

interface Styles {
    container: any;
    firstSection: any;
    secondSection: any;
    thirdSection: any;
}

type Props = OwnProps & FelaWithStylesProps<OwnProps, Styles, Theme>;

const ComplexComponent: React.FunctionComponent<Props> = props => {
    const { styles, rules, theme } = props;

    return (
        <div>
            <div className={styles.container}>
            <div className={styles.firstSection}>First Section</div>
            <div className={styles.secondSection}>Second Section</div>
            <div className={styles.thirdSection}>Third Section</div>
            </div>
            <div>
                <h3>Rules</h3>
                {Object.entries(rules)
                .map(([key, rule]) => (
                    <div key={key}>
                    {`${key}: ${JSON.stringify(rule(props))}`}
                    </div>
                ))}
            </div>
            <div>
                <h3>Theme</h3>
                {JSON.stringify(theme)}
            </div>
        </div>

    );
};

const complexComponentStyle: Rules<OwnProps, Styles, Theme> = ({fontScale, theme}) => ({
    container: {
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
    },
    firstSection: ({ theme }) => ({
        backgroundColor: theme.color.primary,
        fontSize: `{5 * fontScale}px`,
    }),
    secondSection: {
        backgroundColor: theme.color.secondary,
        fontSize: `${7 * fontScale}px`,
    },
    thirdSection: {
        backgroundColor: theme.color.additional,
        fontSize: `${10 * fontScale}px`,
    },
});

export const Complex = connect(complexComponentStyle)(ComplexComponent);




\`\`\`

## packages-modules/counter/browser/src/fela/components/index.ts

\`\`\`ts
export * from './ComplexComponent';

\`\`\`

## packages-modules/counter/browser/src/fela/compute.tsx

\`\`\`tsx
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import * as React from 'react';
import { IMenuPosition } from '@common-stack/client-react';
import { getFilteredMenus, getFilteredRoutes } from '../utils';
import { ComplexWithTheme } from './components/CompledWithTheme';



export const felaPageStore: any[] = [
    {
        component: ComplexWithTheme,
        tab: 'Fela Styling',
        key: 'fela',
        position: IMenuPosition.MIDDLE,
        name: 'Fela Styling',
        path: '/fela',
    },
];

const selectedRoutesAndMenus = ['fela'];

// get menus
const filteredMenus = getFilteredMenus(felaPageStore, selectedRoutesAndMenus);

// get routes
const filteredRoutes = getFilteredRoutes(felaPageStore, selectedRoutesAndMenus);

export { filteredMenus, filteredRoutes };

\`\`\`

## packages-modules/counter/browser/src/fela/index.ts

\`\`\`ts
import { Feature } from '@common-stack/client-react';
import fela from './module';

export default new Feature(fela);

\`\`\`

## packages-modules/counter/browser/src/fela/interfaces/index.ts

\`\`\`ts
export * from './theme';

\`\`\`

## packages-modules/counter/browser/src/fela/interfaces/theme.ts

\`\`\`ts
export interface Theme {
    color: {
        primary: string;
        secondary: string;
        additional: string;
    };
}

\`\`\`

## packages-modules/counter/browser/src/fela/module.tsx

\`\`\`tsx
import * as React from 'react';
import { Feature } from '@common-stack/client-react';
import { filteredMenus, filteredRoutes } from './compute';



export default new Feature({
    menuConfig: filteredMenus,
    routeConfig: filteredRoutes,
});

\`\`\`

## packages-modules/counter/browser/src/fela/theme.ts

\`\`\`ts
import { Theme } from './interfaces';

export const theme: Theme = {
    color: {
        primary: 'lightblue',
        secondary: 'red',
        additional: 'lightgreen',
    },
};

\`\`\`

## packages-modules/counter/browser/src/generated-models.ts

\`\`\`ts
/* tslint:disable */
import { GraphQLResolveInfo } from 'graphql';
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type RequireFields<T, K extends keyof T> = { [X in Exclude<keyof T, K>]?: T[X] } & { [P in K]-?: NonNullable<T[P]> };
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
};

export type ClientCounter = {
  __typename?: 'ClientCounter';
  counter?: Maybe<Scalars['Int']>;
};

/**  Database counter  */
export type Counter = {
  __typename?: 'Counter';
  /**  Current amount  */
  amount: Scalars['Int'];
};

export type Mutation = {
  __typename?: 'Mutation';
  /**  Increase counter value returns current counter amount  */
  addCounter?: Maybe<Counter>;
  addCounterState?: Maybe<ClientCounter>;
  /**  add Counter  */
  addMoleculerCounter?: Maybe<Counter>;
  /**  sync cached counter with current value  */
  syncCachedCounter?: Maybe<Scalars['Boolean']>;
};


export type MutationAddCounterArgs = {
  amount?: Maybe<Scalars['Int']>;
};


export type MutationAddCounterStateArgs = {
  amount: Scalars['Int'];
};


export type MutationAddMoleculerCounterArgs = {
  amount?: Maybe<Scalars['Int']>;
};

export type Query = {
  __typename?: 'Query';
  /**  Counter  */
  counter?: Maybe<Counter>;
  /**  Counter from Datasource  */
  counterCache?: Maybe<Counter>;
  counterState?: Maybe<ClientCounter>;
  /**  Moleculer Counter  */
  moleculerCounter?: Maybe<Counter>;
};

export type Subscription = {
  __typename?: 'Subscription';
  /**  Subscription fired when anyone increases counter  */
  counterUpdated?: Maybe<Counter>;
  moleculerCounterUpdate?: Maybe<Counter>;
};

export type AddCounterStateMutationVariables = Exact<{
  amount: Scalars['Int'];
}>;


export type AddCounterStateMutation = (
  { __typename?: 'Mutation' }
  & { addCounterState?: Maybe<(
    { __typename?: 'ClientCounter' }
    & Pick<ClientCounter, 'counter'>
  )> }
);

export type AddCounterMutationVariables = Exact<{
  amount: Scalars['Int'];
}>;


export type AddCounterMutation = (
  { __typename?: 'Mutation' }
  & { addCounter?: Maybe<(
    { __typename?: 'Counter' }
    & Pick<Counter, 'amount'>
  )> }
);

export type AddCounter_WsMutationVariables = Exact<{
  amount: Scalars['Int'];
}>;


export type AddCounter_WsMutation = (
  { __typename?: 'Mutation' }
  & { addCounter?: Maybe<(
    { __typename?: 'Counter' }
    & Pick<Counter, 'amount'>
  )> }
);

export type SyncCachedCounterMutationVariables = Exact<{ [key: string]: never; }>;


export type SyncCachedCounterMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'syncCachedCounter'>
);

export type CounterCacheQueryQueryVariables = Exact<{ [key: string]: never; }>;


export type CounterCacheQueryQuery = (
  { __typename?: 'Query' }
  & { counterCache?: Maybe<(
    { __typename?: 'Counter' }
    & Pick<Counter, 'amount'>
  )> }
);

export type CounterStateQueryVariables = Exact<{ [key: string]: never; }>;


export type CounterStateQuery = (
  { __typename?: 'Query' }
  & { counterState?: Maybe<(
    { __typename?: 'ClientCounter' }
    & Pick<ClientCounter, 'counter'>
  )> }
);

export type CounterQueryQueryVariables = Exact<{ [key: string]: never; }>;


export type CounterQueryQuery = (
  { __typename?: 'Query' }
  & { counter?: Maybe<(
    { __typename?: 'Counter' }
    & Pick<Counter, 'amount'>
  )> }
);

export type OnCounterUpdatedSubscriptionVariables = Exact<{ [key: string]: never; }>;


export type OnCounterUpdatedSubscription = (
  { __typename?: 'Subscription' }
  & { counterUpdated?: Maybe<(
    { __typename?: 'Counter' }
    & Pick<Counter, 'amount'>
  )> }
);



export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
  selectionSet: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  Query: ResolverTypeWrapper<{}>;
  Counter: ResolverTypeWrapper<Counter>;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  ClientCounter: ResolverTypeWrapper<ClientCounter>;
  Mutation: ResolverTypeWrapper<{}>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  Subscription: ResolverTypeWrapper<{}>;
  String: ResolverTypeWrapper<Scalars['String']>;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  Query: {};
  Counter: Counter;
  Int: Scalars['Int'];
  ClientCounter: ClientCounter;
  Mutation: {};
  Boolean: Scalars['Boolean'];
  Subscription: {};
  String: Scalars['String'];
};

export type ClientCounterResolvers<ContextType = any, ParentType extends ResolversParentTypes['ClientCounter'] = ResolversParentTypes['ClientCounter']> = {
  counter?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CounterResolvers<ContextType = any, ParentType extends ResolversParentTypes['Counter'] = ResolversParentTypes['Counter']> = {
  amount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
  addCounter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType, RequireFields<MutationAddCounterArgs, never>>;
  addCounterState?: Resolver<Maybe<ResolversTypes['ClientCounter']>, ParentType, ContextType, RequireFields<MutationAddCounterStateArgs, 'amount'>>;
  addMoleculerCounter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType, RequireFields<MutationAddMoleculerCounterArgs, never>>;
  syncCachedCounter?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  counter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
  counterCache?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
  counterState?: Resolver<Maybe<ResolversTypes['ClientCounter']>, ParentType, ContextType>;
  moleculerCounter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
};

export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {
  counterUpdated?: SubscriptionResolver<Maybe<ResolversTypes['Counter']>, "counterUpdated", ParentType, ContextType>;
  moleculerCounterUpdate?: SubscriptionResolver<Maybe<ResolversTypes['Counter']>, "moleculerCounterUpdate", ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  ClientCounter?: ClientCounterResolvers<ContextType>;
  Counter?: CounterResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  Subscription?: SubscriptionResolvers<ContextType>;
};


/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
 */
export type IResolvers<ContextType = any> = Resolvers<ContextType>;


export const AddCounterStateDocument = gql`
    mutation addCounterState($amount: Int!) {
  addCounterState(amount: $amount) @client {
    counter
  }
}
    `;

/**
 * __useAddCounterStateMutation__
 *
 * To run a mutation, you first call `useAddCounterStateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCounterStateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCounterStateMutation, { data, loading, error }] = useAddCounterStateMutation({
 *   variables: {
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useAddCounterStateMutation(baseOptions?: Apollo.MutationHookOptions<AddCounterStateMutation, AddCounterStateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCounterStateMutation, AddCounterStateMutationVariables>(AddCounterStateDocument, options);
      }
export type AddCounterStateMutationHookResult = ReturnType<typeof useAddCounterStateMutation>;
export type AddCounterStateMutationResult = Apollo.MutationResult<AddCounterStateMutation>;
export type AddCounterStateMutationOptions = Apollo.BaseMutationOptions<AddCounterStateMutation, AddCounterStateMutationVariables>;
export const AddCounterDocument = gql`
    mutation addCounter($amount: Int!) {
  addCounter(amount: $amount) {
    amount
  }
}
    `;

/**
 * __useAddCounterMutation__
 *
 * To run a mutation, you first call `useAddCounterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCounterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCounterMutation, { data, loading, error }] = useAddCounterMutation({
 *   variables: {
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useAddCounterMutation(baseOptions?: Apollo.MutationHookOptions<AddCounterMutation, AddCounterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCounterMutation, AddCounterMutationVariables>(AddCounterDocument, options);
      }
export type AddCounterMutationHookResult = ReturnType<typeof useAddCounterMutation>;
export type AddCounterMutationResult = Apollo.MutationResult<AddCounterMutation>;
export type AddCounterMutationOptions = Apollo.BaseMutationOptions<AddCounterMutation, AddCounterMutationVariables>;
export const AddCounter_WsDocument = gql`
    mutation AddCounter_WS($amount: Int!) {
  addCounter(amount: $amount) {
    amount
  }
}
    `;

/**
 * __useAddCounter_WsMutation__
 *
 * To run a mutation, you first call `useAddCounter_WsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCounter_WsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCounterWsMutation, { data, loading, error }] = useAddCounter_WsMutation({
 *   variables: {
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useAddCounter_WsMutation(baseOptions?: Apollo.MutationHookOptions<AddCounter_WsMutation, AddCounter_WsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCounter_WsMutation, AddCounter_WsMutationVariables>(AddCounter_WsDocument, options);
      }
export type AddCounter_WsMutationHookResult = ReturnType<typeof useAddCounter_WsMutation>;
export type AddCounter_WsMutationResult = Apollo.MutationResult<AddCounter_WsMutation>;
export type AddCounter_WsMutationOptions = Apollo.BaseMutationOptions<AddCounter_WsMutation, AddCounter_WsMutationVariables>;
export const SyncCachedCounterDocument = gql`
    mutation SyncCachedCounter {
  syncCachedCounter
}
    `;

/**
 * __useSyncCachedCounterMutation__
 *
 * To run a mutation, you first call `useSyncCachedCounterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSyncCachedCounterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [syncCachedCounterMutation, { data, loading, error }] = useSyncCachedCounterMutation({
 *   variables: {
 *   },
 * });
 */
export function useSyncCachedCounterMutation(baseOptions?: Apollo.MutationHookOptions<SyncCachedCounterMutation, SyncCachedCounterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SyncCachedCounterMutation, SyncCachedCounterMutationVariables>(SyncCachedCounterDocument, options);
      }
export type SyncCachedCounterMutationHookResult = ReturnType<typeof useSyncCachedCounterMutation>;
export type SyncCachedCounterMutationResult = Apollo.MutationResult<SyncCachedCounterMutation>;
export type SyncCachedCounterMutationOptions = Apollo.BaseMutationOptions<SyncCachedCounterMutation, SyncCachedCounterMutationVariables>;
export const CounterCacheQueryDocument = gql`
    query counterCacheQuery {
  counterCache {
    amount
  }
}
    `;

/**
 * __useCounterCacheQueryQuery__
 *
 * To run a query within a React component, call `useCounterCacheQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useCounterCacheQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCounterCacheQueryQuery({
 *   variables: {
 *   },
 * });
 */
export function useCounterCacheQueryQuery(baseOptions?: Apollo.QueryHookOptions<CounterCacheQueryQuery, CounterCacheQueryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CounterCacheQueryQuery, CounterCacheQueryQueryVariables>(CounterCacheQueryDocument, options);
      }
export function useCounterCacheQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CounterCacheQueryQuery, CounterCacheQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CounterCacheQueryQuery, CounterCacheQueryQueryVariables>(CounterCacheQueryDocument, options);
        }
export type CounterCacheQueryQueryHookResult = ReturnType<typeof useCounterCacheQueryQuery>;
export type CounterCacheQueryLazyQueryHookResult = ReturnType<typeof useCounterCacheQueryLazyQuery>;
export type CounterCacheQueryQueryResult = Apollo.QueryResult<CounterCacheQueryQuery, CounterCacheQueryQueryVariables>;
export const CounterStateDocument = gql`
    query CounterState {
  counterState @client {
    counter
  }
}
    `;

/**
 * __useCounterStateQuery__
 *
 * To run a query within a React component, call `useCounterStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useCounterStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCounterStateQuery({
 *   variables: {
 *   },
 * });
 */
export function useCounterStateQuery(baseOptions?: Apollo.QueryHookOptions<CounterStateQuery, CounterStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CounterStateQuery, CounterStateQueryVariables>(CounterStateDocument, options);
      }
export function useCounterStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CounterStateQuery, CounterStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CounterStateQuery, CounterStateQueryVariables>(CounterStateDocument, options);
        }
export type CounterStateQueryHookResult = ReturnType<typeof useCounterStateQuery>;
export type CounterStateLazyQueryHookResult = ReturnType<typeof useCounterStateLazyQuery>;
export type CounterStateQueryResult = Apollo.QueryResult<CounterStateQuery, CounterStateQueryVariables>;
export const CounterQueryDocument = gql`
    query counterQuery {
  counter {
    amount
  }
}
    `;

/**
 * __useCounterQueryQuery__
 *
 * To run a query within a React component, call `useCounterQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useCounterQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCounterQueryQuery({
 *   variables: {
 *   },
 * });
 */
export function useCounterQueryQuery(baseOptions?: Apollo.QueryHookOptions<CounterQueryQuery, CounterQueryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CounterQueryQuery, CounterQueryQueryVariables>(CounterQueryDocument, options);
      }
export function useCounterQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CounterQueryQuery, CounterQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CounterQueryQuery, CounterQueryQueryVariables>(CounterQueryDocument, options);
        }
export type CounterQueryQueryHookResult = ReturnType<typeof useCounterQueryQuery>;
export type CounterQueryLazyQueryHookResult = ReturnType<typeof useCounterQueryLazyQuery>;
export type CounterQueryQueryResult = Apollo.QueryResult<CounterQueryQuery, CounterQueryQueryVariables>;
export const OnCounterUpdatedDocument = gql`
    subscription onCounterUpdated {
  counterUpdated {
    amount
  }
}
    `;

/**
 * __useOnCounterUpdatedSubscription__
 *
 * To run a query within a React component, call `useOnCounterUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnCounterUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnCounterUpdatedSubscription({
 *   variables: {
 *   },
 * });
 */
export function useOnCounterUpdatedSubscription(baseOptions?: Apollo.SubscriptionHookOptions<OnCounterUpdatedSubscription, OnCounterUpdatedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnCounterUpdatedSubscription, OnCounterUpdatedSubscriptionVariables>(OnCounterUpdatedDocument, options);
      }
export type OnCounterUpdatedSubscriptionHookResult = ReturnType<typeof useOnCounterUpdatedSubscription>;
export type OnCounterUpdatedSubscriptionResult = Apollo.SubscriptionResult<OnCounterUpdatedSubscription>;
\`\`\`

## packages-modules/counter/browser/src/index.ts

\`\`\`ts
import { Feature } from '@common-stack/client-react';

import Common from './common';
import ApolloCounter from './apollo-server-n-client';
import ConnectedReactRouter from './connected-react-router';
import Fela from './fela';
import { ElectronTrayModule } from './connected-react-router/index.electron';

export default new Feature(Common, ConnectedReactRouter, ApolloCounter, Fela);
export { ElectronTrayModule };

\`\`\`

## packages-modules/counter/browser/src/utils/index.ts

\`\`\`ts
export * from './menu';

\`\`\`

## packages-modules/counter/browser/src/utils/menu.ts

\`\`\`ts
export const getFilteredMenus = (accountPageStore, selectedMenu) =>
    accountPageStore
        .map((item) => {
            if (selectedMenu.indexOf(item.key) !== -1) {
                const { path, component, ...rest } = item;
                return {
                    [path]: { name: rest.tab, ...rest },
                };
            }
        })
        .filter((valid) => valid);

export const getFilteredRoutes = (accountPageStore, selectedRoutes) =>
    accountPageStore
        .map((item) => {
            if (selectedRoutes.indexOf(item.key) !== -1) {
                const { path } = item;
                return {
                    [path]: item,
                };
            }
            return null;
        })
        .filter((valid) => valid);

export const getFilteredTabs = (accountPageStore, selectedTabs) =>
    accountPageStore
        .map((item) => {
            if (selectedTabs.indexOf(item.key) !== -1) {
                const { component, ...rest } = item;
                return rest;
            }
        })
        .filter((valid) => valid);

\`\`\`

## packages-modules/counter/browser/tsconfig.json

\`\`\`json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "rootDir": "./src",
    "outDir": "lib",
    "declarationDir": "lib",
    "declaration": true,
    "declarationMap": true,
    "types": [
      "@types/node",
      "@types/jest",
      "../../../typings",
    ]
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js",
    "rollup.config.js"
  ],
  "include": [
    "src",
    "./typings/*.d.ts"
  ]
}
\`\`\`

## packages-modules/counter/browser/typings/graphql.d.ts

\`\`\`ts
declare module "*/AddCounter.client.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const addCounterState: DocumentNode;

  export default defaultDocument;
}

declare module "*/AddCounter.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const addCounter: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterQuery.client.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const CounterState: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterQuery.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const counterQuery: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterSubscription.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const onCounterUpdated: DocumentNode;

  export default defaultDocument;
}

\`\`\`

## packages-modules/counter/browser/webpack.config.js

\`\`\`js
const nodeExternals = require('webpack-node-externals');
const webpack = require('webpack');
const path = require('path');

const webpackOpts = {
    mode: 'development',
    entry: {
        index: './src/index.ts',
    },
    target: 'node',
    output: {
        path: path.join(__dirname, 'lib'),
        filename: '[name].js',
        libraryTarget: 'commonjs2',
    },
    resolve: {
        extensions: ['.ts', '.tsx', '.graphql', '.graphqls', '.gql', '.native.tsx', '.native.ts'],
    },
    plugins: [
        new webpack.LoaderOptionsPlugin({
            options: {
                test: /\.tsx?$/,
                ts: {
                    compiler: 'typescript',
                    configFile: 'tsconfig.json',
                },
                tslint: {
                    emitErrors: true,
                    failOnHint: true,
                },
            },
        }),
    ],
    devtool: 'source-map',
    module: {
        rules: [
            {
                test: /\.tsx?$/,
                loaders: 'ts-loader',
                options: {
                    compilerOptions: {
                        outDir: path.join(),
                    },
                },
            },
            {
                test: /\.mjs$/,
                include: /node_modules/,
                type: 'javascript/auto',
            },
            {
                test: /\.(gql)$/,
                exclude: /node_modules/,
                use: ['graphql-tag/loader'],
            },
            {
                test: /\.graphql?/,
                exclude: /node_modules/,
                use: 'raw-loader',
            },
        ],
    },
    externals: [nodeExternals({ modulesDir: '../../../node_modules' }), nodeExternals()],
};

module.exports = webpackOpts;

\`\`\`

## packages-modules/counter/electron/jest.config.js

\`\`\`js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    testEnvironment: 'jsdom', // This is overriden, from the base testEnvironment
    name: packageJson.name,
    displayName: packageJson.name,
};
\`\`\`

## packages-modules/counter/electron/rollup.config.js

\`\`\`js
import graphql from '@rollup/plugin-graphql';
import image from '@rollup/plugin-image';
import typescript from '@rollup/plugin-typescript';

const bundle = (config) => ({
    ...config,
    input: 'src/index.ts',
    // marking all node modules as external
    external: (id) => !/^[./]/.test(id),
});
const globals = { react: 'React' };

export default [
    bundle({
        plugins: [typescript({ noEmitOnError: true }), image(), graphql()],
        output: [
            {
                dir: 'lib',
                format: 'es',
                name: 'Counter',
                compact: true,
                exports: 'named',
                sourcemap: true,
                preserveModules: true,
                chunkFileNames: '[name]-[hash].[format].js',
                globals,
            },
        ],
    }),
];

\`\`\`

## packages-modules/counter/electron/src/epics/count-tray-updater.ts

\`\`\`ts
/* eslint-disable @typescript-eslint/no-unused-vars */
import { ofType } from 'redux-observable';
import { Observable, of } from 'rxjs';
import { distinctUntilChanged, map, tap, exhaustMap, pluck, catchError, filter } from 'rxjs/operators';
import { ElectronTypes } from '@common-stack/client-core';
import { CONNECTED_REACT_ROUTER_ACTION_TYPES } from '@sample-stack/counter-module-browser/lib/connected-react-router/constants/action-types';

export const onCountChangedEpic = (
    action$: Observable<any>,
    state$: Observable<any>,
    { container, routes }: { container: any; routes },
) =>
    action$.pipe(
        ofType(CONNECTED_REACT_ROUTER_ACTION_TYPES.INCREMENT),
        exhaustMap(() =>
            state$.pipe(
                pluck('connectedReactRouterCounter'),
                distinctUntilChanged(),
                tap((count) => {
                    const st = container.get(ElectronTypes.TrayWindow);
                    st.updateTitle(count.toString());
                }),
                ofType('TRAY_UPDATED'),
            ),
        ),
    );

\`\`\`

## packages-modules/counter/electron/src/epics/index.ts

\`\`\`ts
export * from './count-tray-updater';

\`\`\`

## packages-modules/counter/electron/src/index.ts

\`\`\`ts
import { Feature } from '@common-stack/client-react';
import { connectedReactRouterCounter } from '@sample-stack/counter-module-browser/lib/connected-react-router/redux/reducers/counter';
import { onCountChangedEpic } from './epics';

const ElectronMainModule = new Feature({
    reducer: { connectedReactRouterCounter },
    epic: [onCountChangedEpic],
});

export default new Feature(ElectronMainModule);

\`\`\`

## packages-modules/counter/electron/tsconfig.json

\`\`\`json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "rootDir": "./src",
    "outDir": "lib",
    "declarationDir": "lib",
    "declaration": true,
    "declarationMap": true
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js",
    "rollup.config.js"
  ],
  "include": [
    "src",
    "./typings/*.d.ts"
  ]
}
\`\`\`

## packages-modules/counter/electron/typings/graphql.d.ts

\`\`\`ts
declare module "*/AddCounter.client.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const addCounterState: DocumentNode;

  export default defaultDocument;
}

declare module "*/AddCounter.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const addCounter: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterQuery.client.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const CounterState: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterQuery.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const counterQuery: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterSubscription.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const onCounterUpdated: DocumentNode;

  export default defaultDocument;
}

\`\`\`

## packages-modules/counter/electron/webpack.config.js

\`\`\`js
const nodeExternals = require('webpack-node-externals');
const webpack = require('webpack');
const path = require('path');

const webpackOpts = {
    mode: 'development',
    entry: {
        index: './src/index.ts',
    },
    target: 'node',
    output: {
        path: path.join(__dirname, 'lib'),
        filename: '[name].js',
        libraryTarget: 'commonjs2',
    },
    resolve: {
        extensions: ['.ts', '.tsx', '.js', '.graphql', '.graphqls', '.gql', '.native.tsx', '.native.ts'],
    },
    plugins: [
        new webpack.LoaderOptionsPlugin({
            options: {
                test: /\.tsx?$/,
                ts: {
                    compiler: 'typescript',
                    configFile: 'tsconfig.json',
                },
                tslint: {
                    emitErrors: true,
                    failOnHint: true,
                },
            },
        }),
    ],
    devtool: 'source-map',
    module: {
        rules: [
            {
                test: /\.tsx?$/,
                loaders: 'ts-loader',
                options: {
                    compilerOptions: {
                        outDir: path.join(),
                    },
                },
            },
            {
                test: /\.mjs$/,
                include: /node_modules/,
                type: 'javascript/auto',
            },
            {
                test: /\.(gql)$/,
                exclude: /node_modules/,
                use: ['graphql-tag/loader'],
            },
            {
                test: /\.graphql?/,
                exclude: /node_modules/,
                use: 'raw-loader',
            },
        ],
    },
    externals: [
        nodeExternals({
            allowlist: [/^@sample-stack/],
            modulesDir: '../../../node_modules',
        }),
        nodeExternals({
            allowlist: [/^@sample-stack/],
        }),
    ],
};

module.exports = webpackOpts;

\`\`\`

## packages-modules/counter/mobile/jest.config.js

\`\`\`js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    testEnvironment: 'jsdom', // This is overriden, from the base testEnvironment
    name: packageJson.name,
    displayName: packageJson.name,
};

\`\`\`

## packages-modules/counter/mobile/src/common/components/Dashboard.tsx

\`\`\`tsx
import * as React from 'react';
import { renderRoutes } from 'react-router-config';

export const Dashboard = (props) =>  <>{renderRoutes(props.route.routes, { matchPath: props.route.path })}</>;

\`\`\`

## packages-modules/counter/mobile/src/common/components/Home.tsx

\`\`\`tsx
import * as React from 'react';

export const Home = () => (
    <div>
        <h1>FullStack-Pro</h1>
    </div>
);

\`\`\`

## packages-modules/counter/mobile/src/common/compute.tsx

\`\`\`tsx
import * as React from 'react';
import { IMenuPosition } from '@common-stack/client-react';

import { Home } from '../common/components/Home';
import { getFilteredRoutes } from '../utils';

export const commonPageStore: any[] = [
    {
        path: '/',
        key: 'home',
        exact: true,
        name: 'Home',
        component: Home,
        position: IMenuPosition.MIDDLE,
    },
];

const selectedRoutesAndMenus = ['home'];


// get routes
const filteredRoutes = getFilteredRoutes(commonPageStore, selectedRoutesAndMenus);

export { filteredRoutes };

\`\`\`

## packages-modules/counter/mobile/src/common/generated-models.ts

\`\`\`ts
/* tslint:disable */

import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';

import gql from 'graphql-tag';
import { MyContext } from './interfaces/context';

export type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    AnyObject: any;
    JSON: any;
    JSONObject: any;
    Date: any;
    Time: any;
    DateTime: any;
};

export type ClientCounter = {
    counter?: Maybe<Scalars['Int']>;
};

export type Counter = {
    amount: Scalars['Int'];
};

export type FieldError = {
    field: Scalars['String'];
    message: Scalars['String'];
};

export type Mutation = {
    dummy?: Maybe<Scalars['Int']>;
    addCounterState?: Maybe<ClientCounter>;
    addCounter?: Maybe<Counter>;
};

export type MutationAddCounterStateArgs = {
    amount: Scalars['Int'];
};

export type MutationAddCounterArgs = {
    amount?: Maybe<Scalars['Int']>;
};

export type Node = {
    id: Scalars['ID'];
};

export type Query = {
    dummy?: Maybe<Scalars['Int']>;
    counterState?: Maybe<ClientCounter>;
    counter?: Maybe<Counter>;
};

export type Subscription = {
    dummy?: Maybe<Scalars['Int']>;
    counterUpdated?: Maybe<Counter>;
};

export type AddCounterStateMutationVariables = {
    amount: Scalars['Int'];
};

export type AddCounterStateMutation = { __typename?: 'Mutation' } & {
    addCounterState: Maybe<{ __typename?: 'ClientCounter' } & Pick<ClientCounter, 'counter'>>;
};

export type AddCounterMutationVariables = {
    amount: Scalars['Int'];
};

export type AddCounterMutation = { __typename?: 'Mutation' } & {
    addCounter: Maybe<{ __typename?: 'Counter' } & Pick<Counter, 'amount'>>;
};

export type CounterStateQueryVariables = {};

export type CounterStateQuery = { __typename?: 'Query' } & {
    counterState: Maybe<{ __typename?: 'ClientCounter' } & Pick<ClientCounter, 'counter'>>;
};

export type CounterQueryQueryVariables = {};

export type CounterQueryQuery = { __typename?: 'Query' } & {
    counter: Maybe<{ __typename?: 'Counter' } & Pick<Counter, 'amount'>>;
};

export type OnCounterUpdatedSubscriptionVariables = {};

export type OnCounterUpdatedSubscription = { __typename?: 'Subscription' } & {
    counterUpdated: Maybe<{ __typename?: 'Counter' } & Pick<Counter, 'amount'>>;
};

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => Promise<TResult> | TResult;

export type StitchingResolver<TResult, TParent, TContext, TArgs> = {
    fragment: string;
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ResolverFn<TResult, TParent, TContext, TArgs>
    | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs>;
    resolve?: SubscriptionResolveFn<TResult, TParent, TContext, TArgs>;
}

export type SubscriptionResolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ((...args: any[]) => SubscriptionResolverObject<TResult, TParent, TContext, TArgs>)
    | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
    parent: TParent,
    context: TContext,
    info: GraphQLResolveInfo,
) => Maybe<TTypes>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
    next: NextResolverFn<TResult>,
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
    Query: {};
    Int: Scalars['Int'];
    ClientCounter: ClientCounter;
    Counter: Counter;
    Mutation: {};
    Subscription: {};
    String: Scalars['String'];
    Boolean: Scalars['Boolean'];
    AnyObject: Scalars['AnyObject'];
    JSON: Scalars['JSON'];
    JSONObject: Scalars['JSONObject'];
    FieldError: FieldError;
    Node: Node;
    ID: Scalars['ID'];
    Date: Scalars['Date'];
    Time: Scalars['Time'];
    DateTime: Scalars['DateTime'];
};

export interface AnyObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['AnyObject'], any> {
    name: 'AnyObject';
}

export type ClientCounterResolvers<ContextType = MyContext, ParentType = ResolversTypes['ClientCounter']> = {
    counter?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
};

export type CounterResolvers<ContextType = MyContext, ParentType = ResolversTypes['Counter']> = {
    amount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
};

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
    name: 'Date';
}

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
    name: 'DateTime';
}

export type FieldErrorResolvers<ContextType = MyContext, ParentType = ResolversTypes['FieldError']> = {
    field?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
    name: 'JSON';
}

export interface JsonObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSONObject'], any> {
    name: 'JSONObject';
}

export type MutationResolvers<ContextType = MyContext, ParentType = ResolversTypes['Mutation']> = {
    dummy?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    addCounterState?: Resolver<
        Maybe<ResolversTypes['ClientCounter']>,
        ParentType,
        ContextType,
        MutationAddCounterStateArgs
    >;
    addCounter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType, MutationAddCounterArgs>;
};

export type NodeResolvers<ContextType = MyContext, ParentType = ResolversTypes['Node']> = {
    __resolveType: TypeResolveFn<null, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type QueryResolvers<ContextType = MyContext, ParentType = ResolversTypes['Query']> = {
    dummy?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    counterState?: Resolver<Maybe<ResolversTypes['ClientCounter']>, ParentType, ContextType>;
    counter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
};

export type SubscriptionResolvers<ContextType = MyContext, ParentType = ResolversTypes['Subscription']> = {
    dummy?: SubscriptionResolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    counterUpdated?: SubscriptionResolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
};

export interface TimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Time'], any> {
    name: 'Time';
}

export type Resolvers<ContextType = MyContext> = {
    AnyObject?: GraphQLScalarType;
    ClientCounter?: ClientCounterResolvers<ContextType>;
    Counter?: CounterResolvers<ContextType>;
    Date?: GraphQLScalarType;
    DateTime?: GraphQLScalarType;
    FieldError?: FieldErrorResolvers<ContextType>;
    JSON?: GraphQLScalarType;
    JSONObject?: GraphQLScalarType;
    Mutation?: MutationResolvers<ContextType>;
    Node?: NodeResolvers;
    Query?: QueryResolvers<ContextType>;
    Subscription?: SubscriptionResolvers<ContextType>;
    Time?: GraphQLScalarType;
};

/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
 */
export type IResolvers<ContextType = MyContext> = Resolvers<ContextType>;
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export const AddCounterStateDocument = gql`
    mutation addCounterState($amount: Int!) {
        addCounterState(amount: $amount) @client {
            counter
        }
    }
`;
export const AddCounterDocument = gql`
    mutation addCounter($amount: Int!) {
        addCounter(amount: $amount) {
            amount
        }
    }
`;
export const CounterStateDocument = gql`
    query CounterState {
        counterState @client {
            counter
        }
    }
`;
export const CounterQueryDocument = gql`
    query counterQuery {
        counter {
            amount
        }
    }
`;
export const OnCounterUpdatedDocument = gql`
    subscription onCounterUpdated {
        counterUpdated {
            amount
        }
    }
`;

\`\`\`

## packages-modules/counter/mobile/src/common/index.ts

\`\`\`ts
import { Feature } from '@common-stack/client-react';
import common from './module';

export default new Feature(common);

\`\`\`

## packages-modules/counter/mobile/src/common/interfaces/context.ts

\`\`\`ts
import { DataProxy } from '@apollo/client/cache';
import { ApolloClient } from '@apollo/client';

export interface MyContext {
    cache: DataProxy;
    getCacheKey: (options: { __typename: string; resource?: string; id?: string }) => string;
    apolloClient: ApolloClient<any>;
}

\`\`\`

## packages-modules/counter/mobile/src/common/module.tsx

\`\`\`tsx
import * as  React from 'react';

import { Feature } from '@common-stack/client-react';
import { filteredRoutes } from './compute';

export default new Feature({
  routeConfig: filteredRoutes,
});

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/components/Counter.tsx

\`\`\`tsx
import * as React from 'react';
import { Button, View, Text } from 'react-native';
import { Dispatch } from 'redux';
import { connect } from 'react-redux';
import { increment, decrement } from '../redux';
import { State } from '../interfaces';

interface CounterStateProps {
    count: number;
}

interface CounterDispatchProps {
    increment: () => void;
    decrement: () => void;
}

const CounterScreen: React.SFC<CounterStateProps & CounterDispatchProps> = (props) => {
    return (
        <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
            <View style={{ marginTop: 20 }}>
                <View style={{ marginBottom: 20 }}>
                    <Text>Counter value: {props.count}</Text>
                </View>

                <Button onPress={props.increment} title="Increment Counter" />

                <View style={{ marginTop: 10 }}>
                    <Button onPress={props.decrement} title="Decrement Counter" />
                </View>
            </View>
        </View>
    );
};

const mapStateToProps = (state: State) => ({
    count: state.connectedReactRouterCounter,
});

const mapDispatchToProps = (dispatch: Dispatch) => ({
    increment: () => dispatch(increment()),
    decrement: () => dispatch(decrement()),
});

export const Counter = connect<CounterStateProps, CounterDispatchProps>(
    mapStateToProps as any,
    mapDispatchToProps,
)(CounterScreen);

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/components/Hello.tsx

\`\`\`tsx
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
import * as React from 'react';
import { StyleSheet, View, Text, ViewStyle } from 'react-native';
import {  Box } from 'native-base';
import { connect } from 'react-redux';

interface Style {
    container: ViewStyle;
}

const HelloScreen = () => {
    return (
        <View style={styles.container}>
            <Box>
                <Text>Hello Value</Text>
            </Box>
            <Box style={{ position: 'absolute', left: 0, right: 0, bottom: 0 }}>
                <View>
                    <Text>Footer will be here</Text>
                </View>
            </Box>
        </View>
    );
};

const styles = StyleSheet.create<Style>({
    container: {
        flex: 1,
        textAlign: 'center',
    },
});

export const Hello = connect((state: any) => {
    return {
        settings: state.settings,
        location: state?.route?.location,
    };
})(HelloScreen);

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/compute.tsx

\`\`\`tsx
/* eslint-disable @typescript-eslint/naming-convention */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { IMenuPosition } from '@common-stack/client-react';
import { Hello } from './components/Hello';
import { Counter } from './components/Counter';
import { getFilteredRoutes } from '../utils';

enum CONNECTED_REACT_ROUTER_ROUTES_TYPES {
    HOME = '/org',
    HELLO = '/org/hello',
    COUNTER = '/org/counter',
}

export const counterPageStore: any[] = [
    {
        exact: true,
        icon: 'export',
        name: 'Hello',
        component: Hello,
        position: IMenuPosition.MIDDLE,
        key: CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO,
        path: CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO,
    },
    {
        exact: true,
        icon: 'export',
        name: 'Counter',
        component: Counter,
        position: IMenuPosition.MIDDLE,
        key: CONNECTED_REACT_ROUTER_ROUTES_TYPES.COUNTER,
        path: CONNECTED_REACT_ROUTER_ROUTES_TYPES.COUNTER,
    },
];

const selectedRoutesAndMenus = [
    CONNECTED_REACT_ROUTER_ROUTES_TYPES.HOME,
    CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO,
    CONNECTED_REACT_ROUTER_ROUTES_TYPES.COUNTER,
];

// get routes
const filteredRoutes = getFilteredRoutes(counterPageStore, selectedRoutesAndMenus);

export { filteredRoutes };

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/constants/action-types.ts

\`\`\`ts
export const enum CONNECTED_REACT_ROUTER_ACTION_TYPES {
    INCREMENT = '@connected-react-router/INCREMENT',
    DECREMENT = '@connected-react-router/DECREMENT',
}

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/constants/index.ts

\`\`\`ts
export * from './action-types';
export * from './routes-types';

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/constants/routes-types.ts

\`\`\`ts
export enum CONNECTED_REACT_ROUTER_ROUTES_TYPES {
    HOME = '/org',
    HELLO = '/org/hello',
    COUNTER = '/org/counter',
}

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/index.ts

\`\`\`ts
import { Feature } from '@common-stack/client-react';
import reactRouter from './module';

export default new Feature(reactRouter);

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/interfaces/index.ts

\`\`\`ts
export * from './state';

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/interfaces/state.ts

\`\`\`ts
import { RouterState } from 'connected-react-router';

export interface State {
    connectedReactRouterCounter: number;
    router: RouterState;
}

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/module.tsx

\`\`\`tsx
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Feature } from '@common-stack/client-react';
import { connectedReactRouterCounter } from './redux';
import { filteredRoutes } from './compute';

export default new Feature({
    routeConfig: filteredRoutes,
    reducer: { connectedReactRouterCounter },
});

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/redux/actions/counter.ts

\`\`\`ts
import { CONNECTED_REACT_ROUTER_ACTION_TYPES } from '../../constants';

export const increment = () => ({
    type: CONNECTED_REACT_ROUTER_ACTION_TYPES.INCREMENT,
});

export const decrement = () => ({
    type: CONNECTED_REACT_ROUTER_ACTION_TYPES.DECREMENT,
});

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/redux/actions/index.ts

\`\`\`ts
export * from './counter';

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/redux/index.ts

\`\`\`ts
export * from './actions';
export * from './reducers';

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/redux/reducers/counter.ts

\`\`\`ts
import { Action } from 'redux';
import { CONNECTED_REACT_ROUTER_ACTION_TYPES } from '../../constants';

const connectedReactRouterCounter = (state = 0, action: Action) => {
    switch (action.type) {
        case CONNECTED_REACT_ROUTER_ACTION_TYPES.INCREMENT:
            return state + 1;
        case CONNECTED_REACT_ROUTER_ACTION_TYPES.DECREMENT:
            return state - 1;
        default:
            return state;
    }
};

export { connectedReactRouterCounter };

\`\`\`

## packages-modules/counter/mobile/src/connected-react-router/redux/reducers/index.ts

\`\`\`ts
export * from './counter';

\`\`\`

## packages-modules/counter/mobile/src/index.ts

\`\`\`ts
import { Feature } from '@common-stack/client-react';
import ConnectedReactRouter from './connected-react-router/index';

export default new Feature(ConnectedReactRouter);

\`\`\`

## packages-modules/counter/mobile/src/utils/index.ts

\`\`\`ts
export * from './menu';

\`\`\`

## packages-modules/counter/mobile/src/utils/menu.ts

\`\`\`ts
export const getFilteredRoutes = (accountPageStore, selectedRoutes) =>
    accountPageStore
        .map((item) => {
            if (selectedRoutes.indexOf(item.key) !== -1) {
                const { path } = item;
                return {
                    [path]: item,
                };
            }
            return null;
        })
        .filter((valid) => valid);

export const getFilteredTabs = (accountPageStore, selectedTabs) =>
    accountPageStore
        .map((item) => {
            if (selectedTabs.indexOf(item.key) !== -1) {
                const { component, ...rest } = item;
                return rest;
            }
        })
        .filter((valid) => valid);

\`\`\`

## packages-modules/counter/mobile/tsconfig.json

\`\`\`json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "target": "esnext",
    "jsx": "react-native",
    "lib": ["es2017"],
    "esModuleInterop": true,
    "sourceMap": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "rootDir": "src",
    "outDir": "lib",
    "declaration": true,
    "declarationDir": "lib",
    "types": [
      "@types/node",
      "@types/jest",
      "../../../typings",
    ],
    "skipLibCheck": true
  },
  "include": ["src"],
  "exclude": [
    "node_modules",
    "lib",
    "jest.config.js",
    "webpack.config.js",
    "rollup.config.js"
  ]
}

\`\`\`

## packages-modules/counter/mobile/typings/graphql.d.ts

\`\`\`ts
declare module "*/AddCounter.client.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const addCounterState: DocumentNode;

  export default defaultDocument;
}

declare module "*/AddCounter.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const addCounter: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterQuery.client.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const CounterState: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterQuery.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const counterQuery: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterSubscription.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const onCounterUpdated: DocumentNode;

  export default defaultDocument;
}

\`\`\`

## packages-modules/counter/server/jest.config.js

\`\`\`js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    name: packageJson.name,
    displayName: packageJson.name,
};
\`\`\`

## packages-modules/counter/server/src/config/config.ts

\`\`\`ts
import * as envalid from 'envalid';

const { str, num } = envalid;

export const config = envalid.cleanEnv(process.env, {
    FILES_TTL: num({ default: 3600, desc: 'TTL for files cache in Seconds' }),
});

\`\`\`

## packages-modules/counter/server/src/config/index.ts

\`\`\`ts
export * from './config';

\`\`\`

## packages-modules/counter/server/src/constants/constants.ts

\`\`\`ts
export const NATS_MOLECULER_COUNTER_SERIVCE = 'NATS_MOLECULER_COUNTER_SERIVCE';

export enum CounterCommands {
    COUNTER_QUERY = 'COUNTER_QUERY',
    ADD_COUNTER = 'ADD_COUNTER',
}

export const TYPES = {
    CounterMockService: Symbol('CounterMockService'),
    CounterMockMicroservice: Symbol('CounterMockMicroservice'),
    CounterMockRemoteService: Symbol('CounterMockRemoteService'),
};

\`\`\`

## packages-modules/counter/server/src/constants/index.ts

\`\`\`ts
export * from './constants';

\`\`\`

## packages-modules/counter/server/src/containers/containers.ts

\`\`\`ts
import { ContainerModule, interfaces } from 'inversify';
import { CounterMockService, CounterMockProxyService } from '../services';
import { TYPES } from '../constants';
import { ICounterService } from '../interfaces';

/**
 * Local services and exposed micro services to serve remote connections.
 * Operates within in the Gateway.
 *
 * @param settings Settings
 */
export const localCounterModule: (settings) => interfaces.ContainerModule = (settings) =>
    new ContainerModule((bind: interfaces.Bind) => {
        // bind<ICounterService>(TYPES.CounterMockService)
        //     .to(CounterMockService)
        //     .inSingletonScope()
        //     .whenTargetIsDefault();

        bind<ICounterService>(TYPES.CounterMockService)
            .to(CounterMockProxyService)
            .inSingletonScope()
            .whenTargetNamed('proxy');
    });

/**
 * Operates external to the Gateway. Usually a broker listen to calls and invoke this service
 * local to the micro container.
 *
 * @param settings Settings
 */
export const externalCounterModule: (settings) => interfaces.ContainerModule = (settings) =>
    new ContainerModule((bind: interfaces.Bind) => {
        bind<ICounterService>(TYPES.CounterMockService).to(CounterMockService).inSingletonScope();
    });

\`\`\`

## packages-modules/counter/server/src/containers/index.ts

\`\`\`ts
export * from './containers';

\`\`\`

## packages-modules/counter/server/src/dataloader/cache.ts

\`\`\`ts
import * as DataLoader from 'dataloader';
import { KeyValueCache } from 'apollo-server-caching';
import { logger } from '@cdm-logger/server';
import { config } from '../config';
import { ICounterService } from '../interfaces';
import { Counter } from '../generated-models';

const KEY = 'COUNTER';
export const setupCaching = ({
    counterService,
    cache,
}: {
    counterService: ICounterService;
    cache: KeyValueCache<string>;
}) => {
    const loader = new DataLoader<string, Counter>(
        (args) => {
            return (counterService.counterQuery() as Promise<Counter>).then((data) => [data]);
        },
        { batch: false },
    );
    const cachedCounterService: ICounterService = {} as ICounterService;
    cachedCounterService.counterQuery = async () => {
        // stores as file:///tmp/tmp.txt
        const key = KEY;
        const cacheDoc = await cache.get(key);

        if (cacheDoc) {
            logger.trace('  document pulled from cache, [%s]', JSON.stringify(cacheDoc));
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return JSON.parse(cacheDoc);
        }
        try {
            const doc = await loader.load(KEY);

            // https://github.com/apollographql/apollo-server/tree/master/packages/apollo-server-caching#apollo-server-caching
            await cache.set(key, JSON.stringify(doc), { ttl: config.FILES_TTL });
            return doc;
        } catch (e) {
            console.log('error: ', e);
            return null;
        }
    };
    // it does syncing of counter
    cachedCounterService.addCounter = async () => {
        cache.delete(KEY);
        const newCounter = await loader.load(KEY);
        await cache.set(KEY, JSON.stringify(newCounter), { ttl: config.FILES_TTL });
    };

    return cachedCounterService;
};

\`\`\`

## packages-modules/counter/server/src/dataloader/counter-dataloader.ts

\`\`\`ts
import { DataSource, DataSourceConfig } from 'apollo-datasource';
import { ApolloError } from 'apollo-server-errors';
import { InMemoryLRUCache } from 'apollo-server-caching';
// import { setupCaching } from './cache';
import { KeyValueCache } from 'apollo-server-caching';
import { IService, IContext, ICounterService } from '../interfaces';
import { setupCaching } from './cache';
import { Counter } from '../generated-models';

export interface CacheOptions {
    ttl?: number;
}

export class CounterDataSource extends DataSource<IService> implements ICounterService {
    private context!: IContext;

    private cacheCounterService: ICounterService;

    constructor() {
        super();
    }

    public counterQuery(): Counter | Promise<Counter> | PromiseLike<Counter> {
        return this.cacheCounterService.counterQuery();
    }

    public addCounter(amount?: number) {
        return this.cacheCounterService.addCounter();
    }

    public initialize(config: DataSourceConfig<IContext>) {
        this.context = config.context;
        if (!this.context.counterMockService) {
            throw new ApolloError('Missing TextFileService in the context!');
        }
        try {
            const cache = config.cache || new InMemoryLRUCache<string>();
            this.cacheCounterService = setupCaching({ counterService: config.context.counterMockService, cache });
        } catch (err) {
            throw new ApolloError(`Setting up cache in the FilesDataSource failed due to ${err}`);
        }
    }
}

\`\`\`

## packages-modules/counter/server/src/dataloader/index.ts

\`\`\`ts
export * from './counter-dataloader';

\`\`\`

## packages-modules/counter/server/src/generated-models.ts

\`\`\`ts
/* tslint:disable */

import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';

export type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    AnyObject: any;
    JSON: any;
    JSONObject: any;
    Date: any;
    Time: any;
    DateTime: any;
};

export type ClientCounter = {
    counter?: Maybe<Scalars['Int']>;
};

export type Counter = {
    amount: Scalars['Int'];
};

export type FieldError = {
    field: Scalars['String'];
    message: Scalars['String'];
};

export type Mutation = {
    dummy?: Maybe<Scalars['Int']>;
    addCounterState?: Maybe<ClientCounter>;
    addCounter?: Maybe<Counter>;
};

export type MutationAddCounterStateArgs = {
    amount: Scalars['Int'];
};

export type MutationAddCounterArgs = {
    amount?: Maybe<Scalars['Int']>;
};

export type Node = {
    id: Scalars['ID'];
};

export type Query = {
    dummy?: Maybe<Scalars['Int']>;
    counterState?: Maybe<ClientCounter>;
    counter?: Maybe<Counter>;
};

export type Subscription = {
    dummy?: Maybe<Scalars['Int']>;
    counterUpdated?: Maybe<Counter>;
};

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => Promise<TResult> | TResult;

export type StitchingResolver<TResult, TParent, TContext, TArgs> = {
    fragment: string;
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ResolverFn<TResult, TParent, TContext, TArgs>
    | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs>;
    resolve?: SubscriptionResolveFn<TResult, TParent, TContext, TArgs>;
}

export type SubscriptionResolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ((...args: any[]) => SubscriptionResolverObject<TResult, TParent, TContext, TArgs>)
    | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
    parent: TParent,
    context: TContext,
    info: GraphQLResolveInfo,
) => Maybe<TTypes>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
    next: NextResolverFn<TResult>,
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
    Query: {};
    Int: Scalars['Int'];
    ClientCounter: ClientCounter;
    Counter: Counter;
    Mutation: {};
    Subscription: {};
    String: Scalars['String'];
    Boolean: Scalars['Boolean'];
    AnyObject: Scalars['AnyObject'];
    JSON: Scalars['JSON'];
    JSONObject: Scalars['JSONObject'];
    FieldError: FieldError;
    Node: Node;
    ID: Scalars['ID'];
    Date: Scalars['Date'];
    Time: Scalars['Time'];
    DateTime: Scalars['DateTime'];
};

export interface AnyObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['AnyObject'], any> {
    name: 'AnyObject';
}

export type ClientCounterResolvers<ContextType = any, ParentType = ResolversTypes['ClientCounter']> = {
    counter?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
};

export type CounterResolvers<ContextType = any, ParentType = ResolversTypes['Counter']> = {
    amount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
};

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
    name: 'Date';
}

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
    name: 'DateTime';
}

export type FieldErrorResolvers<ContextType = any, ParentType = ResolversTypes['FieldError']> = {
    field?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
    name: 'JSON';
}

export interface JsonObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSONObject'], any> {
    name: 'JSONObject';
}

export type MutationResolvers<ContextType = any, ParentType = ResolversTypes['Mutation']> = {
    dummy?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    addCounterState?: Resolver<
        Maybe<ResolversTypes['ClientCounter']>,
        ParentType,
        ContextType,
        MutationAddCounterStateArgs
    >;
    addCounter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType, MutationAddCounterArgs>;
};

export type NodeResolvers<ContextType = any, ParentType = ResolversTypes['Node']> = {
    __resolveType: TypeResolveFn<null, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType = ResolversTypes['Query']> = {
    dummy?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    counterState?: Resolver<Maybe<ResolversTypes['ClientCounter']>, ParentType, ContextType>;
    counter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
};

export type SubscriptionResolvers<ContextType = any, ParentType = ResolversTypes['Subscription']> = {
    dummy?: SubscriptionResolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    counterUpdated?: SubscriptionResolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
};

export interface TimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Time'], any> {
    name: 'Time';
}

export type Resolvers<ContextType = any> = {
    AnyObject?: GraphQLScalarType;
    ClientCounter?: ClientCounterResolvers<ContextType>;
    Counter?: CounterResolvers<ContextType>;
    Date?: GraphQLScalarType;
    DateTime?: GraphQLScalarType;
    FieldError?: FieldErrorResolvers<ContextType>;
    JSON?: GraphQLScalarType;
    JSONObject?: GraphQLScalarType;
    Mutation?: MutationResolvers<ContextType>;
    Node?: NodeResolvers;
    Query?: QueryResolvers<ContextType>;
    Subscription?: SubscriptionResolvers<ContextType>;
    Time?: GraphQLScalarType;
};

/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
 */
export type IResolvers<ContextType = any> = Resolvers<ContextType>;

\`\`\`

## packages-modules/counter/server/src/graphqlTypes/index.ts

\`\`\`ts
// Components
import { Feature } from '@common-stack/server-core';
import createResolvers from './resolvers';

const graphqlFiles = (<any>require).context('', true, /\**.graphql?/);

const schema = graphqlFiles.keys().map((graphqlName) => {
    return graphqlFiles(graphqlName);
});

export default new Feature({ schema, createResolversFunc: createResolvers } as any);

\`\`\`

## packages-modules/counter/server/src/graphqlTypes/resolvers.ts

\`\`\`ts
/* eslint-disable no-unused-vars */
import { GraphQLDate, GraphQLTime, GraphQLDateTime } from 'graphql-iso-date';

export default (pubsub) => ({
    Date: GraphQLDate,
    Time: GraphQLTime,
    DateTime: GraphQLDateTime,
});

\`\`\`

## packages-modules/counter/server/src/index.ts

\`\`\`ts
import { Feature } from '@common-stack/server-core';
import counter from './module';

export { CounterMockMoleculerService } from './services';
export * from './constants';
export default new Feature(counter);

\`\`\`

## packages-modules/counter/server/src/interfaces/context.ts

\`\`\`ts
import { ICounterService } from './counter-service';

export interface IContext extends IService {
    dataSources: IDataSources;
}

export interface IDataSources {
    counterCache: ICounterService;
}
export interface IService {
    counterMockService: ICounterService;
    // counterMockProxyService?: ICounterService;
}

\`\`\`

## packages-modules/counter/server/src/interfaces/counter-service.ts

\`\`\`ts
import { Counter } from '../generated-models';

export interface ICounterService {
    counterQuery(): Counter | PromiseLike<Counter> | Promise<Counter>;

    addCounter(amount?: number): Promise<void> | void;
}

\`\`\`

## packages-modules/counter/server/src/interfaces/index.ts

\`\`\`ts
export * from './context';
export * from './counter-service';

\`\`\`

## packages-modules/counter/server/src/module.ts

\`\`\`ts
import { Feature } from '@common-stack/server-core';
import { interfaces } from 'inversify';
import schema from './schema/schema.graphql';
import { ICounterService, IService } from './interfaces';
import { resolver } from './resolvers';
import { localCounterModule, externalCounterModule } from './containers';
import { CounterMockMoleculerService } from './services';
import { TYPES } from './constants';
import { CounterDataSource } from './dataloader';

const counterServiceGen = (container: interfaces.Container): IService => {
    return {
        counterMockService: container.getNamed<ICounterService>(TYPES.CounterMockService, 'proxy'),
    };
};

const dataSources: (container: interfaces.Container) => any = () => {
    return {
        counterCache: new CounterDataSource(),
    };
};

export default new Feature({
    schema,
    createContainerFunc: [localCounterModule],
    createResolversFunc: resolver,
    createServiceFunc: counterServiceGen,
    // createContextFunc: () => ({ counterMock: counterMock }), // note anything set here should be singleton.
    createDataSourceFunc: dataSources,
    createHemeraContainerFunc: [externalCounterModule],
    addBrokerClientServiceClass: [CounterMockMoleculerService],
    addBrokerMainServiceClass: [],
});


\`\`\`

## packages-modules/counter/server/src/resolvers/index.ts

\`\`\`ts
export * from './resolver';

\`\`\`

## packages-modules/counter/server/src/resolvers/resolver.ts

\`\`\`ts
import { IContext } from '../interfaces';
import { IResolvers, Counter } from '../generated-models';

const COUNTER_SUBSCRIPTION = 'counter_subscription';

export const resolver: (options: any) => IResolvers<IContext> = (options) => ({
    Query: {
        counter(obj, args, context) {
            return context.counterMockService.counterQuery() as Counter;
        },
        counterCache(obj, args, context) {
            return context.dataSources.counterCache.counterQuery() as Counter;
        },
        moleculerCounter(obj, args, context) {
            return context.counterMockProxyService.counterQuery();
        },
    },
    Mutation: {
        async addCounter(obj, { amount }, context) {
            await context.counterMockService.addCounter(amount);
            const counter = await context.counterMockService.counterQuery();

            options.pubsub.publish(COUNTER_SUBSCRIPTION, {
                counterUpdated: { amount: counter.amount },
            });

            return counter;
        },
        async addMoleculerCounter(obj, { amount }, { counterMockProxyService }) {
            await counterMockProxyService.addCounter(amount);
            const counter = await counterMockProxyService.counterQuery();

            options.pubsub.publish(COUNTER_SUBSCRIPTION, {
                moleculerCounterUpdate: { amount: counter.amount },
            });

            return counter;
        },
        async syncCachedCounter(obj, args, context) {
            await context.dataSources.counterCache.addCounter();
            return true;
        },
    },
    Subscription: {
        counterUpdated: {
            subscribe: () => options.pubsub.asyncIterator(COUNTER_SUBSCRIPTION),
        },
        moleculerCounterUpdate: {
            subscribe: () => options.pubsub.asyncIterator(COUNTER_SUBSCRIPTION),
        },
    },
});

\`\`\`

## packages-modules/counter/server/src/services/counter-mock-microservice.ts

\`\`\`ts
import { ServiceBroker, ServiceSettingSchema, Service, Context } from 'moleculer';
import { injectable, inject, Container } from 'inversify';
import { ICounterService } from '../interfaces';
import { CounterCommands, NATS_MOLECULER_COUNTER_SERIVCE, TYPES } from '../constants';

/**
 * Exposes CounterMock services by registering to the Moleculer Broker.
 * Note: This class is not injectable.
 */
export class CounterMockMicroservice extends Service {
    private counterMock: ICounterService;

    constructor(broker: ServiceBroker, { container, ...settings }: { container: Container } & { subTopic: string }) {
        super(broker);

        const topic = NATS_MOLECULER_COUNTER_SERIVCE;
        this.counterMock = container.get<ICounterService>(TYPES.CounterMockService);
        this.parseServiceSchema({
            name: topic,
            actions: {
                [CounterCommands.ADD_COUNTER]: {
                    handler: async (ctx: Context<{ amount?: number }>) => {
                        return this.counterMock.addCounter(ctx.params.amount);
                    },
                },
                [CounterCommands.COUNTER_QUERY]: {
                    handler: async (ctx: Context) => {
                        return this.counterMock.counterQuery();
                    },
                },
            },
        });
    }
}

\`\`\`

## packages-modules/counter/server/src/services/counter-mock-moleculer-service.ts

\`\`\`ts
import { ServiceBroker, ServiceSettingSchema, Service, Context } from 'moleculer';
import { injectable, inject, Container } from 'inversify';
import { ICounterService } from '../interfaces';
import { CounterCommands, NATS_MOLECULER_COUNTER_SERIVCE, TYPES } from '../constants';

/**
 * Exposes CounterMock services by registering to the Moleculer Broker.
 * Note: This class is not injectable.
 */
export class CounterMockMoleculerService extends Service {
    private counterMock: ICounterService;

    constructor(broker: ServiceBroker, { container, settings }: { container: Container } & { settings: any }) {
        super(broker);
        const { subTopic } = settings;
        const topic = NATS_MOLECULER_COUNTER_SERIVCE;
        this.counterMock = container.get<ICounterService>(TYPES.CounterMockService);
        this.parseServiceSchema({
            name: topic,
            version: subTopic,
            actions: {
                [CounterCommands.ADD_COUNTER]: {
                    handler: async (ctx: Context<{ amount?: number }>) =>
                        this.counterMock.addCounter(ctx.params.amount),
                },
                [CounterCommands.COUNTER_QUERY]: {
                    handler: async (ctx: Context) => this.counterMock.counterQuery(),
                },
            },
        });
    }
}

\`\`\`

## packages-modules/counter/server/src/services/counter-mock-proxy-service.ts

\`\`\`ts
import { ServiceBroker, ServiceSettingSchema } from 'moleculer';
import { injectable, inject, tagged } from 'inversify';
import { TaggedType } from '@common-stack/core';
import { Counter } from '../generated-models';
import { ICounterService } from '../interfaces';
import { CounterCommands, NATS_MOLECULER_COUNTER_SERIVCE } from '../constants';

/**
 * Proxies all calls to CounterMock service through Moleculer Borker
 */
@injectable()
export class CounterMockProxyService implements ICounterService {
    constructor(
        @inject('MoleculerBroker')
        private broker: ServiceBroker,

        @inject('Settings')
        @tagged(TaggedType.MICROSERVICE, true)
        private settings: { subTopic: string },
    ) {}

    private topic = NATS_MOLECULER_COUNTER_SERIVCE;

    public counterQuery() {
        return this.broker.call<Counter>(this.fullActionName(CounterCommands.COUNTER_QUERY));
    }

    public addCounter(amount?: number) {
        return this.broker.call<void, any>(this.fullActionName(CounterCommands.ADD_COUNTER), { amount });
    }

    private fullActionName(subCommand: string) {
        return `${this.settings.subTopic}.${this.topic}.${subCommand}`;
    }
}

\`\`\`

## packages-modules/counter/server/src/services/counter-mock-service.ts

\`\`\`ts
import { injectable } from 'inversify';
import { ICounterService } from '../interfaces';

@injectable()
export class CounterMockService implements ICounterService {
    private amount: number;

    constructor() {
        this.amount = 0;
    }

    public counterQuery() {
        return {
            amount: this.amount,
        };
    }

    public addCounter(amount) {
        if (amount) {
            this.amount += amount;
        } else {
            this.amount++;
        }
    }
}

// to make this instance singleton.
const counterMock = new CounterMockService();

export { counterMock };

\`\`\`

## packages-modules/counter/server/src/services/index.ts

\`\`\`ts
export * from './counter-mock-service';
export * from './counter-mock-moleculer-service';
export * from './counter-mock-proxy-service';

\`\`\`

## packages-modules/counter/server/tsconfig.json

\`\`\`json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "../lib",
    "declarationDir": "lib"
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
\`\`\`

## packages-modules/counter/server/webpack.config.js

\`\`\`js
var nodeExternals = require('webpack-node-externals');
var webpack = require('webpack');
var path = require('path');

var webpackOpts = {
  mode: 'development',
  entry: {
    index: './src/index.ts',
  },
  target: 'node',
  output: {
    path: path.join(__dirname, 'lib'),
    filename: '[name].js',
    libraryTarget: "commonjs2",
  },
  resolve: {
    extensions: ['.ts', '.tsx', '.graphql', '.graphqls', '.gql']
  },
  plugins: [
    new webpack.LoaderOptionsPlugin({
      options: {
        test: /\.tsx?$/,
        ts: {
          compiler: 'typescript',
          configFile: 'tsconfig.json'
        },
        tslint: {
          emitErrors: true,
          failOnHint: true
        }
      }
    })
  ],
  devtool: 'source-map',
  module: {
    rules: [{
      test: /\.tsx?$/,
      loaders: 'ts-loader'
    },
    {
      test: /\.(gql)$/,
      exclude: /node_modules/,
      use: ['graphql-tag/loader']
    },
    {
      test: /\.graphql?/,
      exclude: /node_modules/,
      use: 'raw-loader',
    }
    ]
  },
  externals: [
    nodeExternals({ modulesDir: "../../../node_modules" }),
    nodeExternals()
  ]
};

module.exports = webpackOpts;

\`\`\`

## portable-devices/desktop/assets/preload.js

\`\`\`js
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
const _require = require('esm')(module);

process.once('loaded', () => {
    global.require = _require;
});

\`\`\`

## portable-devices/desktop/electron-webpack.json

\`\`\`json
{
  "title": "SampleDesktop",
  "renderer": {
    "dll": [],
    "webpackConfig": "webpack.renderer.additions.js"
  },
  "main": {
    "webpackConfig": "webpack.main.additions.js"
  },
  "whiteListedModules": [
    "antd",
    "react-redux",
    "react-fela",
    "react-helmet",
    "react-loadable",
    "react-router",
    "react-router-config",
    "react-router-dom",
    "react-transition-group"
  ]
}
\`\`\`

## portable-devices/desktop/jest.config.js

\`\`\`js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    name: packageJson.name,
    displayName: packageJson.name,
};
\`\`\`

## portable-devices/desktop/src/common/channel.ts

\`\`\`ts
export const CHANNELS = {
    CHECK_ACCESSIBILITY_FOR_MAC_OS: 'CHECK_ACCESSIBILITY_FOR_MAC_OS',
};

\`\`\`

## portable-devices/desktop/src/common/config/base-apollo-client.ts

\`\`\`ts
// version 09/18/2021
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
import { ApolloClient, ApolloClientOptions, ApolloLink } from '@apollo/client';
import { InMemoryCache } from '@apollo/client/cache';
import { HttpLink, createHttpLink } from '@apollo/client/link/http';
import { BatchHttpLink } from '@apollo/client/link/batch-http';
import { onError } from '@apollo/client/link/error';
import { WebSocketLink } from '@apollo/client/link/ws';
import { getOperationAST } from 'graphql';
import { invariant } from 'ts-invariant';
import { IClientState } from '@common-stack/client-core';
import fetch from 'node-fetch';
import { ConnectionParams } from 'subscriptions-transport-ws';
import { isBoolean, merge } from 'lodash';
import { CdmLogger } from '@cdm-logger/core';
import { RetryLink } from '@apollo/client/link/retry';

const schema = `

`;

interface IApolloClientParams {
    initialState?: any;
    scope: 'browser' | 'server' | 'native';
    getDataIdFromObject: (x?: any) => string;
    clientState: IClientState;
    isDebug: boolean;
    isDev: boolean;
    isSSR: boolean;
    httpGraphqlURL: string;
    httpLocalGraphqlURL: string;
    logger: CdmLogger.ILogger;
}

const errorLink = onError(({ graphQLErrors, networkError }) => {
    if (graphQLErrors) {
        graphQLErrors.map(({ message, locations, path }) =>
            // tslint:disable-next-line
            invariant.warn(`[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`),
        );
    }
    if (networkError) {
        // tslint:disable-next-line
        invariant.warn(`[Network error]: ${networkError}`);
    }
});

let _apolloClient: ApolloClient<any>;
let _memoryCache: InMemoryCache;
export const createApolloClient = ({
    scope,
    isDev,
    isDebug,
    isSSR,
    getDataIdFromObject,
    clientState,
    httpGraphqlURL,
    httpLocalGraphqlURL,
    initialState,
    logger,
}: IApolloClientParams) => {
    const isBrowser = scope === 'browser';
    const isServer = scope === 'server';
    let link;

    const cache = new InMemoryCache({
        dataIdFromObject: getDataIdFromObject,
        possibleTypes: clientState.possibleTypes,
    });

    const attemptConditions = async (count: number, operation: any, error: Error) => {
        const promises = (clientState.retryLinkAttemptFuncs || []).map((func) => func(count, operation, error));

        try {
            const result = await promises;
            return !!result.find((item) => item && isBoolean(item));
        } catch (e) {
            logger.trace('Error occured in retryLink Attempt condition', e);
            throw e;
        }
    };

    const retrylink = new RetryLink({
        attempts: attemptConditions,
    });

    if (_apolloClient && _memoryCache) {
        // return quickly if client is already created.
        return {
            apolloClient: _apolloClient,
            cache: _memoryCache,
        };
    }
    _memoryCache = cache;
    if (isBrowser) {
        const connectionParams = async () => {
            const param: ConnectionParams = {};
            for (const connectionParam of clientState.connectionParams) {
                merge(param, await connectionParam);
            }
            return param;
        };

        const wsLink = new WebSocketLink({
            uri: httpGraphqlURL.replace(/^http/, 'ws'),
            options: {
                reconnect: true,
                timeout: 20000,
                reconnectionAttempts: 10,
                lazy: true,
                connectionParams,
                connectionCallback: async (error, result) => {
                    if (error) {
                        logger.error(error, '[WS connectionCallback error] %j');
                    }
                    const promises = (clientState.connectionCallbackFuncs || []).map((func) =>
                        func(wsLink, error, result),
                    );
                    try {
                        await promises;
                    } catch (e) {
                        logger.trace('Error occured in connectionCallback condition', e);
                        throw e;
                    }
                },
            },
            inactivityTimeout: 10000,
        });

        link = ApolloLink.split(
            ({ query, operationName }) => {
                if (operationName.endsWith('_WS')) {
                    return true;
                }
                const operationAST = getOperationAST(query as any, operationName);
                return !!operationAST && operationAST.operation === 'subscription';
            },
            wsLink,
            new HttpLink({
                uri: httpGraphqlURL,
            }),
        );
    } else if (isServer) {
        link = new BatchHttpLink({ uri: httpLocalGraphqlURL, fetch: fetch as any });
    } else {
        link = createHttpLink({ uri: httpLocalGraphqlURL, fetch: fetch as any });
    }

    const links = [errorLink, retrylink, ...(clientState.preLinks || []), link];

    // Add apollo logger during development only
    if (isBrowser && (isDev || isDebug)) {
        const apolloLogger = require('apollo-link-logger');
        links.unshift(apolloLogger.default);
    }

    const params: ApolloClientOptions<any> = {
        queryDeduplication: true,
        typeDefs: schema.concat(<string>clientState.typeDefs),
        resolvers: clientState.resolvers as any,
        link: ApolloLink.from(links),
        cache,
        connectToDevTools: isBrowser && (isDev || isDebug),
    };
    if (isSSR) {
        if (isBrowser) {
            if (initialState) {
                cache.restore(initialState);
            }
            params.ssrForceFetchDelay = 100;
        } else if (isServer) {
            params.ssrMode = true;
        }
    }
    _apolloClient = new ApolloClient<any>(params);

    clientState?.defaults?.forEach((x) => {
        if (x.type === 'query') {
            cache.writeQuery(x);
        } else if (x.type === 'fragment') {
            cache.writeFragment(x);
        }
    });

    return { apolloClient: _apolloClient, cache };
};

\`\`\`

## portable-devices/desktop/src/common/config/base-redux-config.ts

\`\`\`ts
// version 11/12/2021
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable global-require */
/* eslint-disable no-underscore-dangle */
import {
    createStore,
    combineReducers,
    applyMiddleware,
    StoreEnhancer,
    Middleware,
    compose,
    Action,
    ReducersMapObject,
    PreloadedState,
} from 'redux';
import { EpicMiddleware, Epic } from 'redux-observable';
import { persistReducer, PersistConfig } from 'redux-persist';
// import thunkMiddleware from 'redux-thunk';

interface IReduxStore<S = any> {
    scope: 'browser' | 'server' | 'native' | 'ElectronMain';
    isDebug: boolean;
    isDev: boolean;
    reducers: ReducersMapObject<S>;
    rootEpic?: Epic<Action<S>, Action<any>, void, any>;
    epicMiddleware?: EpicMiddleware<Action<S>, Action<any>>;
    preMiddleware?: Middleware[];
    postMiddleware?: Middleware[];
    middleware?: Middleware[];
    initialState: PreloadedState<S>;
    persistConfig?: PersistConfig<S, any>;
}
/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = ({
    scope,
    isDebug,
    isDev,
    reducers,
    rootEpic,
    epicMiddleware,
    preMiddleware,
    postMiddleware,
    middleware,
    initialState = {},
    persistConfig,
}: IReduxStore<any>) => {
    const isBrowser = scope === 'browser';
    const isElectronMain = scope === 'ElectronMain';
    /**
     * Add middleware that required for this app.
     */

    const middlewares: Middleware[] = [];
    // add epicMiddleware
    if (epicMiddleware) {
        middlewares.push(epicMiddleware);
    }
    if (preMiddleware) {
        middlewares.unshift(...preMiddleware);
    }
    // Add redux logger during development only
    if ((isDev || isDebug) && isBrowser) {
        const { createLogger } = require('redux-logger');

        middlewares.push(
            createLogger({
                level: 'info',
                collapsed: true,
            }),
        );
    }

    if (middleware) {
        middlewares.push(...middleware);
    }

    if (postMiddleware) {
        middlewares.push(...postMiddleware);
    }

    const enhancers: () => StoreEnhancer<any>[] = () => [applyMiddleware(...middlewares)];

    const composeEnhancers: any =
        ((isDev || isDebug) && isBrowser && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) || compose;

    const rootReducer = combineReducers(reducers);
    const persistedReducer = persistConfig ? persistReducer(persistConfig, rootReducer) : rootReducer;

    const store = createStore(persistedReducer, initialState, composeEnhancers(...enhancers()));
    if (isBrowser || isElectronMain) {
        // no SSR for now
        if (epicMiddleware) {
            epicMiddleware.run(rootEpic);
        }
    }

    return store;
};

\`\`\`

## portable-devices/desktop/src/common/config/config.ts

\`\`\`ts
/// <reference path='../../../../../typings/index.d.ts' />
import * as envalid from 'envalid';

const { str, bool, json, num } = envalid;

export const config = envalid.cleanEnv(process.env, {
    NODE_ENV: str({ default: 'production', choices: ['production', 'staging', 'development', 'test'] }),
    ELECTRON_WEBPACK_WDS_PORT: num({ default: 3000 }),
    ELECTRON_WEBPACK_WDS_HOST: str({ default: 'localhost' }),
    // BACKEND_URL: str({ devDefault: __BACKEND_URL__ }),
    // GRAPHQL_URL: str({ devDefault: __GRAPHQL_URL__ }),
    CLIENT_URL: str({ default: 'http://localhost' }),
    NAMESPACE: str({ default: 'default' }),
    apolloLogging: bool({ default: false, devDefault: true }),
});

\`\`\`

## portable-devices/desktop/src/common/constants/index.ts

\`\`\`ts
export * from './ipcEvents';

\`\`\`

## portable-devices/desktop/src/common/constants/ipcEvents.ts

\`\`\`ts
const enum IPC_EVENTS {
    // MAIN
    SHOW_MAIN = 'SHOW_MAIN',
    // ABOUT
    SHOW_ABOUT = 'SHOW_ABOUT',

    // Tray
    HIDE_TRAY = 'HIDE_TRAY',
    SHOW_TRAY = 'SHOW_TRAY',
    SHOW_TRAY_WINDOWED = 'SHOW_TRAY_WINDOWED',
    TRAY_OPEN_ITEM = 'TRAY_OPEN_ITEM',
    TRAY_TOGGLE_AWLAYS_ON_TOP = 'TRAY_TOGGLE_AWLAYS_ON_TOP',
    TRAY_WINDOWED_MODE_CHANGED = 'TRAY_WINDOWED_MODE_CHANGED',
    TRAY_WINDOWED_ALWAYS_ON_TOP_CHANGED = 'TRAY_WINDOWED_ALWAYS_ON_TOP_CHANGED',
    TOGGLE_TRAY_WITH_BOUNDS = 'TOGGLE_TRAY_WITH_BOUNDS',
    TRAY_ICON_CREATED = 'TRAY_ICON_CREATED',
    TRAY_ICON_DESTROYED = 'TRAY_ICON_DESTROYED',
}

export { IPC_EVENTS };

\`\`\`

## portable-devices/desktop/src/common/index.ts

\`\`\`ts
export * from './channel';
export * from './utils';
export * from './constants';

\`\`\`

## portable-devices/desktop/src/common/utils/index.ts

\`\`\`ts
export * from './is';
export * from './logger';

\`\`\`

## portable-devices/desktop/src/common/utils/is.ts

\`\`\`ts
/* eslint-disable import/no-extraneous-dependencies */
import { osx, windows as _windows, main, renderer } from 'electron-is/is';

/**
 * Determine whether it is a mac platform
 */
export const isMacOS = osx();

/**
 * Determine whether it is windows
 */
export const isWindows = _windows();

export const isMain = main();

export const isRenderer = renderer();

export const isDev = process.env.NODE_ENV === 'development';

export const isTest = process.env.NODE_ENV === 'test';

\`\`\`

## portable-devices/desktop/src/common/utils/logger.ts

\`\`\`ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable @typescript-eslint/ban-types */
import { CdmLogger } from '@cdm-logger/core';
/**
 *  Create log proxy method
 * @param logLevel log level
 * @param mainLogger log object
 * @return {function}
 */
export const createLogProxy =
    (logLevel: string, mainLogger: CdmLogger.ILogger) =>
    (fn: Function) =>
    (...args: any) => {
        fn(...args);
        mainLogger[logLevel](...args);
    };

\`\`\`

## portable-devices/desktop/src/main/app/App.ts

\`\`\`ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-use-before-define */
import { inject } from 'inversify';
import { app, ipcMain, Menu } from 'electron';
import { windows } from 'electron-is';
import { logger, provideSingleton } from '../utils';
import { template } from '../menu-template';
import { Service } from './Service';
import { View } from './View';

@provideSingleton(App)
export class App {
    constructor() {
        app.whenReady().then(() => {
            this.services.init();

            this.views.init();

            logger.info('The app is initialized!');
        });

        app.on('window-all-closed', () => {
            if (windows()) {
                app.quit();
            }
        });
        app.on('activate', this.onActivate);

        app.on('before-quit', () => {
            this.beforeQuit();
            app.exit();
        });

        ipcMain.on('show-main-window-event', () => {
            app.dock.show();
        });

        Menu.setApplicationMenu(Menu.buildFromTemplate(template));
    }

    @inject(View)
    views!: View;

    @inject(Service)
    services!: Service;

    onActivate = () => {
        this.views.main.show();
        app.dock.show();
    };

    beforeQuit() {
        this.views.close();
    }
}

\`\`\`

## portable-devices/desktop/src/main/app/Service.ts

\`\`\`ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-use-before-define */
import { inject } from 'inversify';
import { ipcMain } from 'electron';
import { logAfter, logBefore, provideSingleton } from '../utils';
import { CHANNELS } from '../../common';
import { SystemService, UserService } from '../services';

@provideSingleton(Service)
export class Service {
    /** Service class * */

    @inject(UserService)
    user!: UserService;

    @inject(SystemService)
    system!: SystemService;

    /**
     * Handle the initialization of all services
     */
    @logBefore('[Service] Initialize service...')
    @logAfter('[Service] Initialization complete!')
    init() {
        // Service on the bridge
        // global.services = {
        //     user: this.user,
        //     system: this.system,
        // };

        // Check macOS permissions on the bridge
        ipcMain.handle(CHANNELS.CHECK_ACCESSIBILITY_FOR_MAC_OS, this.system.checkAccessibilityForMacOS);
    }
}

\`\`\`

## portable-devices/desktop/src/main/app/View.ts

\`\`\`ts
/* eslint-disable no-use-before-define */
import { inject } from 'inversify';
import { ElectronTypes } from '@common-stack/client-core';
import { MainWindow, TrayWindow, AboutWindow } from '../views';
import { logAfter, logBefore, provideSingleton } from '../utils';

@provideSingleton(View)
export class View {
    @inject(ElectronTypes.MainWindow)
    main!: MainWindow;

    @inject(ElectronTypes.AboutWindow)
    about!: AboutWindow;

    @inject(ElectronTypes.TrayWindow)
    tray!: TrayWindow;

    /**
     * Process all window initialization
     */
    @logBefore('[View] Initialization...')
    @logAfter('[View] Initialization complete!')
    init() {
        // Window on the bridge
        // global.windows = {
        //     home: this.home,
        //     tray: this.tray,
        //     about: this.about,
        // };
    }

    close() {
        this.main.close();
        this.about.close();
        this.tray.close();
    }
}

\`\`\`

## portable-devices/desktop/src/main/app/index.ts

\`\`\`ts
export { Service } from './Service';
export { App } from './App';
export { View } from './View';

\`\`\`

## portable-devices/desktop/src/main/bootstrap.ts

\`\`\`ts
import { app, protocol } from 'electron';
import { dev } from 'electron-is';

import { createLogProxy } from '../common';
import { getLogger } from './utils';
import { loadContainerAsync } from './ioc';
import { createClientContainer } from './config/client.service';
import { App } from './app';
import { createReduxStore } from './config/redux-electron-config';

/**
 * Operation before initialization
 */
const beforeInit = async () => {
    // Registration Agreement
    protocol.registerSchemesAsPrivileged([{ scheme: 'app', privileges: { secure: true, standard: true } }]);

    // control singleton
    const isSingle = app.requestSingleInstanceLock();
    if (!isSingle) {
        app.exit(0);
    }

    // Replace error logger
    if (!dev()) {
        console.error = createLogProxy('error', getLogger('error'))(console.error);
    }

    // Initialize the database part
    const baseContainer = await loadContainerAsync();
    return baseContainer;
};

/**
 * Start method
 */
export const bootstrap = async () => {
    const baseContainer = await beforeInit();
    const { container } = createClientContainer();
    container.parent = baseContainer;
    container.get(App);
    createReduxStore();
};

\`\`\`

## portable-devices/desktop/src/main/config/client.service.ts

\`\`\`ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ClientTypes } from '@common-stack/client-core';
import { interfaces } from 'inversify';
import { ApolloClient } from '@apollo/client';
import { CdmLogger } from '@cdm-logger/core';
import modules, { container, logger } from '../modules';
import { createApolloClient } from '../../common/config/base-apollo-client';
import { PUBLIC_SETTINGS } from '../../renderer/config/public-config';

let __CLIENT_SERVICE__: {
    apolloClient: ApolloClient<any>;
    container: interfaces.Container;
    services: any;
    logger: CdmLogger.ILogger;
};
export const createClientContainer = () => {
    if (__CLIENT_SERVICE__) {
        return __CLIENT_SERVICE__;
    }
    const clientState = modules.getStateParams({ resolverContex: () => modules.createService({}, {}) });
    const { cache, apolloClient } = createApolloClient({
        httpGraphqlURL: PUBLIC_SETTINGS.GRAPHQL_URL,
        httpLocalGraphqlURL: PUBLIC_SETTINGS.LOCAL_GRAPHQL_URL,
        isDev: process.env.NODE_ENV === 'development',
        isDebug: __DEBUGGING__,
        isSSR: __SSR__,
        scope: 'server',
        clientState,
        getDataIdFromObject: (result) => modules.getDataIdFromObject(result),
        initialState: null,
        logger,
    });
    // attaching the context to client as a workaround.
    container.bind(ClientTypes.ApolloClient).toConstantValue(apolloClient);
    container.bind(ClientTypes.InMemoryCache).toConstantValue(cache);
    const services = modules.createService({}, {});
    (apolloClient as any).container = services;

    __CLIENT_SERVICE__ = {
        container,
        apolloClient,
        services,
        logger,
    };
    return __CLIENT_SERVICE__;
};

\`\`\`

## portable-devices/desktop/src/main/config/epic-config.ts

\`\`\`ts
import { combineEpics, ofType } from 'redux-observable';
import { BehaviorSubject } from 'rxjs';
import { mergeMap, takeUntil } from 'rxjs/operators';
import modules from '../modules';

export const epic$ = new BehaviorSubject(combineEpics(...modules.epics));

// Since we're using mergeMap, by default any new
// epic that comes in will be merged into the previous
// one, unless an EPIC_END action is dispatched first,
// which would cause the old one(s) to be unsubscribed
export const rootEpic = (action$, ...rest) =>
    epic$.pipe<any>(mergeMap((epic) => epic(action$, ...rest).pipe(takeUntil(action$.pipe(ofType('EPIC_END'))))));

\`\`\`

## portable-devices/desktop/src/main/config/redux-electron-config.ts

\`\`\`ts
import { triggerAlias, replayActionMain, forwardToRenderer } from 'electron-redux';
import { createEpicMiddleware } from 'redux-observable';
import modules, { container } from '../modules';
import { createReduxStore as createBaseReduxStore } from '../../common/config/base-redux-config';
import { rootEpic } from './epic-config';
import { isDev } from '../../common';

export const epicMiddleware = createEpicMiddleware({
    dependencies: {
        routes: modules.getConfiguredRoutes(),
        container,
    },
});

/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = () => {
    const store = createBaseReduxStore({
        scope: 'ElectronMain',
        isDebug: __DEBUGGING__,
        isDev,
        initialState: {},
        epicMiddleware,
        rootEpic,
        middleware: [triggerAlias],
        postMiddleware: [forwardToRenderer],
        reducers: modules.reducers,
    });

    replayActionMain(store);
    return store;
};

\`\`\`

## portable-devices/desktop/src/main/index.ts

\`\`\`ts
import { bootstrap } from './bootstrap';

bootstrap().catch(console.error);

\`\`\`

## portable-devices/desktop/src/main/interfaces/index.ts

\`\`\`ts
export * from './tray-icon';
export * from './tray-window';

export const TYPES = {
    ITrayIcon: 'ITrayIcon',
    ITrayWindow: 'ITrayWindow',
};

\`\`\`

## portable-devices/desktop/src/main/interfaces/tray-icon.ts

\`\`\`ts
import { Tray } from 'electron';

export interface ITraceIcon {
    trayIcon: Tray;
    updateTitle(title: string): void;
}

\`\`\`

## portable-devices/desktop/src/main/interfaces/tray-window.ts

\`\`\`ts
import { BrowserWindow } from 'electron';

export interface ITrayWindow {
    window: BrowserWindow;
    init(): void;
}

\`\`\`

## portable-devices/desktop/src/main/ioc/index.ts

\`\`\`ts
import 'reflect-metadata';
import container, { asyncBindings } from './inversify.config';

export default container;

export const loadContainerAsync = async () => {
    await container.loadAsync(asyncBindings);
    return container;
};

\`\`\`

## portable-devices/desktop/src/main/ioc/inversify.config.ts

\`\`\`ts
import { AsyncContainerModule, Container } from 'inversify';
import { buildProviderModule } from 'inversify-binding-decorators';
import type { Repository } from 'typeorm';
import { User } from '../models';
import { getDBConnection, getRepository } from '../utils';
import TYPES from './types';

import './loader';
// container
const container = new Container();

container.load(buildProviderModule());

export default container;

/**
 * Load asynchronous objects
 */
export const asyncBindings = new AsyncContainerModule(async (bind) => {
    await getDBConnection();

    bind<Repository<User>>(TYPES.UserRepository)
        .toDynamicValue(() => getRepository(User))
        .inRequestScope();
});

\`\`\`

## portable-devices/desktop/src/main/ioc/loader.ts

\`\`\`ts
import '../app';
import '../services';
import '../views';
import '../utils/sqlite/connection';
import '../utils/AutoUpdater';

\`\`\`

## portable-devices/desktop/src/main/ioc/types.ts

\`\`\`ts
const TYPES = {
    UserRepository: Symbol.for('UserRepository'),
};

export default TYPES;

\`\`\`

## portable-devices/desktop/src/main/menu-template.ts

\`\`\`ts
import { format as formatUrl } from 'url';
import { app, shell, ipcMain } from 'electron';
import { IPC_EVENTS } from '../common';

export const template: Electron.MenuItemConstructorOptions[] = [
    {
        label: 'Edit',
        submenu: [
            { role: 'undo' },
            { role: 'redo' },
            { type: 'separator' },
            { role: 'cut' },
            { role: 'copy' },
            { role: 'paste' },
            { role: 'pasteAndMatchStyle' },
            { role: 'delete' },
            { role: 'selectAll' },
        ],
    },
    {
        label: 'View',
        submenu: [
            { role: 'reload' },
            { role: 'forceReload' },
            { role: 'toggleDevTools' },
            { type: 'separator' },
            { role: 'resetZoom' },
            { role: 'zoomIn' },
            { role: 'zoomOut' },
            { type: 'separator' },
            { role: 'togglefullscreen' },
        ],
    },
    { role: 'window', submenu: [{ role: 'minimize' }, { role: 'close' }] },
    {
        role: 'help',
        submenu: [
            {
                label: 'Learn More',
                click() {
                    require('electron').shell.openExternal('https://electron.atom.io');
                },
            },
            {
                label: 'about', role: 'about'
                // click() {
                //     ipcMain.emit(IPC_EVENTS.SHOW_ABOUT);
                // },
            },
        ],
    },
];

\`\`\`

## portable-devices/desktop/src/main/models/User.ts

\`\`\`ts
import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity('User')
export class User {
    @PrimaryGeneratedColumn()
    id?: number;

    @Column('text', { nullable: true })
    name?: string;

    @Column('text', { nullable: true })
    surname?: string;
}

\`\`\`

## portable-devices/desktop/src/main/models/index.ts

\`\`\`ts
export * from './User';

\`\`\`

## portable-devices/desktop/src/main/modules/index.ts

\`\`\`ts
import { ClientTypes } from '@common-stack/client-react';
import { interfaces } from 'inversify';
import modules from './module';
import parentContainer from '../ioc';
import { logger } from '../utils/logger';

class UtilityClass {
    // tslint:disable-next-line:no-shadowed-variable
    constructor(private modules) {}

    public getCacheKey(storeObj) {
        return this.modules.getDataIdFromObject(storeObj);
    }
}

const utility = new UtilityClass(modules);

// additional bindings to container
const container = modules.createContainers({}) as interfaces.Container;
container.bind(ClientTypes.Logger).toConstantValue(logger);
container.bind(ClientTypes.UtilityClass).toConstantValue(utility);
container.parent = parentContainer;

export default modules;
export { container, logger };

\`\`\`

## portable-devices/desktop/src/main/modules/module.ts

\`\`\`ts
import { Feature } from '@common-stack/client-react';
import ElectronMainModule from '@sample-stack/counter-module-electron';

const modules = new Feature(ElectronMainModule);

export default modules;

\`\`\`

## portable-devices/desktop/src/main/services/Logger.ts

\`\`\`ts
/* eslint-disable @typescript-eslint/ban-types */
import { arch, cpus, platform, release, totalmem } from 'os';
import osName from 'os-name';
import { app } from 'electron';
import { isDev } from '../../common';
import { logger, getLogger } from '../utils';

interface LogInfo {
    level: any;
    message: string;
    key: any;
}

interface WithLogParams {
    before?: LogInfo | Function;
    after?: LogInfo | Function;
}

export class Logger {
    /**
     * Record system log
     */
    static logSystemInfo = () => {
        if (isDev) return;
        logger.divider();
        logger.info('Start the app...');

        logger.info(`Operating system: ${platform()} ${release()}(${arch()}`);
        logger.info(`System version: ${osName()}`);
        logger.info(`Processor: ${cpus().length} core`);
        logger.info(`Total memory: ${(totalmem() / 1024 / 1024 / 1024).toFixed(0)}G`);
        logger.info(`installation path: ${app.getAppPath()}`);
        logger.divider();
    };

    /**
     * Bring the log section to the subject
     * @param before
     * @param after
     */
    static withLog =
        ({ before, after }: WithLogParams) =>
        (func: Function) => {
            if (before) {
                if (typeof before === 'function') {
                    before();
                } else {
                    const logger = getLogger(before.key);
                    logger[before.level](before.message);
                }
            }

            func();

            if (after) {
                if (typeof after === 'function') {
                    after();
                } else {
                    const logger = getLogger(after.key);
                    logger[after.level](after.message);
                }
            }
        };
}

\`\`\`

## portable-devices/desktop/src/main/services/System.ts

\`\`\`ts
/* eslint-disable class-methods-use-this */
/* eslint-disable no-use-before-define */
import { systemPreferences } from 'electron';
import { provideSingleton } from '../utils';
import { isMacOS } from '../../common';

@provideSingleton(SystemService)
export class SystemService {
    /**
     * Check availability
     */
    checkAccessibilityForMacOS() {
        if (!isMacOS) return;
        return systemPreferences.isTrustedAccessibilityClient(true);
    }
}

\`\`\`

## portable-devices/desktop/src/main/services/User.ts

\`\`\`ts
/* eslint-disable no-use-before-define */
import { provide } from 'inversify-binding-decorators';
import { inject } from 'inversify';
import { Repository } from 'typeorm';

import { User } from '../models';
import TYPES from '../ioc/types';

@provide(UserService)
export class UserService {
    @inject(TYPES.UserRepository) private model!: Repository<User>;

    /**
     * Create an object
     * @param name
     * @param surname
     */
    public insert(name: string, surname: string): Promise<User> {
        return this.model.save({ name, surname });
    }

    public async finAll(): Promise<User[]> {
        return this.model.find();
    }
}

\`\`\`

## portable-devices/desktop/src/main/services/index.ts

\`\`\`ts
export { UserService } from './User';
export { SystemService } from './System';
export { Logger } from './Logger';

\`\`\`

## portable-devices/desktop/src/main/utils/AutoUpdater.ts

\`\`\`ts
/* eslint-disable no-use-before-define */
import { autoUpdater } from 'electron-updater';
import { provide } from 'inversify-binding-decorators';

@provide(AppUpdater)
export class AppUpdater {
    constructor() {
        autoUpdater.checkForUpdatesAndNotify();
    }
}

\`\`\`

## portable-devices/desktop/src/main/utils/createProtocol.ts

\`\`\`ts
import { protocol } from 'electron';
import { URL } from 'url';
import * as path from 'path';

export default (scheme: string) => {
    protocol.registerFileProtocol(scheme, (request, respond) => {
        let pathName = new URL(request.url).pathname;
        pathName = decodeURI(pathName); // Needed in case URL contains spaces

        const filePath = path.join(__dirname, pathName);
        respond({ path: filePath });
    });
};

\`\`\`

## portable-devices/desktop/src/main/utils/index.ts

\`\`\`ts
export * from './logger';
export * from './window';
export * from './ioc';
export * from './sqlite/connection';

export * from './AutoUpdater';

\`\`\`

## portable-devices/desktop/src/main/utils/ioc.ts

\`\`\`ts
import { fluentProvide } from 'inversify-binding-decorators';

export const provideSingleton = (identifier: any) => fluentProvide(identifier).inSingletonScope().done();

\`\`\`

## portable-devices/desktop/src/main/utils/logger/customLogger.ts

\`\`\`ts
import { getLogger as createLogger } from '@cdm-logger/electron';
import { ConsoleLogger } from '@cdm-logger/server';
import { isDev } from '../../../common';

const logger = isDev ? ConsoleLogger.create('main') : createLogger('log');
logger.divider = (str = '-', length = 10) => {
    let line = '';
    for (let i = 0; i < length; i += 1) {
        line += str;
    }
    logger.info(line);
};
export { logger };
export const getLogger = (name) => logger.child({ className: name });

\`\`\`

## portable-devices/desktop/src/main/utils/logger/index.ts

\`\`\`ts
export * from './customLogger';
export * from './logDecorator';

\`\`\`

## portable-devices/desktop/src/main/utils/logger/logDecorator.ts

\`\`\`ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/ban-types */
import { CdmLogger } from '@cdm-logger/core';
import { logger } from './customLogger';

interface LogParams {
    message: string;
    scope: any;
    level: CdmLogger.LoggerLevel;
}

const log = (propertyName: string, params: string | LogParams) => {
    // If it is plain text, output directly
    if (typeof params === 'string') {
        logger.info(`(${propertyName}) ${params}`);
    } else {
        // If it is an object, three parameters must be passed in and then output
        const { level, message, scope } = params;
        logger[`${level}`](`(${scope || propertyName}) ${message}`);
    }
};

/**
 * Call log before execution
 */
export const logBefore =
    (params: string | LogParams) => (target: Object, propertyName: string, descriptor: PropertyDescriptor) => {
        const method = descriptor.value;
        // Require, in order to work with decorator
        // eslint-disable-next-line func-names,no-param-reassign
        descriptor.value = function (...args: any[]) {
            log('main', params);
            return method.apply(this, args);
        };
    };

/**
 * Call log after execution
 * @param params
 */
export const logAfter =
    (params: string | LogParams) => (target: Object, propertyName: string, descriptor: PropertyDescriptor) => {
        const method = descriptor.value;
        // Require, in order to work with decorator
        // eslint-disable-next-line func-names,no-param-reassign
        descriptor.value = function (...args: any[]) {
            try {
                return method.apply(this, args);
            } finally {
                log('main', params);
            }
        };
    };

\`\`\`

## portable-devices/desktop/src/main/utils/sqlite/connection.ts

\`\`\`ts
import { app } from 'electron';
import type { ConnectionOptions, EntityTarget } from 'typeorm';
import { createConnection, getConnection } from 'typeorm';
import path from 'path';
import { User } from '../../models';
import { getLogger } from '../logger';
import { isDev, isTest } from '../../../common';

const entities = [User];
// Database storage address
const storagePath = app.getPath('userData');

const connectConfig: ConnectionOptions = {
    type: 'sqlite',
    entities,
    database:
        // In-memory database under test
        /* istanbul ignore next */
        isTest ? ':memory:' : path.join(storagePath, 'database', `${isDev ? 'electron-template' : 'db'}.sqlite`),
};

/**
 * Get database link
 */
export const getDBConnection = async () => {
    const logger = getLogger('database');
    try {
        logger.info('Connect to the database...');
        const connection = await createConnection(connectConfig);
        logger.info('connection succeeded!');

        // A synchronization of the database is equivalent to initializing various tables
        // Otherwise it will report QueryFailedError: SQLITE_ERROR: no such table: User error
        await connection.synchronize();

        return connection;
    } catch (err) {
        logger.error('Database initialization failed, error message:');
        logger.error(err);
        return undefined;
    }
};

/**
 * Get a certain warehouse value
 * @param entity
 */
export function getRepository<T>(entity: EntityTarget<T>) {
    const conn = getConnection();
    return conn.getRepository(entity);
}

\`\`\`

## portable-devices/desktop/src/main/utils/window/devTools.ts

\`\`\`ts
/* eslint-disable global-require */
/* eslint-disable import/no-extraneous-dependencies */
import { app } from 'electron';
import { dev } from 'electron-is';
import { logger } from '../logger';

/**
 * Load plug-in and developer tool window
 */
export const loadDevTools = () => {
    if (!(dev() || process.env.DEBUG === '1')) return;

    app.whenReady().then(() => {
        const {
            default: installExtension,

            // React Dev tools cannot be repaired temporarily (Electron version >= 9.0)
            // https://github.com/electron/electron/issues/23662
            // REACT_DEVELOPER_TOOLS
            REDUX_DEVTOOLS,
        } = require('electron-devtools-installer');

        const extensions = [
            // REACT_DEVELOPER_TOOLS,
            REDUX_DEVTOOLS,
        ];

        try {
            installExtension(extensions).then((name: string) => {
                logger.trace(`Added Extension: ${name}`);
            });
        } catch (e) {
            logger.error('An error occurred: ', e);
        }
    });
};

\`\`\`

## portable-devices/desktop/src/main/utils/window/index.ts

\`\`\`ts
/* eslint-disable import/no-extraneous-dependencies */
import { BrowserWindow, BrowserWindowConstructorOptions } from 'electron';
import { merge } from 'lodash';
import { loadDevTools } from './devTools';
import { loadUrl } from './protocol';

export interface WindowOpts extends BrowserWindowConstructorOptions {
    /**
     * URL
     */
    name: string;
    title?: string;
    show?: boolean;
    width?: number;
    height?: number;
    devTools?: boolean;
    /**
     * Allow renderer to use remote module
     */
    remote?: boolean;
}

/**
 * Method of constructing BrowserWindows object
 * @param opts { WindowOpts }
 */
export const createWindow = (opts: WindowOpts) => {
    const { name, title, width, height, devTools, remote, show = false } = opts;
    const windows = new BrowserWindow(
        merge(
            {},
            {
                show,
                width,
                height,
                title,
                webPreferences: {
                    nodeIntegration: true,
                    enableRemoteModule: remote,
                    // Context isolation environment
                    // https://www.electronjs.org/docs/tutorial/context-isolation
                    contextIsolation: false,
                    // devTools: isDev,
                },
            },
            opts,
        ),
    );

    loadUrl(windows, name);

    loadDevTools();

    // Show devtools and open it
    if (devTools) {
        windows.webContents.openDevTools();
    }
    return windows;
};

\`\`\`

## portable-devices/desktop/src/main/utils/window/protocol.ts

\`\`\`ts
/* eslint-disable import/no-extraneous-dependencies */
import { protocol, BrowserWindow } from 'electron';
import { dev } from 'electron-is';
import { format as formatUrl } from 'url';
import createProtocol from '../createProtocol';
import { config } from '../../../common/config/config';

protocol.registerSchemesAsPrivileged([{ scheme: 'app', privileges: { secure: true, standard: true } }]);

/**
 * Load address path
 * @param windows window
 * @param name path name in renderer
 */
export const loadUrl = (windows: BrowserWindow, name: string) => {
    if (dev()) {
        const htmlDevPath = formatUrl({
            protocol: 'http',
            slashes: true,
            hostname: config.ELECTRON_WEBPACK_WDS_HOST,
            port: config.ELECTRON_WEBPACK_WDS_PORT,
            pathname: `${name}.html`,
        });
        windows.loadURL(htmlDevPath);
    } else {
        createProtocol('app');
        windows.loadURL(`app://./${name}.html`);
    }
};

\`\`\`

## portable-devices/desktop/src/main/views/about.ts

\`\`\`ts
/* eslint-disable no-use-before-define */
import { provide } from 'inversify-binding-decorators';
import { BrowserWindow, ipcMain } from 'electron';
import Positioner from 'electron-positioner';
import { ElectronTypes } from '@common-stack/client-core';
import { createWindow } from '../utils';
import { IPC_EVENTS } from '../../common';

@provide(ElectronTypes.AboutWindow)
export class AboutWindow {
    private window: BrowserWindow;

    constructor() {
        this.window = createWindow({ name: 'about-page', height: 250, width: 300, remote: true });
        // Object BrowserWindow has a lot of standart events
        // We will hide Tray window on blur. To emulate standart behavior of the tray-like apps.
        this.window.on('blur', () => {
            this.window.hide();
        });

        // On show - we should display About Window in the center of the screen.
        this.window.on('show', () => {
            const positioner = new Positioner(this.window);
            (positioner as any).move('center');
        });

        ipcMain.on(IPC_EVENTS.SHOW_ABOUT, () => {
            this.window.show();
        });
    }

    show() {
        this.window.show();
    }

    close() {
        this.window.close();
        this.window = null;
    }
}

\`\`\`

## portable-devices/desktop/src/main/views/index.ts

\`\`\`ts
export { MainWindow } from './main';
export { AboutWindow } from './about';
export { TrayWindow } from './tray';

\`\`\`

## portable-devices/desktop/src/main/views/main.ts

\`\`\`ts
/* eslint-disable no-use-before-define */
import { BrowserWindow, ipcMain } from 'electron';
import { ElectronTypes } from '@common-stack/client-core';
import * as path from 'path';
import { createWindow, provideSingleton } from '../utils';
import { IPC_EVENTS } from '../../common';

@provideSingleton(ElectronTypes.MainWindow)
export class MainWindow {
    private window: BrowserWindow;

    constructor() {
        this.startWindow();
    }

    private startWindow() {
        this.window = createWindow({
            name: 'main-page',
            show: true,
            remote: true,
            webPreferences: {
                nodeIntegration: true,
                webSecurity: false,
                enableRemoteModule: true,
                // add preload to load esm
                preload: path.resolve(path.join(__dirname, 'preload.js')),
            },
        });
        this.window.on('close', (event) => {
            (event as any).sender.hide();
            event.preventDefault(); // prevent quit process
        });
        // Custom events MAIN WINDOW
        ipcMain.on(IPC_EVENTS.SHOW_MAIN, function () {
            if (this.window) {
                this.window.show();
            }
        });
    }

    show() {
        this.window.show();
    }

    close() {
        this.window.close();
        this.window = null;
    }
}

\`\`\`

## portable-devices/desktop/src/main/views/tray.ts

\`\`\`ts
/* eslint-disable no-unused-expressions */
/* eslint-disable no-use-before-define */
import { BrowserWindow, ipcMain, Tray } from 'electron';
import { ElectronTypes } from '@common-stack/client-core';
import * as path from 'path';
import { createWindow, provideSingleton } from '../utils';
import { isDev } from '../../common';

import { IPC_EVENTS } from '../../common';

const iconPath = path.join(__dirname, './icons/16x16.png');

@provideSingleton(ElectronTypes.TrayWindow)
export class TrayWindow {
    private window: BrowserWindow;

    private trayIcon: Tray;

    constructor() {
        this.window = createWindow({
            show: false,
            name: 'tray-page',
            remote: true,
            height: 500,
            width: 500,
            backgroundColor: '#E4ECEF',
            frame: false,
            fullscreenable: false,
            resizable: !isDev,
            transparent: true,
            webPreferences: {
                nodeIntegration: true,
                webSecurity: false,
                enableRemoteModule: true,
                // add preload to load esm
                preload: path.resolve(path.join(__dirname, 'preload.js')),
                devTools: true,
            },
        });
        // Object BrowserWindow has a lot of standart events
        // We will hide Tray window on blur. To emulate standart behavior of the tray-like apps.
        this.window.on('blur', () => {
            this.window.hide();
        });

        this.trayIcon = new Tray(iconPath);
        this.trayIcon.setToolTip('Sample Desktop'); // This tooltip will show up, when user hovers over our tray-icon.

        // By clicking on the icon we have to show TrayWindow and position it in the middle under
        // the tray icon (initially this window is hidden).
        this.trayIcon.on('click', this.toggleWidow);
        // ipcMain.on(WB_HIDE_TRAY, this.ipcHideTray);
        // ipcMain.on(WB_SHOW_TRAY, this.ipcShowTray);
    }

    private toggleWidow = (e, bounds) => {
        this.window.isVisible() ? this.window.hide() : this.showWindow();
    };

    // Since we want the window to be shown under our icon, we need to get the position of the icon and then set the position of the window to be right under it. To achieve this, we create a getWindowPosition() method:
    private getWindowPosition = () => {
        const windowBounds = this.window.getBounds();
        const trayBounds = this.trayIcon.getBounds();

        // Center window horizontally below the tray icon
        const x = Math.round(trayBounds.x + trayBounds.width / 2 - windowBounds.width / 2);
        // Position window 4 pixels vertically below the tray icon
        const y = Math.round(trayBounds.y + trayBounds.height + 4);
        return { x, y };
    };

    // This is a simple show / hide method. We’re using a one-line if statement; if the window is visible, hide it. If not, show it. The isVisible() method comes from Electron. Here is our showWindow() method:
    private showWindow = () => {
        const position = this.getWindowPosition();
        this.window.setPosition(position.x, position.y, false);
        this.window.show();
    };

    show() {
        this.window.show();
    }

    close() {
        this.window.close();
        this.window = null;
    }

    public updateTitle(title: string) {
        this.trayIcon.setTitle(title);
    }
}

\`\`\`

## portable-devices/desktop/src/renderer/about.tsx

\`\`\`tsx
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import './config/public-config';
import About from './app/About';
import 'antd/dist/antd.css';

// Virtual (module as any), generated in-memory by zenjs, contains count of backend rebuilds
// tslint:disable-next-line
// import 'backend_reload';

const rootEl = document.getElementById('app');
let frontendReloadCount = 0;

const renderApp = ({ key }: { key: number }) => ReactDOM.render(<About key={key} />, rootEl);
renderApp({ key: frontendReloadCount });
if (__DEV__) {
    if ((module as any).hot) {
        (module as any).hot.accept();
        // (module as any).hot.accept('backend_reload', () => {
        //     // log.debug('Reloading front-end');
        //     // when the backend restarts wait for 5 seconds
        //     setTimeout(() => window.location.reload(), 5000);
        //     // window.location.reload();
        // });
        (module as any).hot.accept((err) => {
            if (err) {
                console.error('Cannot apply HMR update.', err);
            }
        });
        //  React-hot-loader v4 doesn't require following code any more.
        //  but if RHL not working we can uncomment below code to make normal HMR to refresh the page
        (module as any).hot.accept('./app/About', () => {
            try {
                console.log('Updating front-end');
                frontendReloadCount = (frontendReloadCount || 0) + 1;

        renderApp({ key: frontendReloadCount });
      } catch (err) {
        // log(err.stack);
      }
    });
  }
}

\`\`\`

## portable-devices/desktop/src/renderer/app/500.tsx

\`\`\`tsx
import * as React from 'react';

export const Error500 = ({ error }: any) => {
    React.useEffect(() => {
        console.trace(error);
    }, [error]);

    return (
        <div>ERROR</div>
    );
}
\`\`\`

## portable-devices/desktop/src/renderer/app/About.tsx

\`\`\`tsx
import React, { Component } from 'react'

const pJson = require('../../../package.json');
const timeTrackerIcon = require('../../../assets/icon.png');

export default class About extends Component {

  render() {
    return (
      <div className='window'>
        <div className='mt-45 text-center' style={{ width: 500 }}>
          <img src={timeTrackerIcon} style={{ width: 64 }} />
          <div className='version'>Version {pJson.version}</div>
          <div>copyright &copy; cqb325@163.com</div>
        </div>
      </div>
    )
  }
}

\`\`\`

## portable-devices/desktop/src/renderer/app/ErrorBoundary.tsx

\`\`\`tsx
import * as React from 'react';
import { Error500 } from './500';
import { ServerError } from './ServerError';

type IErrorBoundryState = { error: any; type: string };

export class ErrorBoundary extends React.Component<any, IErrorBoundryState> {
    constructor(props) {
        super(props);
        const serverError: any = __CLIENT__ ? window.__SERVER_ERROR__ : null;
        if (serverError) {
            this.state = { error: new ServerError(serverError), type: 'serverError' };
        } else {
            this.state = { error: undefined, type: undefined };
        }
    }

    componentDidCatch(error) {
        let type;

        if (process.env.NODE_ENV === 'production') {
            type = '404';
        } else {
            type = '500';
        }
        // Update state so the next render will show the fallback UI.
        this.setState({ error, type });
    }

    render() {
        const { error, type } = this.state;
        if (error) {
            return <Error500 error={error} />;
        }
        return this.props.children;
    }
}

\`\`\`

## portable-devices/desktop/src/renderer/app/Main.tsx

\`\`\`tsx
import { hot } from 'react-hot-loader/root';
import * as React from 'react';
import { RendererProvider } from 'react-fela';
import { ApolloProvider } from '@apollo/client';
import { Provider } from 'react-redux';
import { rehydrate } from 'fela-dom';
import { PluginArea } from '@common-stack/client-react';
import { ConnectedRouter } from 'connected-react-router';
import { PersistGate } from 'redux-persist/integration/react';
import { persistStore } from 'redux-persist';
import createRenderer from '../config/main/fela-renderer';
import { createReduxStore } from '../config/main/redux-config';
import { createClientContainer } from '../config/main/client.service';
import modules, { MainRoute } from '../modules/main';
import { ErrorBoundary } from './ErrorBoundary';

const { apolloClient: client } = createClientContainer();

const { store, history } = createReduxStore();
export class Main extends React.Component<{}, {}> {
    render() {
        const renderer = createRenderer();
        const persistor = persistStore(store);
        rehydrate(renderer);
        return (
            <ErrorBoundary>
                <Provider store={store}>
                    <ApolloProvider client={client}>
                        <RendererProvider renderer={renderer}>
                            <PersistGate persistor={persistor}>
                                <PluginArea />
                                {modules.getWrappedRoot(
                                    <ConnectedRouter history={history}>
                                        <MainRoute />
                                    </ConnectedRouter>,
                                )}
                            </PersistGate>
                        </RendererProvider>
                    </ApolloProvider>
                </Provider>
            </ErrorBoundary>
        );
    }
}

export default hot(Main);

\`\`\`

## portable-devices/desktop/src/renderer/app/ServerError.tsx

\`\`\`tsx
class ServerError extends Error {
    constructor(error: any) {
        super();
        for (const key of Object.getOwnPropertyNames(error)) {
            this[key] = error[key];
        }
        this.name = 'ServerError';
    }
}

export { ServerError };

\`\`\`

## portable-devices/desktop/src/renderer/app/Tray.tsx

\`\`\`tsx
import { hot } from 'react-hot-loader/root';
import * as React from 'react';
import { RendererProvider } from 'react-fela';
import { ApolloProvider } from '@apollo/client';
import { Provider } from 'react-redux';
import { rehydrate } from 'fela-dom';
import createRenderer from '../config/tray/fela-renderer';
import { createClientContainer } from '../config/main/client.service';
import { epic$ } from '../config/tray/epic-config';
import { ConnectedRouter } from 'connected-react-router';
import { createReduxStore, history } from '../config/tray/redux-config';
import { MainRoute } from '../modules/tray';
import { ErrorBoundary } from './ErrorBoundary';

const { apolloClient: client, container } = createClientContainer();

let store;
if ((module as any).hot && (module as any).hot.data && (module as any).hot.data.store) {
    // console.log('Restoring Redux store:', JSON.stringify((module as any).hot.data.store.getState()));
    store = (module as any).hot.data.store;
    // replace the reducers always as we don't have ablity to find
    // new reducer added through our `modules`
    // store.replaceReducer(storeReducer((module as any).hot.data.history || history));
} else {
    store = createReduxStore();
}
if ((module as any).hot) {
    (module as any).hot.dispose((data) => {
        // console.log("Saving Redux store:", JSON.stringify(store.getState()));
        data.store = store;
        data.history = history;
        // Force Apollo to fetch the latest data from the server
        delete window.__APOLLO_STATE__;
    });
    (module as any).hot.accept('../config/tray/epic-config', () => {
        // we may need to reload epic always as we don't
        // know whether it is updated using our `modules`
        const nextRootEpic = require('../config/tray/epic-config').rootEpic;
        // First kill any running epics
        store.dispatch({ type: 'EPIC_END' });
        // Now setup the new one
        epic$.next(nextRootEpic);
    });
}
export class Main extends React.Component<{}, {}> {
    public render() {
        const renderer = createRenderer();
        rehydrate(renderer);
        return (
            <ErrorBoundary>
                <Provider store={store}>
                    <ApolloProvider client={client}>
                        <RendererProvider renderer={renderer}>
                            <ConnectedRouter history={history}>
                                <MainRoute />
                            </ConnectedRouter>,
                        </RendererProvider>
                    </ApolloProvider>
                </Provider>
            </ErrorBoundary>
        );
    }
}

export default hot(Main);

\`\`\`

## portable-devices/desktop/src/renderer/components/WindowHeader.tsx

\`\`\`tsx
import * as React from 'react';

export class WindowHeader extends React.Component {
  handleWindowClose = () => {
    if (this.props.close) {
      remote.app.dock.hide();
      remote.getCurrentWindow().hide();
    }
    return false;
  }
  handleWindowMinimize = () => {
    if (this.props.minimize) {
      remote.getCurrentWindow().minimize();
    }
    return false;
  }
  handleWindowToggleMaximize = () => {
    if (this.props.maximize) {
      if (remote.getCurrentWindow().isMaximized()) {
        remote.getCurrentWindow().unmaximize();
      } else {
        remote.getCurrentWindow().maximize();
      }
    }
    return false;
  }

  render() {
    return (
      <div className='window-header' onDoubleClick={ this.handleWindowToggleMaximize }>
        <div className='window-header-controls'>
          <div className={`btn ${this.props.close    ? 'close'    : 'disabled' }`} onClick={ this.handleWindowClose } />
          <div className={`btn ${this.props.minimize ? 'minimize' : 'disabled' }`} onClick={ this.handleWindowMinimize } />
          <div className={`btn ${this.props.maximize ? 'maximize' : 'disabled' }`} onClick={ this.handleWindowToggleMaximize } />
        </div>

        <div className='window-header-title'>{this.props.title}</div>
      </div>
    );
  }
};

\`\`\`

## portable-devices/desktop/src/renderer/components/layout/components/SideMenu.tsx

\`\`\`tsx
import * as H from 'history';
import * as React from 'react';
import { Link } from 'react-router-dom';
import * as PropTypes from 'prop-types';
import pathToRegexp from 'path-to-regexp';
import { Layout, Menu, Avatar } from 'antd';
import { IMenuPosition } from '@common-stack/client-react';

const { Sider } = Layout;
const { SubMenu } = Menu;

export function urlToList(url) {
    const urllist = url.split('/').filter((i) => i);
    return urllist.map((urlItem, index) => {
        return `/${urllist.slice(0, index + 1).join('/')}`;
    });
}

const getImageUrl = (picture) => {
    return picture || "data:image/png;base64,${new Identicon(Base64.encode('myawsomestringbebe'), 420).toString()}";
};

/**
 * Recursively flatten  the data
 * [{path: string}, {path: string}] => {path, path2}
 * @param menu
 */
export const getFlatMenuKeys = (menu) =>
    menu.reduce((keys, item) => {
        keys.push(item.path);
        if (item.children) {
            return keys.concat(getFlatMenuKeys(item.children));
        }
        return keys;
    }, []);

/**
 * Find all matched menu keys based on paths
 * @param flatMenuKeys: [/abc, /abc/:id, /abc/:id/info]
 * @param paths: [/abc/ /abc/11, /abc/11/info]
 */
export const getMenuMatchKeys = (flatMenuKeys, paths) =>
    paths.reduce(
        (matchKeys, path) => matchKeys.concat(flatMenuKeys.filter((item) => pathToRegexp(item).test(path))),
        [],
    );

export namespace ISiderMenu {
    export interface CompProps {
        menuData: any;
        segments: any;
        onCollapse?: any;
        state?: boolean;
        isMobile?: boolean;
        renderer?: any;
        Authorized?: any;
        collapsed?: boolean;
        logo?: any;
        user?: any;
        styles?: {
            grow?: any;
            logo?: any;
            sider?: any;
            icon?: any;
        };
    }

    export interface StateProps {
        location: H.Location;
    }

    export interface CompState {
        openKeys?: any;
    }

    export type Props = CompProps & StateProps;
    export type State = CompState;
}
export class SiderMenu extends React.PureComponent<ISiderMenu.Props, ISiderMenu.State> {
    private menus;

    private flatMenuKeys;

    constructor(props) {
        super(props);
        this.menus = props.menuData;
        this.flatMenuKeys = getFlatMenuKeys(props.menuData);
        this.state = {
            openKeys: this.getDefaultCollapsedSubMenus(props),
        };
    }

    public static contextTypes = {
        renderer: PropTypes.any.isRequired,
    };

    public static defaultProps() {
        return {
            user: {},
            isMobile: false,
        };
    }

    public UNSAFE_componentWillReceiveProps(nextProps) {
        if (nextProps.location.pathname !== this.props.location.pathname) {
            this.setState({
                openKeys: this.getDefaultCollapsedSubMenus(nextProps),
            });
        }
    }

    /**
     * Convert pathname to openKeys
     * /list/search/articles => ['list', '/list/search']
     * @param props
     */
    public getDefaultCollapsedSubMenus(props) {
        const {
            location: { pathname },
        } = props || this.props;
        return getMenuMatchKeys(this.flatMenuKeys, urlToList(pathname));
    }

    /**
     * Allow menu.js config icon as string or ReactNode
     * icon: 'setting',
     * icon: 'http://demo.com/icon.png',
     * icon: <Icon type="setting" />,
     * @param icon
     */
    private getIcon(icon) {
        const { styles = {} } = this.props;
        if (typeof icon === 'string' && icon.indexOf('http') === 0) {
            return <img src={icon} alt="icon" className={styles.icon} />;
        }
        if (typeof icon === 'string') {
            return <div data-type={icon} style={styles.icon} />;
        }
        return icon;
    }

    private getAvatar(menu) {
        const { styles = {}, user } = this.props;
        return (
            <span data-user={user.nickname} id={!user || user.isTest ? `cde-user-placeholder` : 'cde-user'}>
                <div style={{ marginRight: '7px' }} data-src={getImageUrl(user.picture)}>
                    {user.nickname || 'Guest'}
                </div>{' '}
                <span> {user.nickname || 'Guest'}</span>
            </span>
        );
    }

    /**
     * Judge whether it is http link.return or a Link
     * @memberOf SiderMenu
     */
    private getMenuItemPath = (item) => {
        const { styles = {} } = this.props;
        const itemPath = this.conversionPath(item.path);
        const icon = this.getIcon(item.icon);
        const { target, name } = item;
        // Is it a http link
        if (/^https?:\/\//.test(itemPath)) {
            return (
                <a href={itemPath} target={target}>
                    {icon}
                    <span>{name}</span>
                </a>
            );
        }
        return (
            <Link
                to={itemPath}
                target={target}
                replace={itemPath === this.props.location.pathname}
                onClick={
                    this.props.isMobile
                        ? () => {
                              this.props.onCollapse(true);
                          }
                        : undefined
                }
            >
                {icon}
                <span>{name}</span>
            </Link>
        );
    };

    /**
     * get SubMenu or Item
     */
    private getSubMenuOrItem = (item) => {
        const { styles = {} } = this.props;
        if (item.children && item.children.some((child) => child.name)) {
            const childrenItems = this.getNavMenuItems(item.children);
            if (childrenItems && childrenItems.length > 0) {
                return (
                    <SubMenu title={item.name} key={item.path}>
                        {childrenItems}
                    </SubMenu>
                );
            }
            return null;
        }
        return <Menu.Item key={item.path}>{this.getMenuItemPath(item)}</Menu.Item>;
    };

    /**
     * @memberof SiderMenu
     */
    private getNavMenuItems = (menusData) => {
        if (!menusData) {
            return [];
        }
        return menusData
            .filter((item) => item.name && !item.hideInMenu)
            .map((item) => {
                // make dom
                const ItemDom = this.getSubMenuOrItem(item);
                return this.checkPermissionItem(item.authority, ItemDom);
            })
            .filter((item) => item);
    };

    /**
     * Generates LOGO
     * @memberof SiderMenu
     */
    private getLogo(logo) {
        const { styles = {} } = this.props;
        return (
            logo && (
                <div className={styles.logo} key="logo">
                    <Link to="/">
                        <img src={logo.icon} alt="logo" />
                        <h1>{logo.name}</h1>
                    </Link>
                </div>
            )
        );
    }

    // Get the currently selected menu
    private getSelectedMenuKeys = () => {
        const {
            location: { pathname },
        } = this.props;
        return getMenuMatchKeys(this.flatMenuKeys, urlToList(pathname));
    };

    // conversion Path
    private conversionPath = (path) => {
        if (path && path.indexOf('http') === 0) {
            return path;
        }
        return `/${path || ''}`.replace(/\/+/g, '/');
    };

    // permission to check
    private checkPermissionItem = (authority, ItemDom) => {
        if (this.props.Authorized && this.props.Authorized.check) {
            const { check } = this.props.Authorized;
            return check(authority, ItemDom);
        }
        return ItemDom;
    };

    private isMainMenu = (key) => {
        return this.menus.some((item) => key && (item.key === key || item.path === key));
    };

    private handleOpenChange = (openKeys) => {
        const lastOpenKey = openKeys[openKeys.length - 1];
        const moreThanOne = openKeys.filter((openKey) => this.isMainMenu(openKey)).length > 1;
        this.setState({
            openKeys: moreThanOne ? [lastOpenKey] : [...openKeys],
        });
    };

    public render() {
        const { renderer } = this.context;
        const { logo, collapsed, segments = [], onCollapse, styles = {} } = this.props;
        const { openKeys } = this.state;
        // Don't show popup menu when it is been collapsed
        const menuProps = collapsed ? {} : { openKeys };
        // If pathname can't match, use the nearest parent's key
        let selectedKeys = this.getSelectedMenuKeys();
        if (!selectedKeys.length) {
            selectedKeys = [openKeys[openKeys.length - 1]];
        }

        return (
            <Sider
                trigger={null}
                collapsible
                collapsed={collapsed}
                breakpoint="lg"
                onCollapse={onCollapse}
                width={256}
                className={styles.sider}
            >
                {this.getLogo((this.menus.filter((menu) => menu.position === IMenuPosition.LOGO) || [])[0])}
                <div className={styles.grow}>
                    <Menu
                        key="Menu-Middle"
                        theme="dark"
                        mode="inline"
                        {...menuProps}
                        className={styles.grow}
                        onOpenChange={this.handleOpenChange}
                        selectedKeys={selectedKeys}
                        style={{ padding: '16px 0', width: '100%' }}
                    >
                        {this.getNavMenuItems(this.menus.filter((menu) => menu.position === IMenuPosition.MIDDLE))}
                    </Menu>
                    {segments.map((segment, segmentIndex) => (
                        <div key={segmentIndex}>{React.cloneElement(segment, { collapsed })}</div>
                    ))}
                </div>
                <Menu
                    key="Menu-Bottom"
                    theme="dark"
                    mode="inline"
                    {...menuProps}
                    onOpenChange={this.handleOpenChange}
                    selectedKeys={selectedKeys}
                    style={{ padding: '16px 0', width: '100%' }}
                >
                    {this.getNavMenuItems(this.menus.filter((menu) => menu.position === IMenuPosition.BOTTOM))}
                </Menu>
            </Sider>
        );
    }
}

\`\`\`

## portable-devices/desktop/src/renderer/components/layout/components/index.ts

\`\`\`ts
export * from './SideMenu';

\`\`\`

## portable-devices/desktop/src/renderer/components/layout/index.ts

\`\`\`ts
export * from './components';

\`\`\`

## portable-devices/desktop/src/renderer/config/config.ts

\`\`\`ts
import * as envalid from 'envalid';

const { str, bool, num } = envalid;

export const config = envalid.cleanEnv(process.env, {
    NODE_ENV: str({ default: 'production', choices: ['production', 'staging', 'development', 'test'] }),
    BACKEND_URL: str({ devDefault: __BACKEND_URL__ }),
    LOCAL_BACKEND_URL: str({ devDefault: __BACKEND_URL__ }),
    LOCAL_GRAPHQL_URL: str({ default: __GRAPHQL_URL__ }),
    GRAPHQL_URL: str({ devDefault: __GRAPHQL_URL__ }),
    CLIENT_URL: str({ devDefault: __BACKEND_URL__ }),
    NAMESPACE: str({ default: 'default' }),
    AUTH0_TOKEN_GRANTED_TIME: num({ default: 2592000000, desc: 'set to 30 days(30*24*60*60*1000) by default' }),
});

\`\`\`

## portable-devices/desktop/src/renderer/config/index.ts

\`\`\`ts
export * from './config';

\`\`\`

## portable-devices/desktop/src/renderer/config/main/client.service.ts

\`\`\`ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ClientTypes } from '@common-stack/client-core';
import { Container } from 'inversify';
import { ApolloClient } from '@apollo/client';
import { CdmLogger } from '@cdm-logger/core';
import { logger } from '@cdm-logger/client';
import modules, { container } from '../../modules/main';
import { createApolloClient } from '../../../common/config/base-apollo-client';
import { PUBLIC_SETTINGS } from '../public-config';
import { isDev } from '../../../common';

let __CLIENT_SERVICE__: {
    apolloClient: ApolloClient<any>;
    container: Container;
    services: any;
    logger: CdmLogger.ILogger;
};
export const createClientContainer = () => {
    if (__CLIENT_SERVICE__) {
        return __CLIENT_SERVICE__;
    }
    const clientState = modules.getStateParams({ resolverContex: () => modules.createService({}, {}) });
    const { cache, apolloClient } = createApolloClient({
        httpGraphqlURL: PUBLIC_SETTINGS.GRAPHQL_URL,
        httpLocalGraphqlURL: PUBLIC_SETTINGS.LOCAL_GRAPHQL_URL,
        isDev,
        isDebug: __DEBUGGING__,
        isSSR: __SSR__,
        scope: 'browser',
        clientState,
        getDataIdFromObject: (result) => modules.getDataIdFromObject(result),
        initialState: null,
        logger,
    });
    // attaching the context to client as a workaround.
    container.bind(ClientTypes.ApolloClient).toConstantValue(apolloClient);
    container.bind(ClientTypes.InMemoryCache).toConstantValue(cache);
    const services = modules.createService({}, {});
    (apolloClient as any).container = services;

    __CLIENT_SERVICE__ = {
        container,
        apolloClient,
        services,
        logger,
    };
    return __CLIENT_SERVICE__;
};

\`\`\`

## portable-devices/desktop/src/renderer/config/main/epic-config.ts

\`\`\`ts
import { combineEpics, ofType } from 'redux-observable';
import { BehaviorSubject } from 'rxjs';
import { mergeMap, takeUntil } from 'rxjs/operators';
import modules from '../../modules/main';

export const epic$ = new BehaviorSubject(combineEpics(...modules.epics));

// Since we're using mergeMap, by default any new
// epic that comes in will be merged into the previous
// one, unless an EPIC_END action is dispatched first,
// which would cause the old one(s) to be unsubscribed
export const rootEpic = (action$, ...rest) =>
    epic$.pipe<any>(mergeMap((epic) => epic(action$, ...rest).pipe(takeUntil(action$.pipe(ofType('EPIC_END'))))));

\`\`\`

## portable-devices/desktop/src/renderer/config/main/fela-renderer.ts

\`\`\`ts
import { createRenderer } from 'fela';
import webPreset from 'fela-preset-web';

export default () => {
    const renderer = createRenderer({
        plugins: [...webPreset],
        devMode: process.env.NODE_ENV ? process.env.NODE_ENV !== 'production' : false,
    });
    renderer.renderStatic(
        `
        html, body, #root{
            height: 100%;
            }
            .ant-picker-dropdown, .ant-select-dropdown {
            
            }
            @media only screen and (min-width: 768px) {
                #usermenuStyle{
                    position: fixed;
                    top: calc(100% - 140px)!important;
                }
            }
            aside{
                overflow:inherit !important;
            }
        `,
    );

    return renderer;
};

\`\`\`

## portable-devices/desktop/src/renderer/config/main/redux-config.ts

\`\`\`ts
/* eslint-disable no-param-reassign */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable global-require */
/* eslint-disable no-nested-ternary */
/* eslint-disable no-underscore-dangle */
import { replayActionRenderer, forwardToMainWithParams } from 'electron-redux';
import storage from 'redux-persist/lib/storage';
import { combineReducers } from 'redux';
import autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2';
import { createEpicMiddleware } from 'redux-observable';
import { connectRouter, routerMiddleware } from 'connected-react-router';
import modules from '../../modules/main';
import { createClientContainer } from './client.service';
import { rootEpic, epic$ } from './epic-config';
import { createReduxStore as createBaseReduxStore } from '../../../common/config/base-redux-config';
import { isDev } from '../../../common';

const history = require('../router-history');

const { apolloClient, services, container, logger } = createClientContainer();
export const epicMiddleware = createEpicMiddleware({
    dependencies: {
        apolloClient,
        routes: modules.getConfiguredRoutes(),
        services,
        container,
        logger,
    },
});

export const persistConfig = {
    key: 'root',
    storage,
    stateReconciler: autoMergeLevel2,
    // Don't add `user` state to persist as it creates problems.
    transforms: modules.reduxPersistStateTransformers,
};

export const storeReducer = (hist) =>
    combineReducers({
        router: connectRouter(hist),
        ...modules.reducers,
    });

/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = () => {
    // middleware
    const router = connectRouter(history);

    let store;
    if ((module as any).hot && (module as any).hot.data && (module as any).hot.data.store) {
        // console.log('Restoring Redux store:', JSON.stringify((module as any).hot.data.store.getState()));
        store = (module as any).hot.data.store;
        // replace the reducers always as we don't have ablity to find
        // new reducer added through our `modules`
        store.replaceReducer(
            persistReducer(persistConfig, storeReducer((module as any).hot.data.history || newHistory)),
        );
        // store.replaceReducer(storeReducer((module as any).hot.data.history || history));
    } else {
        // If we have preloaded state, save it.
        const initialState = __CLIENT__
            ? { ...window.__PRELOADED_STATE__ } // #952 TODO we need cookie to have id_token for SSR to work properly
            : {};
        // Delete it once we have it stored in a variable
        if (__CLIENT__) {
            delete window.__PRELOADED_STATE__;
        }
        store = createBaseReduxStore({
            scope: 'browser',
            isDebug: __DEBUGGING__,
            isDev,
            initialState: {},
            persistConfig,
            middleware: [routerMiddleware(history)],
            epicMiddleware,
            preMiddleware: [
                forwardToMainWithParams({
                    blacklist: [/^@@/, /^redux-form/, /^contribution/, /^command/],
                }),
            ],
            rootEpic,
            reducers: { router, ...modules.reducers },
        });
    }
    if ((module as any).hot) {
        (module as any).hot.dispose((data) => {
            // console.log("Saving Redux store:", JSON.stringify(store.getState()));
            data.store = store;
            data.history = history;
        });
        (module as any).hot.accept('../config/epic-config', () => {
            // we may need to reload epic always as we don't
            // know whether it is updated using our `modules`
            const nextRootEpic = require('./epic-config').rootEpic;
            // First kill any running epics
            store.dispatch({ type: 'EPIC_END' });
            // Now setup the new one
            epic$.next(nextRootEpic);
        });
    }
    // Delete it once we have it stored in a variable
    if (__CLIENT__) {
        // electron
        replayActionRenderer(store);
    }
    container.bind('ReduxStore').toConstantValue(store);
    return store;
};

\`\`\`

## portable-devices/desktop/src/renderer/config/public-config.ts

\`\`\`ts
/* eslint-disable no-underscore-dangle */
import { lowerCase } from 'lodash';

/**
 * This file opens up in public site, so make sure it is
 * not dependent on any other file that compromises the security.
 */
const publicEnv = [
    'NODE_ENV',
    'GRAPHQL_URL',
    'GRAPHQL_SUBSCRIPTION_URL',
    'FACEBOOK_APP_ID',
    'GA_ID',
    'LOG_LEVEL',
    'AUTH0_CLIENT_ID',
    'AUTH0_DOMAIN',
    'CLIENT_URL',
    'APP_NAME',
    'AUTH0_API_AUDIENCE',
    'AUTH0_REALM',
    'STRIPE_PUBLISHABLE_KEY',
    'CDE_WORKSPACE_DOMAIN',
    'CDE_WORKSPACE_URL_PRFIX',
    'AUTH0_TOKEN_GRANTED_TIME',
    'ZIPKIN_URL',
    'EXTENSION_SOCKET_URL',
];

const isBrowser = typeof window !== 'undefined';
// const base = (isBrowser ? ( window.__ENV__ || __ENV__) : process.env) || {};
const base = {
    AUTH0_CLIENT_ID: 'GVh8k85SAftTTRbotGxsc986piXsR825',
    AUTH0_DOMAIN: 'dev-cdebase.auth0.com',
    AUTH0_ISSUER: 'https://dev-cdebase.auth0.com/',
    AUTH0_API_AUDIENCE: 'https://dev-cdebase.auth0.com/api/v2/',
    STRIPE_ENDPOINT_SECRET: 'werwerw',
    CLIENT_URL: 'http://localhost',
};

const env: any = {};
for (const v of publicEnv) {
    env[v] = base[v];
}

export default env;

if (isBrowser) {
    process[lowerCase('env')] = env; // to avoid webpack to replace `process` with actual value.
    process.APP_ENV = env;
}
export const PUBLIC_SETTINGS: __PUBLIC_SETTINGS__ = {
    apolloLogging: false,
    GRAPHQL_URL: process.env.GRAPHQL_URL || env.GRAPHQL_URL || __GRAPHQL_URL__,
    LOCAL_GRAPHQL_URL: process.env.LOCAL_GRAPHQL_URL || __GRAPHQL_URL__,
    LOG_LEVEL: process.env.LOG_LEVEL || 'trace',
};

\`\`\`

## portable-devices/desktop/src/renderer/config/router-history.ts

\`\`\`ts
import { createHashHistory } from 'history';

module.exports = createHashHistory(); // use hashistory in electron

\`\`\`

## portable-devices/desktop/src/renderer/config/tray/client.service.ts

\`\`\`ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ClientTypes } from '@common-stack/client-core';
import { Container } from 'inversify';
import { ApolloClient } from '@apollo/client';
import { CdmLogger } from '@cdm-logger/core';
import { logger } from '@cdm-logger/client';
import modules, { container } from '../../modules/tray';
import { createApolloClient } from '../../../common/config/base-apollo-client';
import { PUBLIC_SETTINGS } from '../public-config';
import { isDev } from '../../../common';

let __CLIENT_SERVICE__: {
    apolloClient: ApolloClient<any>;
    container: Container;
    services: any;
    logger: CdmLogger.ILogger;
};
export const createClientContainer = () => {
    if (__CLIENT_SERVICE__) {
        return __CLIENT_SERVICE__;
    }
    const clientState = modules.getStateParams({ resolverContex: () => modules.createService({}, {}) });
    const { cache, apolloClient } = createApolloClient({
        httpGraphqlURL: PUBLIC_SETTINGS.GRAPHQL_URL,
        httpLocalGraphqlURL: PUBLIC_SETTINGS.LOCAL_GRAPHQL_URL,
        isDev,
        isDebug: __DEBUGGING__,
        isSSR: __SSR__,
        scope: 'browser',
        clientState,
        getDataIdFromObject: (result) => modules.getDataIdFromObject(result),
        initialState: null,
        logger,
    });
    // attaching the context to client as a workaround.
    container.bind(ClientTypes.ApolloClient).toConstantValue(apolloClient);
    container.bind(ClientTypes.InMemoryCache).toConstantValue(cache);
    const services = modules.createService({}, {});
    (apolloClient as any).container = services;

    __CLIENT_SERVICE__ = {
        container,
        apolloClient,
        services,
        logger,
    };
    return __CLIENT_SERVICE__;
};

\`\`\`

## portable-devices/desktop/src/renderer/config/tray/epic-config.ts

\`\`\`ts
import { combineEpics, ofType } from 'redux-observable';
import { BehaviorSubject } from 'rxjs';
import { mergeMap, takeUntil } from 'rxjs/operators';
import modules from '../../modules/tray';

export const epic$ = new BehaviorSubject(combineEpics(...modules.epics));

// Since we're using mergeMap, by default any new
// epic that comes in will be merged into the previous
// one, unless an EPIC_END action is dispatched first,
// which would cause the old one(s) to be unsubscribed
export const rootEpic = (action$, ...rest) =>
    epic$.pipe<any>(mergeMap((epic) => epic(action$, ...rest).pipe(takeUntil(action$.pipe(ofType('EPIC_END'))))));

\`\`\`

## portable-devices/desktop/src/renderer/config/tray/fela-renderer.ts

\`\`\`ts
import { createRenderer } from 'fela';
import webPreset from 'fela-preset-web';

export default () => {
    const renderer = createRenderer({
        plugins: [...webPreset],
        devMode: process.env.NODE_ENV ? process.env.NODE_ENV !== 'production' : false,
    });
    renderer.renderStatic(
        `
        html, body, #root{
            height: 100%;
            }
        `,
    );

    return renderer;
};

\`\`\`

## portable-devices/desktop/src/renderer/config/tray/redux-config.ts

\`\`\`ts
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable global-require */
/* eslint-disable no-nested-ternary */
/* eslint-disable no-underscore-dangle */
import { forwardToMain, replayActionRenderer, forwardToMainWithParams, getInitialStateRenderer } from 'electron-redux';
import { createEpicMiddleware } from 'redux-observable';
import { connectRouter, routerMiddleware } from 'connected-react-router';
import modules from '../../modules/tray';
import { createClientContainer } from './client.service';
import { isDev } from '../../../common';
import { rootEpic } from './epic-config';
import { createReduxStore as createBaseReduxStore } from '../../../common/config/base-redux-config';

export const history = require('../router-history');

const { apolloClient, container, services, logger } = createClientContainer();
export const epicMiddleware = createEpicMiddleware({
    dependencies: {
        apolloClient,
        routes: modules.getConfiguredRoutes(),
        services,
        container,
        logger,
    },
});

/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = () => {
    // middleware
    const router = connectRouter(history);

    // If we have preloaded state, save it.
    const store = createBaseReduxStore({
        scope: 'browser',
        isDebug: __DEBUGGING__,
        isDev,
        initialState: {},
        middleware: [routerMiddleware(history)],
        // epicMiddleware,
        preMiddleware: [forwardToMain],
        // rootEpic,
        reducers: { router, ...modules.reducers },
    });

    // Delete it once we have it stored in a variable
    if (__CLIENT__) {
        delete window.__PRELOADED_STATE__;
        // electron
        replayActionRenderer(store);
    }
    container.bind('ReduxStore').toConstantValue(store);

    return store;
};

\`\`\`

## portable-devices/desktop/src/renderer/main.tsx

\`\`\`tsx
import 'reflect-metadata';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import './config/public-config'; // load before rendering `Main`
import Main from './app/Main';
import 'antd/dist/antd.css';
// import 'react-table/react-table.css';
// import 'react-big-calendar/lib/css/react-big-calendar.css';
// import 'react-big-calendar/lib/addons/dragAndDrop/styles.css';
// Virtual (module as any), generated in-memory by zenjs, contains count of backend rebuilds
// tslint:disable-next-line
// import 'backend_reload';

const rootEl = document.getElementById('app');
let frontendReloadCount = 0;

const renderApp = ({ key }: { key: number }) => ReactDOM.render(<Main key={key} />, rootEl);
renderApp({ key: frontendReloadCount });
if (__DEV__) {
    if ((module as any).hot) {
        (module as any).hot.accept();
        // (module as any).hot.accept('backend_reload', () => {
        //     // log.debug('Reloading front-end');
        //     // when the backend restarts wait for 5 seconds
        //     setTimeout(() => window.location.reload(), 5000);
        //     // window.location.reload();
        // });
        (module as any).hot.accept((err) => {
            if (err) {
                console.error('Cannot apply HMR update.', err);
            }
        });
        //  React-hot-loader v4 doesn't require following code any more.
        //  but if RHL not working we can uncomment below code to make normal HMR to refresh the page
        (module as any).hot.accept('./app/Main', () => {
            try {
                console.log('Updating front-end');
                frontendReloadCount = (frontendReloadCount || 0) + 1;

                renderApp({ key: frontendReloadCount });
            } catch (err) {
                // log(err.stack);
            }
        });
    }
}

\`\`\`

## portable-devices/desktop/src/renderer/modules/main/index.ts

\`\`\`ts
import { logger } from '@cdm-logger/client';
import { ClientTypes } from '@common-stack/client-react';
import modules, { MainRoute } from './module';

class UtilityClass {
    // eslint-disable-next-line no-useless-constructor
    constructor(private modules) {}

    public getCacheKey(storeObj) {
        return this.modules.getDataIdFromObject(storeObj);
    }
}

const utility = new UtilityClass(modules);

// additional bindings to container
const container = modules.createContainers({}) as any;
container.bind(ClientTypes.Logger).toConstantValue(logger);
container.bind(ClientTypes.UtilityClass).toConstantValue(utility);

export default modules;
export { MainRoute, container, logger };

\`\`\`

## portable-devices/desktop/src/renderer/modules/main/module.tsx

\`\`\`tsx
import * as React from 'react';
import { Layout } from 'antd';
import counterModules from '@sample-stack/counter-module-browser';
import { Feature, FeatureWithRouterFactory } from '@common-stack/client-react';
import { SiderMenu } from '../../components/layout';

const features = new Feature(FeatureWithRouterFactory, counterModules);

export const MainRoute = (props) => (
    <Layout hasSider style={{ minHeight: '100vh', display: 'flex' }}>
        <SiderMenu
            collapsed={false}
            menuData={features.getMenus()}
            location={window.location as any}
            segments={features.sidebarSegments}
        />
        <Layout>
            <Layout.Content style={{ height: '100%' }}>
                <section className="flex-grow" style={{ height: '100%' }}>
                    {features.getRoutes()}
                </section>
            </Layout.Content>
        </Layout>
    </Layout>
);

export default features;

\`\`\`

## portable-devices/desktop/src/renderer/modules/tray/index.ts

\`\`\`ts
import { logger } from '@cdm-logger/client';
import { ClientTypes } from '@common-stack/client-react';
import modules, { MainRoute } from './module';

class UtilityClass {
    // eslint-disable-next-line no-useless-constructor
    constructor(private modules) {}

    public getCacheKey(storeObj) {
        return this.modules.getDataIdFromObject(storeObj);
    }
}

const utility = new UtilityClass(modules);

// additional bindings to container
const container = modules.createContainers({}) as any;
container.bind(ClientTypes.Logger).toConstantValue(logger);
container.bind(ClientTypes.UtilityClass).toConstantValue(utility);

export default modules;
export { MainRoute, container, logger };

\`\`\`

## portable-devices/desktop/src/renderer/modules/tray/module.tsx

\`\`\`tsx
import * as React from 'react';
import { Feature, FeatureWithRouterFactory, renderRoutes2 } from '@common-stack/client-react';
import { Layout } from 'antd';
import { ElectronTrayModule } from '@sample-stack/counter-module-browser';

const features = new Feature(FeatureWithRouterFactory, ElectronTrayModule);
export const MainRoute = (props) => (
    <Layout>
        <Layout.Content style={{ height: '100%' }}>
            <section className="flex-grow" style={{ height: '100%' }}>
                {features.getRoutes()}
            </section>
        </Layout.Content>
    </Layout>
);

export default features;

\`\`\`

## portable-devices/desktop/src/renderer/tray-main.tsx

\`\`\`tsx
import 'reflect-metadata';
import 'antd/dist/antd.css';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import './config/public-config'; // load before rendering `Main`
import Main from './app/Tray';

// Virtual (module as any), generated in-memory by zenjs, contains count of backend rebuilds
// tslint:disable-next-line
// import 'backend_reload';

const rootEl = document.getElementById('app');
let frontendReloadCount = 0;

const renderApp = ({ key }: { key: number }) => ReactDOM.render(<Main key={key} />, rootEl);
renderApp({ key: frontendReloadCount });
if (__DEV__) {
    if ((module as any).hot) {
        (module as any).hot.accept();
        // (module as any).hot.accept('backend_reload', () => {
        //     // log.debug('Reloading front-end');
        //     // when the backend restarts wait for 5 seconds
        //     setTimeout(() => window.location.reload(), 5000);
        //     // window.location.reload();
        // });
        (module as any).hot.accept((err) => {
            if (err) {
                console.error('Cannot apply HMR update.', err);
            }
        });
        //  React-hot-loader v4 doesn't require following code any more.
        //  but if RHL not working we can uncomment below code to make normal HMR to refresh the page
        (module as any).hot.accept('./app/Tray', () => {
            try {
                console.log('Updating front-end');
                frontendReloadCount = (frontendReloadCount || 0) + 1;

                renderApp({ key: frontendReloadCount });
            } catch (err) {
                // log(err.stack);
            }
        });
    }
}

\`\`\`

## portable-devices/desktop/tools/esm-wrapper.js

\`\`\`js
/* eslint-disable import/no-unresolved */
/* eslint-disable no-global-assign */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable @typescript-eslint/no-unsafe-call */
require = require('esm')(module, { cjs: true });
module.exports = require('./main-process.js');

\`\`\`

## portable-devices/desktop/tools/utils.js

\`\`\`js
const path = require('path');
const getSymlinkedNodeModulesForDirectory = require('../../../tools/get-symlinked-modules');

function getWorkspacePackagePaths(root) {
    const symlinkedModules = getSymlinkedNodeModulesForDirectory(root);
    const symlinkedModulePaths = Object.values(symlinkedModules);
    return symlinkedModulePaths.map((f) => path.resolve(f, 'lib'));
}
module.exports = {
    getWorkspacePackagePaths,
};

\`\`\`

## portable-devices/desktop/tsconfig.json

\`\`\`json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "declaration": false,
    "jsx": "react",
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["../../typings/*.d.ts"],
  "exclude": ["node_modules", "lib", "dist", "webpack.config.js"]
}

\`\`\`

## portable-devices/desktop/webpack.main.additions.js

\`\`\`js
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable @typescript-eslint/no-unsafe-call */
const TerserPlugin = require('terser-webpack-plugin');
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const webpack = require('webpack');
const buildConfig = require('./build.config');

const config = {
    devtool: process.env.DEBUG_PROD === 'true' ? 'source-map' : 'none',
    target: 'electron-main',
    entry: './src/main/index.ts',
    mode: 'development',
    output: {
        filename: 'main-process.js',
    },
    resolve: {
        extensions: ['.ts', '.tsx', '.mjs', '.graphql', '.graphqls', '.gql', '.native.tsx', '.native.ts'],
    },
    optimization: {
        minimizer: process.env.E2E_BUILD
            ? []
            : [
                  new TerserPlugin({
                      parallel: true,
                      sourceMap: true,
                      cache: true,
                  }),
              ],
    },
    module: {
        rules: [
            {
                test: /\.mjs$/,
                include: /node_modules/,
                type: 'javascript/auto',
            },
        ],
    },
    plugins: [
        new CopyWebpackPlugin({
            patterns: [
                {
                    from: 'assets/preload.js',
                    to: 'preload.js',
                },
                {
                    from: 'tools/esm-wrapper.js',
                    to: 'main.js',
                },
                {
                    from: 'assets/icons',
                    to: 'icons',
                },
            ],
        }),
        // new Dotenv({
        //     path: process.env.ENV_FILE,
        // }),
        new webpack.DefinePlugin(
            Object.assign(
                ...Object.entries(buildConfig).map(([k, v]) => ({
                    [k]: typeof v !== 'string' ? v : `'${v.replace(/\\/g, '\\\\')}'`,
                })),
            ),
        ),
        // new webpack.DefinePlugin({
        //     __ENV__: JSON.stringify(dotenv.parsed),
        // }),
        new BundleAnalyzerPlugin({
            analyzerMode: process.env.OPEN_ANALYZER === 'true' ? 'server' : 'disabled',
            openAnalyzer: process.env.OPEN_ANALYZER === 'true',
        }),

        /**
         * Create global constants which can be configured at compile time.
         *
         * Useful for allowing different behaviour between development builds and
         * release builds.
         *
         * NODE_ENV should be production so that modules do not perform certain
         * development checks.
         */
        new webpack.EnvironmentPlugin({
            NODE_ENV: 'production',
            DEBUG_PROD: false,
            START_MINIMIZED: false,
            E2E_BUILD: false,
        }),
    ],

    /**
     * Disables webpack processing of __dirname and __filename.
     * If you run the bundle in node.js it falls back to these values of node.js.
     * https://github.com/webpack/webpack/issues/2010
     */
    node: {
        __dirname: false,
        __filename: false,
    },
};

module.exports = config;

\`\`\`

## portable-devices/desktop/webpack.renderer.additions.js

\`\`\`js
/* eslint-disable import/no-extraneous-dependencies */
const Dotenv = require('dotenv-webpack');
const path = require('path');
const webpack = require('webpack');
const dotenv = require('dotenv-safe');
const { merge } = require('webpack-merge');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const utils = require('./tools/utils');
const buildConfig = require('./build.config');

const config = {
    target: 'electron-renderer',
    entry: {
        renderer: ['./src/renderer/main.tsx'],
        tray: ['./src/renderer/tray-main.tsx'],
        about: ['./src/renderer/about.tsx'],
    },
    output: {
        filename: '[name].js',
    },
    plugins: [
        new Dotenv({
            path: process.env.ENV_FILE,
        }),
        new webpack.DefinePlugin(
            Object.assign(
                ...Object.entries(buildConfig).map(([k, v]) => ({
                    [k]: typeof v !== 'string' ? v : `'${v.replace(/\\/g, '\\\\')}'`,
                })),
            ),
        ),
        new webpack.DefinePlugin({
            __ENV__: JSON.stringify(dotenv.parsed),
        }),
        new CopyWebpackPlugin({
            patterns: [
                {
                    from: 'assets/html/tray-page.html',
                    to: 'tray-page.html',
                },
                {
                    from: 'assets/html/about-page.html',
                    to: 'about-page.html',
                },
                {
                    from: 'assets/html/main-page.html',
                    to: 'main-page.html',
                },
            ],
        }),
    ],
    resolve: {
        symlinks: true,
    },
    externals: [
        '@apollo/client',
        'react',
        'react-redux',
        'react-fela',
        'react-helmet',
        'react-loadable',
        'react-router',
        'react-router-config',
        'react-router-dom',
        'react-transition-group',
        'connected-react-router',
        'history',
    ],
};

if (process.env.NODE_ENV === 'development') {
    const dotEnvPlugin = {
        plugins: [
            new Dotenv({
                path: process.env.ENV_FILE,
            }),
        ],
    };
    // config.builders.web.webpackConfig = merge(config.builders.web.webpackConfig, dotEnvPlugin);
}

const workspaceRoot = path.resolve(__dirname, '../..');
const dirsToWatch = utils.getWorkspacePackagePaths(workspaceRoot);
// inorder to make watch to work on workspace packages
module.exports = function (givenConfig) {
    const updatedConfig = merge(givenConfig, config, {
        devServer: {
            ...givenConfig.devServer,
            contentBase: dirsToWatch,
            watchContentBase: true,
        },
    });
    return updatedConfig;
};

\`\`\`

## portable-devices/mobile/App.tsx

\`\`\`tsx
import './src/config/public-config';
import App from './src/App';

export default App;

\`\`\`

## portable-devices/mobile/__generated__/AppEntry.js

\`\`\`js
// @generated by expo-yarn-workspaces

import 'expo/build/Expo.fx';
import { activateKeepAwake } from 'expo-keep-awake';
import registerRootComponent from 'expo/build/launch/registerRootComponent';

import App from '../App';

if (__DEV__) {
  activateKeepAwake();
}

registerRootComponent(App);

\`\`\`

## portable-devices/mobile/app.json

\`\`\`json
{
  "expo": {
    "name": "FullStack Pro",
    "slug": "sample-stack",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/images/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "updates": {
      "fallbackToCacheTimeout": 0
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.cdmbase.samplestack"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#FFFFFF"
      },
      "package": "com.cdmbase.samplestack"
    },
    "web": {
      "favicon": "./assets/images/favicon.png"
    }
  }
}

\`\`\`

## portable-devices/mobile/babel.config.js

\`\`\`js
module.exports = function (api) {
    api.cache(true);
    return {
        presets: ['babel-preset-expo'],
        plugins: [
            [
                'module:react-native-dotenv',
                {
                    moduleName: '@env',
                    path: process.env.ENV_FILE,
                },
            ],
            'react-native-reanimated/plugin',
        ],
    };
};

\`\`\`

## portable-devices/mobile/eas.json

\`\`\`json
{
  "cli": {
    "version": ">= 0.36.1"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "ios": {
        "simulator": true
      },
      "node": "14.17.3",
      "env": {
        "NODE_ENV": "development",
        "GRAPHQL_URL": "https://ideback-default-v1.cdebase.io/graphql",
        "GA_ID": "jjj",
        "LOG_LEVEL": "trace",
        "CLIENT_URL": "http://localhost:3000",
        "APP_NAME": "fullstack-pro"
      }
    },
    "preview": {
      "extends": "production",
      "node": "14.17.3",
      "distribution": "internal",
      "env": {
        "NODE_ENV": "development",
        "GRAPHQL_URL": "https://ideback-default-v1.cdebase.io/graphql",
        "GA_ID": "jjj",
        "LOG_LEVEL": "trace",
        "CLIENT_URL": "http://localhost:3000",
        "APP_NAME": "fullstack-pro"
      }
    },
    "production": {   
      "node": "14.17.3",
      "env": {
        "NODE_ENV": "development",
        "GRAPHQL_URL": "https://ideback-default-v1.cdebase.io/graphql",
        "GA_ID": "jjj",
        "LOG_LEVEL": "trace",
        "CLIENT_URL": "http://localhost:3000",
        "APP_NAME": "fullstack-pro"
      }
    }
  },
  "submit": {
    "production": {}
  }
}

\`\`\`

## portable-devices/mobile/index.js

\`\`\`js
/* eslint-disable jest/require-hook */
/* eslint-disable import/no-unresolved */
/* eslint-disable import/no-extraneous-dependencies */
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in the Expo client or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

\`\`\`

## portable-devices/mobile/jest.config.js

\`\`\`js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    preset: 'jest-expo',
    modulePathIgnorePatterns: [
        '<rootDir>/node_modules/react-native/Libraries/react-native/',
        '<rootDir>/node_modules/react-native/Libraries/vendor/core/whatwg-fetch.js',
        '<rootDir>/node_modules/react-native/jest/',
        '<rootDir>/node_modules/haul/',
        '<rootDir>/portable-devices/mobile/.expo/',
        '<rootDir>/portable-devices/mobile/node_modules/'
    ],
    name: packageJson.name,
    displayName: packageJson.name,
};
\`\`\`

## portable-devices/mobile/metro.config.js

\`\`\`js
// Learn more https://docs.expo.io/guides/customizing-metro
const { getDefaultConfig } = require('expo/metro-config');
const path = require('path');

const projectRoot = __dirname;
const workspaceRoot = path.resolve(__dirname, '../..');

const config = getDefaultConfig(__dirname);

config.watchFolders = [workspaceRoot];
config.resolver.nodeModulesPath = [
    path.resolve(projectRoot, 'node_modules'),
    path.resolve(workspaceRoot, 'node_modules'),
];

module.exports = config;

\`\`\`

## portable-devices/mobile/src/App.tsx

\`\`\`tsx
import { StatusBar } from 'expo-status-bar';
import React from 'react';
import { NativeRouter, Route } from 'react-router-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { StyleSheet } from 'react-native';
import { createRenderer } from 'fela-native';
import { ApolloProvider } from '@apollo/client';
import { Provider } from 'react-redux';
import { MainRoute } from './modules/modules';
import { persistStore, persistReducer } from 'redux-persist';
import { PersistGate } from 'redux-persist/integration/react';
// import { RendererProvider } from 'react-fela';
import { ConnectedRouter } from 'connected-react-router';
import {
  createReduxStore,
  history,
} from './config/redux-config';
import { NativeBaseProvider } from 'native-base';
import { createClientContainer } from './config/client.service';

const { apolloClient: client, container } = createClientContainer();

const store = createReduxStore();
const renderer = createRenderer();

export default function App() {

  let persistor = persistStore(store as any);
  return (
    <NativeBaseProvider>
      <SafeAreaProvider>
        <Provider store={store}>
          <ApolloProvider client={client}>
            <PersistGate persistor={persistor}>
              <NativeRouter>
                <ConnectedRouter history={history}>
                  <MainRoute />
                </ConnectedRouter>
              </NativeRouter>
            </PersistGate>
          </ApolloProvider>
        </Provider>
      </SafeAreaProvider>
    </NativeBaseProvider>
  );
}

const styles = StyleSheet.create({
        container: {
        marginTop: 25,
    padding: 10,
  },
  header: {
        fontSize: 20,
  },
  nav: {
        flexDirection: 'row',
    justifyContent: 'space-around',
  },
  navItem: {
        flex: 1,
    alignItems: 'center',
    padding: 10,
  },
  subNavItem: {
        padding: 5,
  },
  topic: {
        textAlign: 'center',
    fontSize: 15,
  },
});

\`\`\`

## portable-devices/mobile/src/components/__tests__/StyledText-test.js

\`\`\`js
import * as React from 'react';
import renderer from 'react-test-renderer';

import { MonoText } from '../StyledText';

it(`renders correctly`, () => {
    const tree = renderer.create(<MonoText>Snapshot test!</MonoText>).toJSON();

    expect(tree).toMatchSnapshot();
});

\`\`\`

## portable-devices/mobile/src/components/layout/Drawer.tsx

\`\`\`tsx
import * as React from 'react';
import { Drawer } from 'native-base';
import { Route } from 'react-router-native';
import SideBar from './SideBar';

export const DrawerRoute = ({ match, drawerRef, routes }: any) => {
  const onClose = () => {
    console.log("close")
    drawerRef.current._root.close()
  }

  return (
    <Drawer 
    ref={drawerRef} 
    content={
      <SideBar matchUrl={match.url} routes={routes} />
    }
    onClose={onClose}
    >
      {routes.map((route: any) => (
        <Route key={route.path} exact={route.exact} path={route.path} component={route.component} />
      ))}
    </Drawer>
  )
};

\`\`\`

## portable-devices/mobile/src/components/layout/Header.tsx

\`\`\`tsx
import React, { useState } from 'react';
import { Header, Left, Right, Body, Text, Icon } from 'native-base';

const MainHeader = (props: any) => {
  const[isToggle, setIsToggle] = useState(false);

  const toggle = () => {
    if(isToggle){
      props.drawerRef?.current?._root?.close();
    } else{
      props.drawerRef?.current?._root?.open();
    }
    setIsToggle(!isToggle)
  }

  return (
    <Header style={{ backgroundColor: '#1f1f1f' }}>
      <Left>
        <Icon style={{ color: '#fff' }} name="menu" onPress={() => toggle()} />
      </Left>
      <Body>
        <Text style={{ color: '#fff' }}>{props.title}</Text>
      </Body>
    </Header>
  );
};

export default MainHeader;

\`\`\`

## portable-devices/mobile/src/components/layout/Layout.tsx

\`\`\`tsx
import React, { useRef } from 'react';
import { View } from 'react-native';
import { connect } from 'react-redux';
import MainHeader from './Header';
import { DrawerRoute } from './Drawer';

const Layout = (props: any, route: any) => {
  const drawerRef = useRef();
  return (
    <View style={{ flex: 1 }}>
      <MainHeader title="CDMBase LLC" drawerRef={drawerRef} />
      <DrawerRoute match={props.match} routes={route.routes || []} drawerRef={drawerRef}/>
    </View>
  );
};

export const ProLayout = connect((state: any) => {
  return {
    settings: state.settings,
    location: state.router.location,
  };
})(Layout);

export default Layout;

\`\`\`

## portable-devices/mobile/src/components/layout/NativeBaseIcon.tsx

\`\`\`tsx
import * as React from 'react';
import { Icon } from 'native-base';
import { G, Path } from 'react-native-svg';
const NativeBaseIcon = () => {
  return (
    <Icon size="220px" viewBox="0 0 602.339 681.729">
      <G
        id="Group_403"
        data-name="Group 403"
        transform="translate(14575 1918.542)"
      >
        <Path
          id="Path_1"
          data-name="Path 1"
          d="M488.722,0A45.161,45.161,0,0,1,527.83,22.576L675.676,278.584a45.162,45.162,0,0,1,0,45.171L527.83,579.763a45.162,45.162,0,0,1-39.108,22.576H193.008A45.162,45.162,0,0,1,153.9,579.763L6.053,323.755a45.162,45.162,0,0,1,0-45.171L153.9,22.576A45.162,45.162,0,0,1,193.008,0Z"
          transform="translate(-13972.661 -1918.542) rotate(90)"
          fill="#356290"
        />
        <Path
          id="Path_252"
          data-name="Path 252"
          d="M401.1,0A60.816,60.816,0,0,1,453.77,30.405L567.2,226.844a60.816,60.816,0,0,1,0,60.82L453.77,484.1A60.816,60.816,0,0,1,401.1,514.509H174.241A60.816,60.816,0,0,1,121.575,484.1L8.149,287.665a60.816,60.816,0,0,1,0-60.82L121.575,30.405A60.816,60.816,0,0,1,174.241,0Z"
          transform="translate(-14016.576 -1865.281) rotate(90)"
          fill="#1784b2"
        />
        <Path
          id="Path_251"
          data-name="Path 251"
          d="M345.81,0a36.573,36.573,0,0,1,31.674,18.288L480.566,196.856a36.573,36.573,0,0,1,0,36.569L377.484,411.993a36.573,36.573,0,0,1-31.674,18.288H139.655a36.572,36.572,0,0,1-31.674-18.288L4.9,233.425a36.573,36.573,0,0,1,0-36.569L107.981,18.288A36.573,36.573,0,0,1,139.655,0Z"
          transform="translate(-14058.69 -1820.41) rotate(90)"
          fill="#50bfc3"
        />
        <Path
          id="_x3C__x2F__x3E_"
          d="M187.066,335.455V297.993l-65.272-21.949,65.272-22.523V216.059L81,259.5v32.521Zm38.726,29.3L286.123,174H256.7l-60.33,190.759Zm72.052-29.3,106.066-43.783V259.267L297.844,216.059V254.44l59.3,23.328-59.3,19.421Z"
          transform="translate(-14516.286 -1846.988)"
          fill="#fff"
        />
      </G>
    </Icon>
  );
};

export default NativeBaseIcon;

\`\`\`

## portable-devices/mobile/src/components/layout/NativeBaseSample.tsx

\`\`\`tsx
import React from 'react';
import {
  Text,
  Link,
  HStack,
  Center,
  Heading,
  Switch,
  useColorMode,
  NativeBaseProvider,
  extendTheme,
  VStack,
  Code,
} from 'native-base';
import NativeBaseIcon from './NativeBaseIcon';

// Define the config
const config = {
  useSystemColorMode: false,
  initialColorMode: "dark",
};

// extend the theme
export const theme = extendTheme({ config });

export default function App() {
  return (
    <NativeBaseProvider>
      <Center
        _dark={{ bg: "blueGray.900" }}
        _light={{ bg: "blueGray.50" }}
        px={4}
        flex={1}
      >
        <VStack space={5} alignItems="center">
          <NativeBaseIcon />
          <Heading size="lg">Welcome to NativeBase</Heading>
          <HStack space={2} alignItems="center">
            <Text>Edit</Text>
            <Code>App.tsx</Code>
            <Text>and save to reload.</Text>
          </HStack>
          <Link href="https://docs.nativebase.io" isExternal>
            <Text color="primary.500" underline fontSize={"xl"}>
              Learn NativeBase
            </Text>
          </Link>
          <ToggleDarkMode />
        </VStack>
      </Center>
    </NativeBaseProvider>
  );
}

// Color Switch Component
function ToggleDarkMode() {
  const { colorMode, toggleColorMode } = useColorMode();
  return (
    <HStack space={2} alignItems="center">
      <Text>Dark</Text>
      <Switch
        isChecked={colorMode === "light" ? true : false}
        onToggle={toggleColorMode}
        aria-label={
          colorMode === "light" ? "switch to dark mode" : "switch to light mode"
        }
      />
      <Text>Light</Text>
    </HStack>
  );
}

\`\`\`

## portable-devices/mobile/src/components/layout/SideBar.tsx

\`\`\`tsx
import React, { useState } from 'react';
import { Container, View, Text, List, ListItem, Left, Right, Icon, Drawer } from 'native-base';
import { Link } from 'react-router-native';

const SideBar = ({ routes, matchUrl }: any) => {
    const [icon, setIcon] = useState('chevron-down-outline');
    const [isToggle, setToggle] = useState(false);

    const toggle = () => {
        if (isToggle) {
            setIcon('chevron-down-outline');
            setToggle(false);
        } else {
            setIcon('chevron-up-outline');
            setToggle(true)
        }
    }

    const isMenuExist = routes.length > 0;

    return (
        <Container style={{ backgroundColor: '#1f1f1f' }}>
            {isMenuExist && routes.map(menu => (
                menu.routes ? (
                    <List>
                        <ListItem onPress={() => toggle()}>
                            <Left>
                                <Icon style={{ color: isToggle ? '#fff' : '#a1a1a1' }} name="document-outline" />
                                <Text style={{ color: isToggle ? '#fff' : '#a1a1a1' }}>{menu.name}</Text>
                            </Left>
                            <Right>
                                <Icon name={icon} />
                            </Right>
                        </ListItem>
                        {isToggle && (menu.routes.map(subMenu => (
                            <List>
                                <ListItem>
                                    <Left>
                                        <Link to={subMenu.path} underlayColor="#f0f4f7">
                                            <Text style={{ color: '#a1a1a1' }}>{subMenu.name}</Text>
                                        </Link>
                                    </Left >
                                </ListItem >
                            </List >
                        )))}
                    </List>
                ) :
                    (<List>
                        <ListItem>
                            <Left>
                                <Link to={menu.path} underlayColor="#f0f4f7">
                                    <Text style={{ color: '#a1a1a1' }}>{menu.name}</Text>
                                </Link>
                            </Left >
                        </ListItem >
                    </List >)
            ))}
        </Container >
    )
}

export default SideBar;

\`\`\`

## portable-devices/mobile/src/components/layout/module.ts

\`\`\`ts
/* eslint-disable prettier/prettier */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { Feature } from '@common-stack/client-react';
import NativeBaseSample from './NativeBaseSample'
import Layout from './Layout';

export default new Feature({
  routeConfig: [
    {
      '/': {
        exact: true,
        component: NativeBaseSample,
      } as any,
    },
    // {
    //   '/org': {
    //     exact: false,
    //     component: Layout,
    //     key: 'layout',
    //   } as any,
    // },
  ],
});

\`\`\`

## portable-devices/mobile/src/components/layout/root-navigation.tsx

\`\`\`tsx
import React, { useRef } from 'react';

export const navigationRefs = React.createRef<any>();

export function navigate(name: any) {
    navigationRefs.current?.navigate(name);
}

\`\`\`

## portable-devices/mobile/src/config/base-apollo-client.ts

\`\`\`ts
// version 09/18/2021
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
import { ApolloClient, ApolloClientOptions, ApolloLink } from '@apollo/client';
import { InMemoryCache } from '@apollo/client/cache';
import { HttpLink, createHttpLink } from '@apollo/client/link/http';
import { BatchHttpLink } from '@apollo/client/link/batch-http';
import { onError } from '@apollo/client/link/error';
import { WebSocketLink } from '@apollo/client/link/ws';
import { getOperationAST } from 'graphql';
import { invariant } from 'ts-invariant';
import { IClientState } from '@common-stack/client-core';
import fetch from 'node-fetch';
import { ConnectionParams } from 'subscriptions-transport-ws';
import { isBoolean, merge } from 'lodash';
import { CdmLogger } from '@cdm-logger/core';
import { RetryLink } from '@apollo/client/link/retry';

const schema = `

`;

interface IApolloClientParams {
    initialState?: any;
    scope: 'browser' | 'server' | 'native';
    getDataIdFromObject: (x?: any) => string;
    clientState: IClientState;
    isDebug: boolean;
    isDev: boolean;
    isSSR: boolean;
    httpGraphqlURL: string;
    httpLocalGraphqlURL: string;
    logger: CdmLogger.ILogger;
}

const errorLink = onError(({ graphQLErrors, networkError }) => {
    if (graphQLErrors) {
        graphQLErrors.map(({ message, locations, path }) =>
            // tslint:disable-next-line
            invariant.warn(`[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`),
        );
    }
    if (networkError) {
        // tslint:disable-next-line
        invariant.warn(`[Network error]: ${networkError}`);
    }
});

let _apolloClient: ApolloClient<any>;
let _memoryCache: InMemoryCache;
export const createApolloClient = ({
    scope,
    isDev,
    isDebug,
    isSSR,
    getDataIdFromObject,
    clientState,
    httpGraphqlURL,
    httpLocalGraphqlURL,
    initialState,
    logger,
}: IApolloClientParams) => {
    const isBrowser = scope === 'browser';
    const isServer = scope === 'server';
    let link;

    const cache = new InMemoryCache({
        dataIdFromObject: getDataIdFromObject,
        possibleTypes: clientState.possibleTypes,
    });

    const attemptConditions = async (count: number, operation: any, error: Error) => {
        const promises = (clientState.retryLinkAttemptFuncs || []).map((func) => func(count, operation, error));

        try {
            const result = await promises;
            return !!result.find((item) => item && isBoolean(item));
        } catch (e) {
            logger.trace('Error occured in retryLink Attempt condition', e);
            throw e;
        }
    };

    const retrylink = new RetryLink({
        attempts: attemptConditions,
    });

    if (_apolloClient && _memoryCache) {
        // return quickly if client is already created.
        return {
            apolloClient: _apolloClient,
            cache: _memoryCache,
        };
    }
    _memoryCache = cache;
    if (isBrowser) {
        const connectionParams = async () => {
            const param: ConnectionParams = {};
            for (const connectionParam of clientState.connectionParams) {
                merge(param, await connectionParam);
            }
            return param;
        };

        const wsLink = new WebSocketLink({
            uri: httpGraphqlURL.replace(/^http/, 'ws'),
            options: {
                reconnect: true,
                timeout: 20000,
                reconnectionAttempts: 10,
                lazy: true,
                connectionParams,
                connectionCallback: async (error, result) => {
                    if (error) {
                        logger.error(error, '[WS connectionCallback error] %j');
                    }
                    const promises = (clientState.connectionCallbackFuncs || []).map((func) =>
                        func(wsLink, error, result),
                    );
                    try {
                        await promises;
                    } catch (e) {
                        logger.trace('Error occured in connectionCallback condition', e);
                        throw e;
                    }
                },
            },
            inactivityTimeout: 10000,
        });

        link = ApolloLink.split(
            ({ query, operationName }) => {
                if (operationName.endsWith('_WS')) {
                    return true;
                }
                const operationAST = getOperationAST(query as any, operationName);
                return !!operationAST && operationAST.operation === 'subscription';
            },
            wsLink,
            new HttpLink({
                uri: httpGraphqlURL,
            }),
        );
    } else if (isServer) {
        link = new BatchHttpLink({ uri: httpLocalGraphqlURL, fetch: fetch as any });
    } else {
        link = createHttpLink({ uri: httpLocalGraphqlURL, fetch: fetch as any });
    }

    const links = [errorLink, retrylink, ...(clientState.preLinks || []), link];

    // Add apollo logger during development only
    if (isBrowser && (isDev || isDebug)) {
        const apolloLogger = require('apollo-link-logger');
        links.unshift(apolloLogger.default);
    }

    const params: ApolloClientOptions<any> = {
        queryDeduplication: true,
        typeDefs: schema.concat(<string>clientState.typeDefs),
        resolvers: clientState.resolvers as any,
        link: ApolloLink.from(links),
        cache,
        connectToDevTools: isBrowser && (isDev || isDebug),
    };
    if (isSSR) {
        if (isBrowser) {
            if (initialState) {
                cache.restore(initialState);
            }
            params.ssrForceFetchDelay = 100;
        } else if (isServer) {
            params.ssrMode = true;
        }
    }
    _apolloClient = new ApolloClient<any>(params);

    clientState?.defaults?.forEach((x) => {
        if (x.type === 'query') {
            cache.writeQuery(x);
        } else if (x.type === 'fragment') {
            cache.writeFragment(x);
        }
    });

    return { apolloClient: _apolloClient, cache };
};

\`\`\`

## portable-devices/mobile/src/config/base-redux-config.ts

\`\`\`ts
// version 11/12/2021
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable global-require */
/* eslint-disable no-underscore-dangle */
import {
    createStore,
    combineReducers,
    applyMiddleware,
    StoreEnhancer,
    Middleware,
    compose,
    Action,
    ReducersMapObject,
    PreloadedState,
} from 'redux';
import { EpicMiddleware, Epic } from 'redux-observable';
import { persistReducer, PersistConfig } from 'redux-persist';

interface IReduxStore<S = any> {
    scope: 'browser' | 'server' | 'native' | 'ElectronMain';
    isDebug: boolean;
    isDev: boolean;
    reducers: ReducersMapObject<S>;
    rootEpic?: Epic<Action<S>, Action<any>, void, any>;
    epicMiddleware?: EpicMiddleware<Action<S>, Action<any>>;
    preMiddleware?: Middleware[];
    postMiddleware?: Middleware[];
    middleware?: Middleware[];
    initialState: PreloadedState<S>;
    persistConfig?: PersistConfig<S, any>;
}
/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = ({
    scope,
    isDebug,
    isDev,
    reducers,
    rootEpic,
    epicMiddleware,
    preMiddleware,
    postMiddleware,
    middleware,
    initialState = {},
    persistConfig,
}: IReduxStore<any>) => {
    const isBrowser = scope === 'browser';
    const isElectronMain = scope === 'ElectronMain';
    /**
     * Add middleware that required for this app.
     */

    const middlewares: Middleware[] = [];
    // add epicMiddleware
    if (epicMiddleware) {
        middlewares.push(epicMiddleware);
    }
    if (preMiddleware) {
        middlewares.unshift(...preMiddleware);
    }
    // Add redux logger during development only
    if ((isDev || isDebug) && isBrowser) {
        const { createLogger } = require('redux-logger');

        middlewares.push(
            createLogger({
                level: 'info',
                collapsed: true,
            }),
        );
    }

    if (middleware) {
        middlewares.push(...middleware);
    }

    if (postMiddleware) {
        middlewares.push(...postMiddleware);
    }

    const enhancers: () => StoreEnhancer<any>[] = () => [applyMiddleware(...middlewares)];

    const composeEnhancers: any =
        ((isDev || isDebug) && isBrowser && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) || compose;

    const rootReducer = combineReducers(reducers);
    const persistedReducer = persistConfig ? persistReducer(persistConfig, rootReducer) : rootReducer;

    const store = createStore(persistedReducer, initialState, composeEnhancers(...enhancers()));
    if (isBrowser || isElectronMain) {
        // no SSR for now
        if (epicMiddleware) {
            epicMiddleware.run(rootEpic);
        }
    }

    return store;
};

\`\`\`

## portable-devices/mobile/src/config/client.service.ts

\`\`\`ts
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ClientTypes } from '@common-stack/client-core';
import { Container } from 'inversify';
import { ApolloClient } from '@apollo/client';
import { CdmLogger } from '@cdm-logger/core';
import modules, { container, logger } from '../modules';
import { createApolloClient } from './base-apollo-client';
import { PUBLIC_SETTINGS } from './public-config';

let __CLIENT_SERVICE__: {
    apolloClient: ApolloClient<any>;
    container: Container;
    services: any;
    logger: CdmLogger.ILogger
};
export const createClientContainer = () => {
    if (__CLIENT_SERVICE__) {
        return __CLIENT_SERVICE__;
    }
    const clientState = modules.getStateParams({ resolverContex: () => modules.createService({}, {}) });
    const { cache, apolloClient } = createApolloClient({
        httpGraphqlURL: PUBLIC_SETTINGS.GRAPHQL_URL,
        httpLocalGraphqlURL: PUBLIC_SETTINGS.LOCAL_GRAPHQL_URL,
        isDev: process.env.NODE_ENV === 'development',
        isDebug: __DEBUGGING__,
        isSSR: __SSR__,
        scope: 'browser',
        clientState,
        getDataIdFromObject: (result) => modules.getDataIdFromObject(result),
        initialState: null,
        logger,
    });
    // attaching the context to client as a workaround.
    container.bind(ClientTypes.ApolloClient).toConstantValue(apolloClient);
    container.bind(ClientTypes.InMemoryCache).toConstantValue(cache);
    const services = modules.createService({}, {});
    (apolloClient as any).container = services;

    __CLIENT_SERVICE__ = {
        container,
        apolloClient,
        services,
        logger,
    };
    return __CLIENT_SERVICE__;
};

\`\`\`

## portable-devices/mobile/src/config/config.ts

\`\`\`ts

\`\`\`

## portable-devices/mobile/src/config/epic-config.ts

\`\`\`ts
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-call */
import { combineEpics, ofType } from 'redux-observable';
import { BehaviorSubject } from 'rxjs';
import { mergeMap, takeUntil } from 'rxjs/operators';
import modules from '../modules';

export const epic$ = new BehaviorSubject(combineEpics(...modules.epics));

// Since we're using mergeMap, by default any new
// epic that comes in will be merged into the previous
// one, unless an EPIC_END action is dispatched first,
// which would cause the old one(s) to be unsubscribed
export const rootEpic = (action$, ...rest) =>
    epic$.pipe(mergeMap((epic) => epic(action$, ...rest).pipe(takeUntil(action$.pipe(ofType('EPIC_END'))))));

\`\`\`

## portable-devices/mobile/src/config/fela-renderer.ts

\`\`\`ts
import { createRenderer, IRenderer } from 'fela';
import webPreset from 'fela-preset-web';

export default () => {
    const renderer = createRenderer({
        plugins: [...webPreset],
        devMode: process.env.NODE_ENV ? process.env.NODE_ENV !== 'production' : false,
    });
    renderer.renderStatic(
        `
        html, body, #demo, .content{
            height: 100%;
          }
          body {
            background-color: #fff;
            color: #ccc;
            padding: 0;
            margin: 0;
            font-family: sans-serif;
            font-size: 13px;
          }
          div, a {
            outline: none !important;
          }
          a {
            text-decoration: none;
            cursor: pointer;
          }
          footer {
            position:fixed;
            bottom: 0;
            left: 0;
            right:0;
            height: 20px;
            background: #007acc;
          }
          footer > .container {
            padding: 2px;
          }
          #content {
            height: calc(100vh - 20px);
          }
          #container {
            height: 100%;
          }
          .editor-container {
            height: 100%;
            overflow: hidden;
          }
          .error {
            color: orangered;
          }
        `,
    );

    return renderer;
};

\`\`\`

## portable-devices/mobile/src/config/index.ts

\`\`\`ts
import { LOG_LEVEL } from '@env';

const config = {
    LOG_LEVEL,
};

export default config;

\`\`\`

## portable-devices/mobile/src/config/public-config.ts

\`\`\`ts
import { NODE_ENV, GRAPHQL_URL, FACEBOOK_APP_ID, GA_ID, LOG_LEVEL } from '@env';

const env = {
    NODE_ENV,
    GRAPHQL_URL,
    FACEBOOK_APP_ID,
    GA_ID,
    LOG_LEVEL,
    LOCAL_GRAPHQL_URL: GRAPHQL_URL,
    $typeof: 'null', // bug https://github.com/af/envalid/issues/150
};

const isBrowser = typeof window !== 'undefined';

export default env;

if (isBrowser) {
    // process.env = env;
    process.APP_ENV = env;
}

export const PUBLIC_SETTINGS: __PUBLIC_SETTINGS__ = {
    apolloLogging: false,
    GRAPHQL_URL: env.GRAPHQL_URL,
    LOCAL_GRAPHQL_URL: env.LOCAL_GRAPHQL_URL,
    LOG_LEVEL: env.LOG_LEVEL || 'trace',
};

\`\`\`

## portable-devices/mobile/src/config/redux-config.ts

\`\`\`ts
import storage from '@react-native-async-storage/async-storage';
import autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2';
import { createEpicMiddleware } from 'redux-observable';
import { connectRouter, routerMiddleware } from 'connected-react-router';
import { createReduxStore as createBaseReduxStore } from './base-redux-config';
import modules, { logger } from '../modules';
import { rootEpic } from './epic-config';
import history from './router-history';
import { createClientContainer } from './client.service';

export { history };
const { apolloClient, container, services } = createClientContainer();

export const epicMiddleware = createEpicMiddleware({
    dependencies: {
        apolloClient,
        routes: modules.getConfiguredRoutes(),
        services,
        container,
        logger,
    },
});

export const persistConfig = {
    key: 'root',
    storage,
    stateReconciler: autoMergeLevel2,
    transforms: modules.reduxPersistStateTransformers,
};

/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = () => {
    // middleware
    const router = connectRouter(history);

    const store = createBaseReduxStore({
        scope: 'browser',
        isDebug: __DEBUGGING__,
        isDev: process.env.NODE_ENV === 'development',
        initialState: {},
        persistConfig,
        middleware: [routerMiddleware(history)],
        epicMiddleware,
        rootEpic: rootEpic as any,
        reducers: { router, ...modules.reducers },
    });
    container.bind('ReduxStore').toConstantValue(store);

    return store;
};

\`\`\`

## portable-devices/mobile/src/config/router-history.ts

\`\`\`ts
import { createMemoryHistory } from 'history';

const hist = createMemoryHistory();

export default hist;

\`\`\`

## portable-devices/mobile/src/constants/Colors.ts

\`\`\`ts
const tintColorLight = '#2f95dc';
const tintColorDark = '#fff';

export default {
    light: {
        text: '#000',
        background: '#fff',
        tint: tintColorLight,
        tabIconDefault: '#ccc',
        tabIconSelected: tintColorLight,
    },
    dark: {
        text: '#fff',
        background: '#000',
        tint: tintColorDark,
        tabIconDefault: '#ccc',
        tabIconSelected: tintColorDark,
    },
};

\`\`\`

## portable-devices/mobile/src/constants/Layout.ts

\`\`\`ts
import { Dimensions } from 'react-native';

const { width } = Dimensions.get('window');
const { height } = Dimensions.get('window');

export default {
    window: {
        width,
        height,
    },
    isSmallDevice: width < 375,
};

\`\`\`

## portable-devices/mobile/src/hooks/useCachedResources.ts

\`\`\`ts
import { Ionicons } from '@expo/vector-icons';
import * as Font from 'expo-font';
import * as SplashScreen from 'expo-splash-screen';
import * as React from 'react';

export default function useCachedResources() {
    const [isLoadingComplete, setLoadingComplete] = React.useState(false);

    // Load any resources or data that we need prior to rendering the app
    React.useEffect(() => {
        async function loadResourcesAndDataAsync() {
            try {
                SplashScreen.preventAutoHideAsync();

                // Load fonts
                await Font.loadAsync({
                    ...Ionicons.font,
                    'space-mono': require('../assets/fonts/SpaceMono-Regular.ttf'),
                });
            } catch (e) {
                // We might want to provide this error information to an error reporting service
                console.warn(e);
            } finally {
                setLoadingComplete(true);
                SplashScreen.hideAsync();
            }
        }

        loadResourcesAndDataAsync();
    }, []);

    return isLoadingComplete;
}

\`\`\`

## portable-devices/mobile/src/hooks/useColorScheme.ts

\`\`\`ts
import { ColorSchemeName, useColorScheme as _useColorScheme } from 'react-native';

// The useColorScheme value is always either light or dark, but the built-in
// type suggests that it can be null. This will not happen in practice, so this
// makes it a bit easier to work with.
export default function useColorScheme(): NonNullable<ColorSchemeName> {
    return _useColorScheme();
}

\`\`\`

## portable-devices/mobile/src/hooks/useColorScheme.web.ts

\`\`\`ts
// useColorScheme from react-native does not support web currently. You can replace
// this with react-native-appearance if you would like theme support on web.
export default function useColorScheme() {
    return 'light';
}

\`\`\`

## portable-devices/mobile/src/modules/index.ts

\`\`\`ts
/* eslint-disable import/no-cycle */
/* eslint-disable @typescript-eslint/no-var-requires */
import { ClientTypes } from '@common-stack/client-react';
import { logger } from '@cdm-logger/client';
import modules, { MainRoute } from './modules';

Object.assign(global, require('../../build.config'));


class UtilityClass {
    // tslint:disable-next-line:no-shadowed-variable
    constructor(private modules) {}

    public getCacheKey(storeObj) {
        return this.modules.getDataIdFromObject(storeObj);
    }
}

const utility = new UtilityClass(modules);
// additional bindings to container
const container = modules.createContainers({}) as any;
container.bind(ClientTypes.Logger).toConstantValue(logger);
container.bind(ClientTypes.UtilityClass).toConstantValue(utility);

export default modules;
export { MainRoute, container, logger };

\`\`\`

## portable-devices/mobile/src/modules/modules.tsx

\`\`\`tsx
import * as React from 'react';
import { Feature, FeatureWithRouterFactory } from '@common-stack/client-react';
import counterModule from '@sample-stack/counter-module-mobile';
import { StatusBar } from 'expo-status-bar';
import { enableScreens } from 'react-native-screens';
import { Route } from 'react-router-native';
import LayoutModule from '../components/layout/module';
import { renderRoutes2 } from './render';

const features = new Feature(FeatureWithRouterFactory, LayoutModule, counterModule);
const configuredRoutes = features.getConfiguredRoutes();
const routes = renderRoutes2({ routes: configuredRoutes }) || [];
enableScreens();

export const MainRoute = () => {
  /**
   * when used renderRoutes2 opts.routes come as empty need to debug that
   * for now using switch directly inroder to render routes properly.
   */
  return (
    <>
      {routes}
    </>
  );
};

export default features;

\`\`\`

## portable-devices/mobile/src/modules/render.tsx

\`\`\`tsx
import * as React from 'react';
import { useEffect, useState, createElement } from 'react';
// import { Plugin, ApplyPluginsType } from '@umijs/runtime';
import { IRoute, IComponent } from '@common-stack/client-react';
import { Switch, Route, Redirect } from 'react-router-native';

interface IOpts {
  routes: IRoute[];
  plugin?: Plugin;
  extraProps?: object;
  pageInitialProps?: object;
  getInitialPropsCtx?: object;
  isServer?: boolean;
  ssrProps?: object;
  rootRoutes?: IRoute[];
}

interface IGetRouteElementOpts {
  route: IRoute;
  index: number;
  opts: IOpts;
}

function wrapInitialPropsFetch(route: IRoute, opts: IOpts): IComponent {
  const { component, ...restRouteParams } = route;
  let Component: any = route.component;
  function ComponentWithInitialPropsFetch(props: any) {
    const [initialProps, setInitialProps] = useState(() => (window as any).g_initialProps);

    useEffect(() => {
      /**
       * 1. 首次渲染时，此时 window.g_initialProps 变量存在，不需要再走一次 getInitialProps，这样一次 SSR 就走了 2 次 getInitialProps
       * 2. 但是路由切换时，window.getInitialProps 会被赋为 null，这时候就走 getInitialProps 逻辑
       * 3. 如果任何时候都走 2 次，配置 forceInitial: true，这个场景用于静态站点的首屏加载希望走最新数据
       * 4. 开启动态加载后，会在执行 getInitialProps 前预加载下
       */
      const handleGetInitialProps = async () => {
        // preload when enalbe dynamicImport
        if (Component.preload) {
          const preloadComponent = await Component.preload();
          // for test case, really use .default
          Component = preloadComponent.default || preloadComponent;
        }

        // @sri not suppported
        // const defaultCtx = {
        //   isServer: false,
        //   match: props?.match,
        //   route,
        //   ...(opts.getInitialPropsCtx || {}),
        //   ...restRouteParams,
        // };
        // @sri not suppported
        // if (Component?.getInitialProps) {
        //   const ctx = await opts.plugin.applyPlugins({
        //     key: 'ssr.modifyGetInitialPropsCtx',
        //     type: ApplyPluginsType.modify,
        //     initialValue: defaultCtx,
        //     async: true,
        //   });

        //   const initialProps = await Component!.getInitialProps!(
        //     ctx || defaultCtx,
        //   );
        //   setInitialProps(initialProps);
        // }
      };
      // null 时，一定会触发 getInitialProps 执行
      if (!(window as any).g_initialProps) {
        handleGetInitialProps();
      }
    }, [window.location.pathname, window.location.search]);
    return <Component {...props} {...initialProps} />;
  }
  // flag for having wrappered
  ComponentWithInitialPropsFetch.wrapInitialPropsLoaded = true;
  ComponentWithInitialPropsFetch.displayName = 'ComponentWithInitialPropsFetch';
  return ComponentWithInitialPropsFetch;
}

function render({ route, opts, props }: { route: IRoute; opts: IOpts; props: object }) {
  const routes = renderRoutes({
    ...opts,
    routes: route.routes || [],
    rootRoutes: opts.rootRoutes,
  });
  const { component: Component, wrappers } = route;
  if (Component) {
    const defaultPageInitialProps = opts.isServer ? {} : (window as any).g_initialProps;
    const newProps = {
      ...props,
      ...opts.extraProps,
      ...(opts.pageInitialProps || defaultPageInitialProps),
      route,
      routes: opts.rootRoutes,
    };
    // @ts-ignore
    let ret = <Component {...newProps}>{routes}</Component>;

    // route.wrappers
    if (wrappers) {
      let len = wrappers.length - 1;
      while (len >= 0) {
        ret = createElement(wrappers[len], newProps, ret);
        len -= 1;
      }
    }

    return ret;
  }
  return routes;
}

function getRouteElement({ route, index, opts }: IGetRouteElementOpts) {
  const routeProps = {
    key: route.key || index,
    exact: route.exact,
    strict: route.strict,
    sensitive: route.sensitive,
    path: route.path,
  };
  if (route.redirect) {
    return <Redirect {...routeProps} from={route.path} to={route.redirect} />;
  }
  // avoid mount and unmount with url hash change
  // @sri not supproted yet
  // if (
  //   // only when SSR config enable
  //   opts.ssrProps &&
  //   !opts.isServer &&
  //   // make sure loaded once
  //   !(route.component as any)?.wrapInitialPropsLoaded &&
  //   (route.component?.getInitialProps || route.component?.preload)
  // ) {
  //   // client Render for enable ssr, but not sure SSR success
  //   route.component = wrapInitialPropsFetch(route, opts);
  // }
  return (
    <Route
      {...routeProps}
      render={(props: object) => {
        return render({ route, opts, props });
      }}
    />
  );
}

function renderRoutes(opts: IOpts) {
  return opts.routes ? (
    <Switch>
      {opts.routes.map((route, index) => {
        const renderedR = getRouteElement({
          route,
          index,
          opts: {
            ...opts,
            rootRoutes: opts.rootRoutes || opts.routes,
          },
        });
        return renderedR;
      })}
    </Switch>
  ) : null;
}

export { renderRoutes as renderRoutes2 };

\`\`\`

## portable-devices/mobile/src/pages/dashboard.tsx

\`\`\`tsx
import React from "react"
import {StyleSheet, View, Text, ViewStyle} from "react-native"
import { Link } from 'react-router-native';
interface Style {
    container: ViewStyle
}

const Dashboard = () => {
    return(
        <View style={styles.container}>
            <Text>Dashboard Value</Text>
            <Link to={'/org/counter'}><Text>Calendar</Text></Link>
        </View>
    )
}

const styles = StyleSheet.create<Style>({
    container:{
        textAlign: 'center'
    }
})

export default Dashboard;

\`\`\`

## portable-devices/mobile/src/pages/hello.tsx

\`\`\`tsx
import React from 'react';
import { StyleSheet, View, Text, ViewStyle } from 'react-native';
import { Footer, Content } from 'native-base';
import { connect } from 'react-redux';

interface Style {
    container: ViewStyle;
}

const HelloScreen = () => {
    return (
        <View style={styles.container}>
            <Content>
                <Text>Hello Value</Text>
            </Content>
            <Footer style={{ position: 'absolute', left: 0, right: 0, bottom: 0 }}>
                <View>
                    <Text>Footer will be here</Text>
                </View>
            </Footer>
        </View>
    );
};

const styles = StyleSheet.create<Style>({
    container: {
        flex: 1,
        textAlign: 'center',
    },
});

const Hello = connect((state: any) => {
    return {
        settings: state.settings,
        location: state?.route?.location,
    };
})(HelloScreen);

export default Hello;

\`\`\`

## portable-devices/mobile/src/pages/index.ts

\`\`\`ts
import Dashboard from './dashboard';
import Hello from './hello';

export { Dashboard, Hello };

\`\`\`

## portable-devices/mobile/src/screens/NotFoundScreen.tsx

\`\`\`tsx
import { StackScreenProps } from '@react-navigation/stack';
import * as React from 'react';
import { StyleSheet, Text, TouchableOpacity, View } from 'react-native';

import { RootStackParamList } from '../types';

export default function NotFoundScreen({
  navigation,
}: StackScreenProps<RootStackParamList, 'NotFound'>) {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>This screen doesn't exist.</Text>
      <TouchableOpacity onPress={() => navigation.replace('Root')} style={styles.link}>
        <Text style={styles.linkText}>Go to home screen!</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
  linkText: {
    fontSize: 14,
    color: '#2e78b7',
  },
});

\`\`\`

## portable-devices/mobile/tsconfig.json

\`\`\`json
{
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "jsx": "react-native",
    "lib": [
      "dom",
      "esnext"
    ],
    "moduleResolution": "node",
    "noEmit": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "strict": true
  },
  "extends": "expo/tsconfig.base"
}

\`\`\`

## portable-devices/mobile/types.tsx

\`\`\`tsx
export type RootStackParamList = {
  Root: undefined;
  NotFound: undefined;
};

export type BottomTabParamList = {
  TabOne: undefined;
  TabTwo: undefined;
};

export type TabOneParamList = {
  TabOneScreen: undefined;
};

export type TabTwoParamList = {
  TabTwoScreen: undefined;
};

\`\`\`

## portable-devices/mobile/webpack.config.js

\`\`\`js
const webpack = require('webpack');
const path = require('path');
const createExpoWebpackConfigAsync = require('@expo/webpack-config');

module.exports = async function (env, argv) {
    const config = await createExpoWebpackConfigAsync(env, argv);

    config.module.rules.push(
        {
            test: /\.js$/,
            loader: 'babel-loader',
            include: [path.join(__dirname, 'node_modules/react-router-native')],
        },
        {
            test: /\.js$/,
            loader: 'babel-loader',
            include: [path.join(__dirname, '../../node_modules/react-router-native')],
        },
    );
    config.plugins.push(
        new webpack.DefinePlugin({
            __CLIENT__: true,
            __DEBUGGING__: false,
        }),
    );
    return config;
};

\`\`\`

## prettier.config.js

\`\`\`js
module.exports = {
    bracketSpacing: true,
    printWidth: 120,
    singleQuote: true,
    tabWidth: 4,
    trailingComma: 'all',
    endOfLine: 'lf',
};

\`\`\`

## servers/backend-server/.zenrc.js

\`\`\`js
const url = require('url');
const path = require('path');
var nodeExternals = require('webpack-node-externals');
const CopyWebpackPlugin = require('copy-webpack-plugin');

const config = {
    builders: {
        server: {
            entry: './src/index.ts',
            stack: ['server'],
            tsLoaderOptions: {
                // "configFile": "./tsconfig.json"
            },
            defines: {
                __SERVER__: true
            },
            enabled: true,
            webpackConfig: {
                output: {
                    filename: 'main.js',
                    sourceMapFilename: '[file].map',
                },
                plugins: [
                    new CopyWebpackPlugin({
                        patterns: [{
                            from: '../../tools/esm-wrapper.js',
                            to: 'index.js',
                        }],
                    }),
                ],
                externals: [
                    nodeExternals({}),
                    nodeExternals({ allowlist: [/webpack\/hot/i], modulesDir: "../../node_modules" })
                ],
            }
        },
        test: {
            stack: ['server'],
            roles: ['test'],
            defines: {
                __TEST__: true
            }
        }
    },
    options: {
        stack: [
            'ts',
            "apollo",
            'webpack'
        ],
        cache: '../../.cache',
        ssr: false,
        backendBuildDir: "dist",
        frontendBuildDir: "dist",
        dllBuildDir: "dist/.build/dll",
        webpackDll: false,
        persistGraphQL: false,
        backendUrl: "http://{ip}:8080",
        frontendRefreshOnBackendChange: true,
        nodeDebugger: false,
        defines: {
            __DEV__: process.env.NODE_ENV !== 'production',
            __GRAPHQL_URL__: '"http://localhost:8080/graphql"',
        },

    }
};

config.options.devProxy = config.options.ssr;

if (process.env.NODE_ENV === 'test') {
}
if (process.env.NODE_ENV === 'production') {
    // Generating source maps for production will slowdown compilation for roughly 25%
    config.options.sourceMap = false;
}

const extraDefines = {
    __SSR__: config.options.ssr,
    __PERSIST_GQL__: config.options.persistGraphQL,
    __FRONTEND_BUILD_DIR__: `"../frontend-server/dist/web"`,
    __DLL_BUILD_DIR__: `"../frontend-server/dist/build/dll"`
};

config.options.defines = Object.assign(config.options.defines, extraDefines);

module.exports = config;

\`\`\`

## servers/backend-server/knexfile.js

\`\`\`js
// Update with your config settings.
var path = require('path');
require('dotenv').config({ path: process.env.ENV_FILE });

var connection = {
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  socketPath: process.env.DB_SOCKET_PATH,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
  multipleStatements: true,
  charset: 'utf8',
};
var DB_CLIENT = process.env.DB_TYPE || 'sqlite3';

var migrations_path = path.dirname(require.resolve('@sample-stack/store/lib/store/migrations/index'));
var seeds_path = path.dirname(require.resolve('@sample-stack/store/lib/store/seeds/index'));
module.exports = {

  development: {
    client: 'sqlite3',
    connection: {
      filename: './dev-db.sqlite3'
    },
    seeds: {
      directory: seeds_path,
    },
    migrations: {
      directory: migrations_path,
    },
    useNullAsDefault: true,
  },

  test: {
    client: DB_CLIENT,
    connection: connection,
    pool: {
      min: 2,
      max: 10
    },
    seeds: {
      directory: seeds_path,
    },
    migrations: {
      directory: migrations_path,
    },
    useNullAsDefault: true,
  },

  production: {
    client: DB_CLIENT,
    connection: connection,
    pool: {
      min: 2,
      max: 200
    },
    migrations: {
      directory: migrations_path,
    },
    useNullAsDefault: true,
  }

};

\`\`\`

## servers/backend-server/src/api/remote-config.ts

\`\`\`ts
interface ISchemaConfig {
    uri: string;
    wsUri: string;
}

export const remoteSchemaDetails: ISchemaConfig[] = [
    // {
    // uri: 'http://localhost:8085/graphql',
    // wsUri: 'ws://localhost:8085/graphql',
    // },
];

\`\`\`

## servers/backend-server/src/api/resolver.ts

\`\`\`ts
import GraphQLJSON, { GraphQLJSONObject } from 'graphql-type-json';

export const resolvers = {
    JSON: GraphQLJSON,
    JSONObject: GraphQLJSONObject,
};

\`\`\`

## servers/backend-server/src/api/scalar.ts

\`\`\`ts
// add any scalar types
import { GraphQLError, GraphQLScalarType, Kind } from 'graphql';

// https://stackoverflow.com/questions/41557536/custom-map-keys-in-graphql-response
export const GraphQLAnyObject = new GraphQLScalarType({
    name: 'AnyObject',
    description: 'Any JSON object. This type bypasses type checking.',
    serialize: (value) => value,
    parseValue: (value) => value,
    parseLiteral: (ast) => {
        if (ast.kind !== Kind.OBJECT) {
            throw new GraphQLError(`Query error: Can only parse object but got a: ${ast.kind}`, [ast]);
        }
        return ast.fields;
    },
});

\`\`\`

## servers/backend-server/src/config/config.ts

\`\`\`ts
/// <reference path='../../../../typings/index.d.ts' />
import * as envalid from 'envalid';

const { str, bool, json } = envalid;

export const config = envalid.cleanEnv(process.env, {
    NODE_ENV: str({ default: 'production', choices: ['production', 'staging', 'development', 'test'] }),
    NATS_URL: str(),
    NATS_USER: str(),
    NATS_PW: str(),
    MONGO_URL: str(),
    LOG_LEVEL: str({ default: 'info', devDefault: 'trace', choices: ['info', 'debug', 'trace'] }),
    REDIS_CLUSTER_URL: json({
        devDefault: '[{"port":6379,"host":"localhost"}]',
        example: '[{"port":6379,"host":"localhost"}]',
    }),
    REDIS_URL: str({ devDefault: 'localhost' }),
    REDIS_CLUSTER_ENABLED: bool({ devDefault: false }),
    REDIS_SENTINEL_ENABLED: bool({ devDefault: true }),
    HEMERA_LOG_LEVEL: str({ default: 'info' }),
    BACKEND_URL: str({ devDefault: __BACKEND_URL__ }),
    GRAPHQL_URL: str({ devDefault: __GRAPHQL_URL__ }),
    CLIENT_URL: str({ devDefault: __BACKEND_URL__ }),
    CONNECTION_ID: str({ devDefault: 'CONNECTION_ID' }),
    NAMESPACE: str({ default: 'default' }),
    apolloLogging: bool({ default: false, devDefault: true }),
    API_NAMESPACE: str({ devDefault: 'default' }),
    ADMIN_API_NAMESPACE: str({ devDefault: 'default' }),
});

\`\`\`

## servers/backend-server/src/config/index.ts

\`\`\`ts
export * from './config';

\`\`\`

## servers/backend-server/src/config/moleculer.config.ts

\`\`\`ts
/* eslint-disable @typescript-eslint/no-empty-function */
import { BrokerOptions, Errors } from 'moleculer';
import { config } from './config';

/**
 * Moleculer ServiceBroker configuration file
 *
 * More info about options:
 *         https://moleculer.services/docs/0.14/configuration.html
 *
 *
 * Overwrite options in production:
 * ================================
 * 	You can overwrite any option with environment variables.
 * 	For example to overwrite the 'logLevel', use `LOGLEVEL=warn` env var.
 * 	To overwrite a nested parameter, e.g. retryPolicy.retries, use `RETRYPOLICY_RETRIES=10` env var.
 *
 * 	To overwrite broker’s deeply nested default options, which are not presented in 'moleculer.config.ts',
 * 	via environment variables, use the `MOL_` prefix and double underscore `__` for nested properties in .env file.
 * 	For example, to set the cacher prefix to `MYCACHE`, you should declare an env var as `MOL_CACHER__OPTIONS__PREFIX=MYCACHE`.
 */
const brokerConfig: BrokerOptions = {
    // Namespace of nodes to segment your nodes on the same network.
    namespace: config.NAMESPACE,
    // namespace: null,
    // Unique node identifier. Must be unique in a namespace.
    // nodeID: config.CONNECTION_ID,

    // Enable/disable logging or use custom logger. More info: https://moleculer.services/docs/0.14/logging.html
    // Available logger types: 'Console', 'File', 'Pino', 'Winston', 'Bunyan', 'debug', 'Log4js', 'Datadog'
    logger: {
        type: 'Console',
        options: {
            // Using colors on the output
            colors: true,
            // Print module names with different colors (like docker-compose for containers)
            moduleColors: false,
            // Line formatter. It can be 'json', 'short',
            // 'simple', 'full', a `Function` or a template string like '{timestamp} {level} {nodeID}/{mod}: {msg}'
            formatter: 'full',
            // Custom object printer. If not defined, it uses the `util.inspect` method.
            objectPrinter: null,
            // Auto-padding the module name in order to messages begin at the same column.
            autoPadding: false,
        },
    },
    // Default log level for built-in console logger. It can be overwritten in logger options above.
    // Available values: trace, debug, info, warn, error, fatal
    logLevel: config.LOG_LEVEL as any,

    // Define transporter.
    // More info: https://moleculer.services/docs/0.14/networking.html
    // Note: During the development, you don't need to define it because all services will be loaded locally.
    // In production you can set it via `TRANSPORTER=nats://localhost:4222` environment variable.
    transporter:
        config.NODE_ENV === 'development'
            ? 'TCP'
            : {
                  type: 'NATS',
                  options: {
                      url: config.NATS_URL,
                      user: config.NATS_USER,
                      pass: config.NATS_PW,
                      reconnectTimeWait: 1000,
                  },
              },

    // Define a cacher.
    // More info: https://moleculer.services/docs/0.14/caching.html
    // cacher: {
    //     type: 'Redis',
    //     enabled: false,
    //     options: {

    //         // Redis settings
    //         redis: {

    //         }
    //     }
    // },

    // Define a serializer.
    // Available values: 'JSON', 'Avro', 'ProtoBuf', 'MsgPack', 'Notepack', 'Thrift'.
    // More info: https://moleculer.services/docs/0.13/networking.html
    serializer: 'JSON',

    // Number of milliseconds to wait before reject a request with a RequestTimeout error. Disabled: 0
    requestTimeout: 10 * 1000,

    // Retry policy settings. More info: https://moleculer.services/docs/0.13/fault-tolerance.html#Retry
    retryPolicy: {
        // Enable feature
        enabled: false,
        // Count of retries
        retries: 5,
        // First delay in milliseconds.
        delay: 100,
        // Maximum delay in milliseconds.
        maxDelay: 1000,
        // Backoff factor for delay. 2 means exponential backoff.
        factor: 2,
        // A function to check failed requests.
        check: (err: Errors.MoleculerRetryableError) => err && !!err.retryable,
    },

    // Limit of calling level. If it reaches the limit, broker will throw an MaxCallLevelError error. (Infinite loop protection)
    maxCallLevel: 100,

    // Number of seconds to send heartbeat packet to other nodes.
    heartbeatInterval: 5,
    // Number of seconds to wait before setting node to unavailable status.
    heartbeatTimeout: 15,

    // tslint:disable-next-line:max-line-length
    // Tracking requests and waiting for running requests before shutdowning. More info: https://moleculer.services/docs/0.13/fault-tolerance.html
    tracking: {
        // Enable feature
        enabled: false,
        // Number of milliseconds to wait before shutdowning the process
        shutdownTimeout: 5000,
    },

    // Disable built-in request & emit balancer. (Transporter must support it, as well.)
    disableBalancer: false,

    // Settings of Service Registry. More info: https://moleculer.services/docs/0.14/registry.html
    registry: {
        // Define balancing strategy. More info: https://moleculer.services/docs/0.14/balancing.html
        // Available values: 'RoundRobin', 'Random', 'CpuUsage', 'Latency'
        strategy: 'RoundRobin',
        // Enable local action call preferring.
        preferLocal: true,
    },

    // Settings of Circuit Breaker. More info: https://moleculer.services/docs/0.14/fault-tolerance.html#Circuit-Breaker
    circuitBreaker: {
        // Enable feature
        enabled: false,
        // Threshold value. 0.5 means that 50% should be failed for tripping.
        threshold: 0.5,
        // Minimum request count. Below it, CB does not trip.
        minRequestCount: 20,
        // Number of seconds for time window.
        windowTime: 60,
        // Number of milliseconds to switch from open to half-open state
        halfOpenTime: 10 * 1000,
        // A function to check failed requests.
        check: (err: Errors.MoleculerRetryableError) => err && err.code >= 500,
    },

    // Settings of bulkhead feature. More info: https://moleculer.services/docs/0.14/fault-tolerance.html#Bulkhead
    bulkhead: {
        // Enable feature.
        enabled: false,
        // Maximum concurrent executions.
        concurrency: 10,
        // Maximum size of queue
        maxQueueSize: 100,
    },

    // Enable action & event parameter validation. More info: https://moleculer.services/docs/0.14/validating.html
    validator: true,

    errorHandler: null,

    // Enable/disable built-in metrics function. More info: https://moleculer.services/docs/0.14/metrics.html
    metrics: {
        enabled: false,
        // Available built-in reporters: 'Console', 'CSV', 'Event', 'Prometheus', 'Datadog', 'StatsD'
        reporter: {
            type: 'Prometheus',
            options: {
                // HTTP port
                port: 3030,
                // HTTP URL path
                path: '/metrics',
                // Default labels which are appended to all metrics labels
                defaultLabels: (registry) => ({
                    namespace: registry.broker.namespace,
                    nodeID: registry.broker.nodeID,
                }),
            },
        },
    },

    // Enable built-in tracing function. More info: https://moleculer.services/docs/0.14/tracing.html
    tracing: {
        enabled: true,
        // Available built-in exporters: 'Console', 'Datadog', 'Event', 'EventLegacy', 'Jaeger', 'Zipkin'
        exporter: {
            type: 'Console', // Console exporter is only for development!
            options: {
                // Custom logger
                logger: null,
                // Using colors
                colors: true,
                // Width of row
                width: 100,
                // Gauge width in the row
                gaugeWidth: 40,
            },
        },
    },

    // Register internal services ('$node'). More info: https://moleculer.services/docs/0.13/services.html#Internal-services
    internalServices: true,
    // Register internal middlewares. More info: https://moleculer.services/docs/0.13/middlewares.html#Internal-middlewares
    internalMiddlewares: true,

    // Watch the loaded services and hot reload if they changed.
    // You can also enable it in Moleculer Runner with `--hot` argument
    hotReload: false,

    // Register custom middlewares
    middlewares: [],

    // Called after broker created.
    created(broker) {},

    // Called after broker starte.
    started(broker) {},

    // Called after broker stopped.
    stopped(broker) {},

    // Register custom REPL commands.
    replCommands: null,
};

export = brokerConfig;

\`\`\`

## servers/backend-server/src/connectors/connection-broker.ts

\`\`\`ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-unused-expressions */
/* eslint-disable no-underscore-dangle */

import { Transporter, GenericObject } from 'moleculer';
import { CdmLogger } from '@cdm-logger/core';
import { MongoConnector } from './mongo-connector';
import { NatsConnector } from './nats-connector';
import { RedisConnector } from './redis-connector';
import { config } from '../config';
import { GraphqlPubSubConnector } from './graphql-pubsub-connector';

type ILogger = CdmLogger.ILogger;

/**
 *  Connection broker class
 *
 * @class ConnectionBroker
 */
export class ConnectionBroker {
    private _mongoConnector: MongoConnector;

    private _redisConnector: RedisConnector;

    private _natsConnector: NatsConnector;

    private _graphqlPubsubConnector: GraphqlPubSubConnector;

    /**
     * Creates an instance of ConnectionBroker.
     * @param {*} options
     * @memberof ConnectionBroker
     */
    constructor(transporter: string | GenericObject, logger: ILogger) {
        if (typeof transporter === 'string') {
            if (transporter === 'TCP') {
                this._graphqlPubsubConnector = new GraphqlPubSubConnector({ logger, type: 'TCP' });
            } else if (transporter === 'NATS') {
                this._natsConnector = new NatsConnector({});
                this._graphqlPubsubConnector = new GraphqlPubSubConnector({
                    logger,
                    type: 'NATS',
                    client: this._natsConnector,
                });
            }
        } else if (transporter.type === 'NATS') {
            this._natsConnector = new NatsConnector(transporter.options);
            this._graphqlPubsubConnector = new GraphqlPubSubConnector({
                logger,
                ...transporter,
                client: this._natsConnector,
            });
        }

        this._mongoConnector = new MongoConnector(config.MONGO_URL);
        this._redisConnector = new RedisConnector(); // TODO pass constructor options
    }

    public get mongoConnection() {
        return this._mongoConnector.connect();
    }

    public get redisDataloaderClient() {
        return this._redisConnector.getRedisDataloaderClient();
    }

    public get natsConnection() {
        return this._natsConnector.connect();
    }

    public get graphqlPubsub() {
        return this._graphqlPubsubConnector.getClient();
    }

    public async stop() {
        this._mongoConnector && (await this._mongoConnector.disconnect());
        this._redisConnector && (await this._redisConnector.disconnect());
        this._natsConnector && (await this._natsConnector.disconnect());
    }
}

\`\`\`

## servers/backend-server/src/connectors/graphql-pubsub-connector.ts

\`\`\`ts
/* eslint-disable no-return-assign */
import { PubSub, PubSubEngine } from 'graphql-subscriptions';
import { NatsPubSub } from 'graphql-nats-subscriptions';
import { wrapPubSub } from 'apollo-logger';
import { logger } from '@cdm-logger/server';
import { GenericObject } from 'moleculer';
import { CdmLogger } from '@cdm-logger/core';

type ILogger = CdmLogger.ILogger;

type PubSubOptions = {
    apolloLogging?: boolean;
    logger: ILogger;
} & GenericObject;

export class GraphqlPubSubConnector {
    private client: PubSubEngine | NatsPubSub;

    private opts: PubSubOptions;

    private logger: ILogger;

    /**
     * Creates an instance of GraphqlPubSubConnector.
     * @param {*} opts
     * @memberof GraphqlPubSubConnector
     */
    constructor(opts?: PubSubOptions) {
        if (opts === undefined || opts.type === undefined) {
            this.opts = { ...opts, apolloLogging: true, type: 'TCP' };
        }
        this.opts = opts;
        this.logger = opts.logger.child({ className: 'GraphqlPubSubConnector' });
    }

    public async getClient() {
        if (this.opts.type === 'TCP') {
            if (this.opts.apolloLogging) {
                return (this.client = wrapPubSub(new PubSub(), { logger: this.logger.trace.bind(this.logger) }));
            }
            return (this.client = new PubSub());
        }
        if (this.opts.type === 'NATS') {
            // console.log('--this.copts', this.opts.client)
            const natsClient = await this.opts.client.connect();
            return (this.client = new NatsPubSub({ client: natsClient, logger }));
        }
        this.logger.warn('Did not defined known transporter [%s], return default pubsub', this.opts.type);
        return (this.client = new PubSub());
    }
}

\`\`\`

## servers/backend-server/src/connectors/mongo-connector.ts

\`\`\`ts
import { createConnection, connection, ConnectionOptions, Connection } from 'mongoose';
import * as _ from 'lodash';
import { Db } from 'mongodb';
import { logger } from '@cdm-logger/server';
import { CdmLogger } from '@cdm-logger/core';

type ILogger = CdmLogger.ILogger;

export class MongoConnector {
    private client: Connection;

    private db: Db;

    private opts: ConnectionOptions;

    private uri: string;

    private logger: ILogger;

    constructor(uri: string, opts?: ConnectionOptions) {
        this.opts = _.defaultsDeep(opts, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
        });
        this.uri = uri;
        this.logger = logger.child({ className: 'MongoConnector' });
    }

    /**
     * Connect to database
     *
     * @memberof MongoConnector
     */
    public async connect(): Promise<Connection> {
        if (this.client) {
            return this.client;
        }
        const conn = createConnection(this.uri, this.opts);

        conn.then((result) => {
            this.client = conn;

            if ((result as any).connection) {
                this.db = (result as any).conection.db;
            } else {
                this.db = result.db;
            }

            this.logger.info(' MongoDB has connected successfully.');

            this.db.on('disconnected', () => this.logger.warn('Mongoose has disconnected.'));
            this.db.on('error', (err) => this.logger.error('MongoDB error.', err));
            this.db.on('reconnect', () => this.logger.info('Mongoose has reconnected.'));
        });
        return conn;
    }

    /**
     * Disconnect from database
     *
     * @memberof MongoConnector
     */
    public async disconnect() {
        if (!this.client) {
            return;
        }
        if (this.db && (this.db as any).close) {
            await (this.db as any).close();
        }
        await connection.close();
    }
}

\`\`\`

## servers/backend-server/src/connectors/nats-connector.ts

\`\`\`ts
import * as nats from 'nats';
import * as _ from 'lodash';
import { logger } from '@cdm-logger/server';
import { CdmLogger } from '@cdm-logger/core';
type ILogger = CdmLogger.ILogger;


export class NatsConnector {


    private opts: nats.ClientOpts;
    private client: nats.Client;
    private logger: ILogger;
    private connected: boolean;

    constructor(opts: nats.ClientOpts) {
        this.opts = _.defaultsDeep(opts, {});
        this.logger = logger.child({ className: 'NatsConnector' });
    }
    /**
     * Connect to a NATS server
     *
     * @memberof NatsConnector
     */
    public connect() {
        if (this.client) {
            return this.client;
        }
        return new Promise<nats.Client>((resolve, reject) => {
            const client = nats.connect(this.opts);

            client.on('connect', () => {
                this.client = client;
                this.connected = true;
                this.logger.info('NATS client is connected.');
                resolve(client);
            });

            client.on('reconnect', () => {
                this.logger.info('NATS client is reconnected.');
                this.connected = true;
            });

            client.on('reconnecting', () => {
                this.logger.warn('NATS client is reconnecting...');
            });

            client.on('disconnect', () => {
                if (this.connected) {
                    this.logger.warn('NATS client is disconnected.');
                    this.connected = false;
                }
            });

            client.on('error', e => {
                this.logger.error('NATS error.', e.message);
                this.logger.debug(e);
                reject(e);

            });

            client.on('close', () => {
                this.logger.fatal('NATS connection close.');
            });
        });

    }

    /**
     * Disconnect from a NATS server
     *
     * @memberof NatsTransporter
     */
    public disconnect() {
        if (this.client) {
            this.client.flush(() => {
                this.client.close();
                this.client = null;
            });
        }
    }
}

\`\`\`

## servers/backend-server/src/connectors/redis-connector.ts

\`\`\`ts


import * as _ from 'lodash';
import { RedisClusterCache, RedisCache } from 'apollo-server-cache-redis';
import * as IORedis from 'ioredis';
import { logger } from '@cdm-logger/server';
import { config } from '../config';
import { CdmLogger } from '@cdm-logger/core';
type ILogger = CdmLogger.ILogger;

export class RedisConnector {


    private client: RedisClusterCache | RedisCache;
    private opts: IORedis.ClusterOptions | IORedis.RedisOptions;
    private logger: ILogger;

    /**
     * Creats an instance of Redis.
     *
     * @param {object} opts
     */
    constructor(opts?: IORedis.ClusterOptions | IORedis.RedisOptions) {
        this.opts = _.defaultsDeep(opts, {
            prefix: null,
        });
        this.logger = logger.child({ className: 'RedisConnector' });
    }

    /**
     * Connect to the server
     *
     * @memberof RedisConnector
     */
    public connect() {
        return new Promise((resolve, reject) => {
            reject('this method not implemented');
        });
    }


    /**
     * Return redis or redis.cluster Dataloader Client
     *
     * @memberof RedisConnection
     */
    public getRedisDataloaderClient() {
        let client: RedisClusterCache | RedisCache;
        if (config.REDIS_CLUSTER_ENABLED) {
            if (!config.REDIS_CLUSTER_URL) {
                throw new Error(`No nodes defined for cluster, ${config.REDIS_CLUSTER_URL}`);
            }
            this.logger.info('Setting Redis.Cluster connection');
            client = new RedisClusterCache(config.REDIS_CLUSTER_URL as any, this.opts);
        } else {
            this.logger.info('Setting Redis connection');
            client = new RedisCache(config.REDIS_URL as any || this.opts);
        }
        return client;
    }

    /**
     * Close Redis client connection.
     *
     * @memberof RedisConnection
     */
    public disconnect() {
        if (!this.client) {
            return;
        }
        return this.client.close();
    }
}

\`\`\`

## servers/backend-server/src/constants/ENDPOINTS.ts

\`\`\`ts
// Default port or given one.
export const GRAPHQL_ROUTE = '/graphql';
export const GRAPHIQL_ROUTE = '/graphiql';

\`\`\`

## servers/backend-server/src/constants/index.ts

\`\`\`ts
export * from './ENDPOINTS';

\`\`\`

## servers/backend-server/src/express-app.ts

\`\`\`ts
/* eslint-disable @typescript-eslint/no-var-requires */
import * as express from 'express';

import modules from './modules';
import { errorMiddleware } from './middleware/error';
import { contextServicesMiddleware } from './middleware/services';
import { IModuleService } from './interfaces';

const cookiesMiddleware = require('universal-cookie-express');

export function expressApp(options: IModuleService, middlewares, http?) {
    const app: express.Express = express();

    app.use(contextServicesMiddleware(options.createContext, options.serviceContext));

    for (const applyBeforeware of modules.beforewares) {
        applyBeforeware(app);
    }

    app.use(cookiesMiddleware());

    // Don't rate limit heroku
    app.enable('trust proxy');

    if (middlewares !== null) {
        app.use(middlewares);
    }

    // app.use(corsMiddleware);
    app.use((req, res, next) => {
        res.header('Access-Control-Allow-Credentials', JSON.stringify(true));
        res.header('Access-Control-Allow-Origin', req.headers.origin as string);
        res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');
        res.header('Access-Control-Allow-Headers', 'X-Requested-With, X-HTTP-Method-Override, Content-Type, Accept');
        next();
    });

    const corsOptions = {
        origin: true,
        credentials: true,
    };

    for (const applyMiddleware of modules.middlewares) {
        applyMiddleware(app);
    }

    if (__DEV__) {
        app.use(errorMiddleware);
    }

    return app;
}

\`\`\`

## servers/backend-server/src/index.ts

\`\`\`ts
/* eslint-disable import/first */
/// <reference types="webpack-env" />
// eslint-disable-next-line global-require, import/first, no-unused-expressions, @typescript-eslint/no-var-requires
process.env.ENV_FILE !== null && require('dotenv').config({ path: process.env.ENV_FILE });

import 'reflect-metadata';
import { logger } from '@cdm-logger/server';
import { Service } from './service';

declare let module: __WebpackModuleApi.Module;

process.on('uncaughtException', (ex) => {
    logger.error(ex);
    process.exit(1);
});

process.on('unhandledRejection', (reason) => {
    logger.error(reason);
});
const service = new Service();

async function start() {
    await service.initialize();
    await service.start();
}
if (module.hot) {
    module.hot.status((event) => {
        if (event === 'abort' || event === 'fail') {
            logger.error(`HMR error status: ${event}`);
            // Signal webpack.run.js to do full-reload of the back-end
            service.gracefulShutdown(event);
        }
        // adddintionally when event is idle due to external modules
        if (event === 'idle') {
            service.gracefulShutdown(event);
        }
    });
    module.hot.accept();
}

start();

\`\`\`

## servers/backend-server/src/interfaces/index.ts

\`\`\`ts
export * from './module-interface';

\`\`\`

## servers/backend-server/src/interfaces/module-interface.ts

\`\`\`ts
import { GraphQLSchema } from 'graphql';
import { CdmLogger } from '@cdm-logger/core';
type ILogger = CdmLogger.ILogger;


export interface IModuleService {
    serviceContainer: any;
    serviceContext: any;
    dataSource: any;
    defaultPreferences: any;
    createContext: any;
    schema: GraphQLSchema;
    logger: ILogger;
}



\`\`\`

## servers/backend-server/src/main.spec.ts

\`\`\`ts
// import {GRAPHQL_ROUTE, GRAPHIQL_ROUTE, main} from './main';
// import {get as httpGet, Server} from 'http';
// import 'jest';

// const ERRNO_KEY = 'errno';
// const PORT: number = 8080;

// function getFromServer(uri) {
//   return new Promise((resolve, reject) => {
//     httpGet(`http://localhost:${PORT}${uri}`, (res) => {
//       resolve(res);
//     }).on('error', (err: Error) => {
//       reject(err);
//     });
//   });
// }

// describe('main', () => {
//   it('should be able to Initialize a server (production)', () => {
//     return main({
//       enableCors: false,
//       enableGraphiql: false,
//       env: 'production',
//       port: PORT,
//     })
//     .then(([server]) => {
//       return (<Server>server).close();
//     });
//   });

//   it('should be able to Initialize a server (development)', () => {
//     return main({
//       enableCors: true,
//       enableGraphiql: true,
//       env: 'dev',
//       port: PORT,
//     })
//     .then(([server]) => {
//       return (<Server>server).close();
//     });
//   });

//   it('should have a working GET graphql (developemnt)', () => {
//     return main({
//       enableCors: true,
//       enableGraphiql: true,
//       env: 'dev',
//       port: PORT,
//     })
//     .then(([server]) => {
//       return getFromServer(GRAPHQL_ROUTE).then((res: any) => {
//         (<Server>server).close();
//         // GET without query returns 400
//         expect(res.statusCode).toBe(400);
//       });
//     });
//   });

//   it('should have a working GET graphql (production)', () => {
//     return main({
//       enableCors: false,
//       enableGraphiql: false,
//       env: 'production',
//       port: PORT,
//     })
//     .then(([server]) => {
//       return getFromServer(GRAPHQL_ROUTE).then((res: any) => {
//         (<Server>server).close();
//         // GET without query returns 400
//         expect(res.statusCode).toBe(400);
//       });
//     });
//   });

//   it('should have a working graphiql (developemnt)', () => {
//     return main({
//       enableCors: true,
//       enableGraphiql: true,
//       env: 'dev',
//       port: PORT,
//     })
//     .then(([server]) => {
//       return getFromServer(GRAPHIQL_ROUTE).then((res: any) => {
//         (<Server>server).close();
//         expect(res.statusCode).toBe(200);
//       });
//     });
//   });

//   it('should have block graphiql (production)', () => {
//     return main({
//       enableCors: false,
//       enableGraphiql: false,
//       env: 'production',
//       port: PORT,
//     })
//     .then(([server]) => {
//       return getFromServer(GRAPHIQL_ROUTE).then((res: any) => {
//         (<Server>server).close();
//         expect(res.statusCode).toBe(404);
//       });
//     });
//   });

//   it('should reject twice on same port', () => {
//     return main({
//       enableCors: false,
//       enableGraphiql: false,
//       env: 'production',
//       port: PORT,
//     })
//     .then(([server]) => {
//       return main({
//         enableCors: false,
//         enableGraphiql: false,
//         env: 'production',
//         port: PORT,
//       })
//       .then(([secondServer]) => {
//         (<Server>server).close();
//         (<Server>secondServer).close();
//         throw new Error('Was able to listen twice!');
//       }, (err: Error) => {
//         (<Server>server).close();
//         expect(err[ERRNO_KEY]).toBe('EADDRINUSE');
//       });
//     });
//   });
// });

\`\`\`

## servers/backend-server/src/middleware/cors.ts

\`\`\`ts
import * as cors from 'cors';
import * as express from 'express';
import { config } from '../config';
import { logger } from '@cdm-logger/server';

const CLIENT_URL = config.CLIENT_URL;
const BACKEND_URL = config.BACKEND_URL;

const corsWhitelist = [
    BACKEND_URL,
    CLIENT_URL,
    config.GRAPHQL_URL,
];
logger.info('Cors whitelist: %j', corsWhitelist);
const corsOptions = {
    origin: (origin, callback) => {
        if (corsWhitelist.indexOf(origin) !== -1) {
            callback(null, true);
        } else {
            // TODO: only throw when in debug mode
            logger.error('url (%s) is not in the whitelist', origin);
            // callback(new Error('Not allowed by CORS'))
            logger.warn('allowing all origins temporarily, you need to disable it.');
            callback(null, true);
        }
    },
    credentails: false,
};

export const corsMiddleware = cors(corsOptions);

\`\`\`

## servers/backend-server/src/middleware/error.ts

\`\`\`ts
/// <reference path='../../../../typings/index.d.ts' />

import * as path from 'path';
import * as fs from 'fs';
import * as url from 'url';
import { logger } from '@cdm-logger/server';


let assetMap;

const stripCircular = (from, seen?: any) => {
    const to = Array.isArray(from) ? [] : {};
    seen = seen || [];
    seen.push(from);
    Object.getOwnPropertyNames(from).forEach(key => {
        if (!from[key] || (typeof from[key] !== 'object' && !Array.isArray(from[key]))) {
            to[key] = from[key];
        } else if (seen.indexOf(from[key]) < 0) {
            to[key] = stripCircular(from[key], seen.slice(0));
        } else { to[key] = '[Circular]'; }
    });
    return to;
};

const { pathname } = url.parse(__BACKEND_URL__);

export const errorMiddleware =
    (e, req, res, next) => {
        if (req.path === pathname) {
            const stack = e.stack.toString().replace(/[\n]/g, '\\n');
            res.status(200).send(`[{"data": {}, "errors":[{"message": "${stack}"}]}]`);
        } else {
            logger.error(e);

            if (__DEV__ || !assetMap) {
                assetMap = JSON.parse(fs.readFileSync(path.join(__FRONTEND_BUILD_DIR__, 'assets.json')).toString());
            }

            const serverErrorScript = `<script charset="UTF-8">window.__SERVER_ERROR__=${JSON.stringify(
                stripCircular(e),
            )};</script>`;
            const vendorScript = assetMap['vendor.js']
                ? `<script src="/${assetMap['vendor.js']}" charSet="utf-8"></script>`
                : '';

            res.status(200).send(
                `<html>${serverErrorScript}<body><div id="content"></div>
        ${vendorScript}
            <script src="/${assetMap['index.js']}" charSet="utf-8"></script>
            </body></html>`,
            );
        }
    };



\`\`\`

## servers/backend-server/src/middleware/moleculer-inter-namespace.ts

\`\`\`ts
/* eslint-disable no-param-reassign */
import { ServiceBroker, Middleware } from 'moleculer';
import * as _ from 'lodash';

export const InterNamespaceMiddleware = function (options): Middleware {
    if (!Array.isArray(options)) {
        throw new Error('Must be an Array');
    }

    let thisBroker: ServiceBroker;
    const brokers: { [key: string]: ServiceBroker } = {};

    return {
        created(broker: ServiceBroker) {
            thisBroker = broker;
            options.forEach((nsOpts) => {
                if (_.isString(nsOpts)) {
                    nsOpts = {
                        namespace: nsOpts,
                    };
                }
                const ns = nsOpts.namespace;

                const brokerOpts = _.defaultsDeep(
                    {},
                    nsOpts,
                    { nodeID: null, middlewares: null, created: null, started: null },
                    broker.options,
                );
                brokers[ns] = new ServiceBroker(brokerOpts);
            });
        },

        started() {
            return Promise.all(Object.values(brokers).map((b) => b.start()));
        },

        stopped() {
            return Promise.all(Object.values(brokers).map((b) => b.stop()));
        },

        call(next) {
            return function (actionName, params, opts = {}) {
                if (_.isString(actionName) && actionName.includes('@')) {
                    const [action, namespace] = actionName.split('@');

                    if (brokers[namespace]) {
                        return brokers[namespace].call(action, params, opts);
                    }
                    if (namespace === thisBroker.namespace) {
                        return next(action, params, opts);
                    }
                    throw new Error(`Unknown namespace: ${namespace}`);
                }

                return next(actionName, params, opts);
            };
        },
    };
};

\`\`\`

## servers/backend-server/src/middleware/persistedQuery.ts

\`\`\`ts
import { invert, isArray } from 'lodash';
import { GRAPHIQL_ROUTE } from '../ENDPOINTS';
import { logger } from '@cdm-logger/server';

let reqlib: any = require('app-root-path');

let persistCache = true;
let queryMap;
try {
    queryMap = reqlib.require('@sample-stack/platform-browser/extracted_queries.json');

} catch (err) {
    logger.warn('extracted_queries.json file is unavailable, disabling persist queries');
}
export const persistedQueryMiddleware = (req, res, next) => {

    if (queryMap) {
        const invertedMap = invert(queryMap);

        if (isArray(req.body)) {
            req.body = req.body.map(body => {
                const id = body['id'];
                return {
                    query: invertedMap[id],
                    ...body,
                };
            });
            next();
        } else {
            if (!__DEV__ || (req.get('Referer') || '').indexOf(GRAPHIQL_ROUTE) < 0) {
                res.status(500).send('Unknown GraphQL query has been received, rejecting...');
            } else {
                next();
            }
        }
    } else {
        next();
    }
};


\`\`\`

## servers/backend-server/src/middleware/services.ts

\`\`\`ts
import 'isomorphic-fetch';


export const contextServicesMiddleware = (createContext, serviceContext) =>  (req, res, next) => {
    Promise.all([
        createContext(req, res),
        serviceContext(req, res),
    ])
        .then(([ context, services ]) => {
            req.context = context;
            req.services = services;

            next();
        })
        .catch((err) => next());
};

\`\`\`

## servers/backend-server/src/modules/index.ts

\`\`\`ts
import modules, { settings } from './module';

export default modules;
export { settings };

// export const updateContainers = (options) => {
//     if (process.env.NODE_ENV !== 'development') {
//         options.forEach(el => {
//             hemera.act({
//                 topic: `UPDATE_CONTAINER_${el.toUpperCase()}`,
//                 cmd: `UPDATE_CONTAINER_${el.toUpperCase()}`,
//             });
//         });'
//     } else {
//         modules.createServiceContext(settings, options);
//     }
// };

\`\`\`

## servers/backend-server/src/modules/module.ts

\`\`\`ts
import { ContainerModule, interfaces } from 'inversify';
import { Feature } from '@common-stack/server-core';
import CounterModule from '@sample-stack/counter-module-server';
import { TaggedType } from '@common-stack/core';
import { config } from '../config';

export const settings = {
    // mongoConnection: generateMongo(config.MONGO_URL),
    subTopic: config.CONNECTION_ID, // usually versioning
    adminApiNamespace: config.ADMIN_API_NAMESPACE,
    apiNamespace: config.API_NAMESPACE,
};

const defaultModule = () =>
    new ContainerModule((bind: interfaces.Bind) => {
        bind('Settings').toConstantValue(settings).whenTargetTagged('default', true);
        bind('Settings').toConstantValue(settings).whenTargetTagged(TaggedType.MICROSERVICE, true);
        bind('MongoOptions').toConstantValue({});
    });

const DefaultFeature = new Feature({
    createContainerFunc: [defaultModule],
    createHemeraContainerFunc: [defaultModule],
});

export const ExternalModules = new Feature<any>({});

export default new Feature(DefaultFeature, ExternalModules, CounterModule);

\`\`\`

## servers/backend-server/src/server-setup/graphql-server.ts

\`\`\`ts
import { ApolloServer, ApolloServerExpressConfig } from 'apollo-server-express';
import 'isomorphic-fetch';
import { Express } from 'express';
import * as http from 'http';
import { RedisClusterCache, RedisCache } from 'apollo-server-cache-redis';
import { CdmLogger } from '@cdm-logger/core';
import { GRAPHQL_ROUTE } from '../constants';
import { IModuleService } from '../interfaces';

type ILogger = CdmLogger.ILogger;

let debug = false;
if ((process.env.LOG_LEVEL && process.env.LOG_LEVEL === 'trace') || process.env.LOG_LEVEL === 'debug') {
    debug = true;
}

// @workaround as the `dataSources` not available in Subscription (websocket) Context.
// https://github.com/apollographql/apollo-server/issues/1526 need to revisit in Apollo-Server v3.
const constructDataSourcesForSubscriptions = (context, cache, dataSources) => {
    const intializeDataSource = (instance) => {
        instance.initialize({ context, cache });
    };
    // tslint:disable-next-line:forin
    // eslint-disable-next-line guard-for-in
    for (const prop in dataSources) {
        // tslint:disable-next-line:no-console
        intializeDataSource(dataSources[prop]);
    }
    return dataSources;
};

export class GraphqlServer {
    private logger: ILogger;

    constructor(
        private app: Express,
        private httpServer: http.Server,
        private cache: RedisCache | RedisClusterCache,
        private moduleService: IModuleService,
        private enableSubscription = true,
    ) {
        this.logger = this.moduleService.logger.child({ className: 'GraphqlServer' });
    }

    public async initialize() {
        this.logger.info('GraphqlServer initializing...');
        const apolloServer = this.configureApolloServer();
        apolloServer.applyMiddleware({ app: this.app, disableHealthCheck: false, path: GRAPHQL_ROUTE });
        if (this.enableSubscription) {
            apolloServer.installSubscriptionHandlers(this.httpServer);
        }
        this.logger.info('GraphqlServer initialized');
    }

    private configureApolloServer(): ApolloServer {
        const serverConfig: ApolloServerExpressConfig = {
            debug,
            schema: this.moduleService.schema as any,
            dataSources: () => this.moduleService.dataSource,
            cache: this.cache,
            context: async ({
                req,
                res,
                connection,
            }: {
                req: Express.Request;
                res: Express.Response;
                connection: any;
            }) => {
                let context;
                let addons = {};
                try {
                    if (connection) {
                        context = connection.context;
                        if (!context.dataSources) {
                            addons = {
                                // @workaround for apollo server issue #1526
                                dataSources: constructDataSourcesForSubscriptions(
                                    connection.context,
                                    this.cache,
                                    this.moduleService.dataSource,
                                ),
                            };
                        } else {
                            addons = {
                                // @workaround for apollo server issue #1526
                                dataSources: context.dataSources,
                            };
                        }
                    } else {
                        const pureContext = await this.moduleService.createContext(req, res);
                        const contextServices = await this.moduleService.serviceContext(req, res);
                        context = {
                            ...pureContext,
                            ...contextServices,
                            preferences: this.moduleService.defaultPreferences,
                            // update: updateContainers,
                        };
                    }
                } catch (err) {
                    this.logger.error('adding context to graphql failed due to [%o]', err);
                    throw err;
                }
                return {
                    ...context,
                    ...addons,
                };
            },
        };
        if (this.enableSubscription) {
            serverConfig.subscriptions = {
                onConnect: async (connectionParams, webSocket) => {
                    this.logger.debug(`Subscription client connected using built-in SubscriptionServer.`);
                    const pureContext = await this.moduleService.createContext(connectionParams, webSocket);
                    const contextServices = await this.moduleService.serviceContext(connectionParams, webSocket);
                    return {
                        ...contextServices,
                        ...pureContext,
                        preferences: this.moduleService.defaultPreferences,
                        // update: updateContainers,
                    };
                },
                // onDisconnect: () => {},
            };
        }
        return new ApolloServer(serverConfig);
    }
}

\`\`\`

## servers/backend-server/src/server-setup/graphql-subscription-server.ts

\`\`\`ts
import { SubscriptionServer, ConnectionContext, ExecutionParams } from 'subscriptions-transport-ws';
import { execute, subscribe, ExecutionResult } from 'graphql';
// import { GraphQLServerOptions } from 'apollo-server-core';
import { formatApolloErrors } from 'apollo-server-errors';
import { GraphQLServerOptions } from 'apollo-server-core/dist/graphqlOptions';
import { Context } from 'apollo-server-core';
import { RedisClusterCache, RedisCache } from 'apollo-server-cache-redis';
import { CdmLogger } from '@cdm-logger/core';
import { IModuleService } from '../interfaces';

type ILogger = CdmLogger.ILogger;

// @workaround as the `dataSources` not available in Subscription (websocket) Context.
// https://github.com/apollographql/apollo-server/issues/1526 need to revisit in Apollo-Server v3.
const constructDataSourcesForSubscriptions = (context, cache, dataSources) => {
    const intializeDataSource = (instance) => {
        instance.initialize({ context, cache });
    };
    // tslint:disable-next-line:forin
    for (const prop in dataSources) {
        // tslint:disable-next-line:no-console
        intializeDataSource(dataSources[prop]);
    }
    return dataSources;
};

export class GraphqlSubscriptionServer {
    private subscriptionServer: SubscriptionServer;

    private context: Context;

    private logger: ILogger;

    constructor(
        private moduleService: IModuleService,
        private cache: RedisCache | RedisClusterCache,
        private requestOptions: Partial<GraphQLServerOptions<any>> = Object.create(null),
    ) {
        this.logger = this.moduleService.logger.child({ className: 'GraphqlSubscriptionServer' });
    }

    public create() {
        this.subscriptionServer = SubscriptionServer.create(
            {
                schema: this.moduleService.schema as any,
                execute,
                subscribe,
                onConnect: async (connectionParams: any, webSocket: any, ctx: ConnectionContext) => {
                    try {
                        this.logger.debug(`Subscription client connected using built-in SubscriptionServer.`);
                        const pureContext = await this.moduleService.createContext(connectionParams, webSocket);
                        const contextServices = await this.moduleService.serviceContext(connectionParams, webSocket);
                        const context = {
                            ...contextServices,
                            ...pureContext,
                            preferences: this.moduleService.defaultPreferences,
                            // update: updateContainers,
                            wsCtx: ctx,
                        };
                        const addons = {
                            dataSources: constructDataSourcesForSubscriptions(
                                context,
                                this.cache,
                                this.moduleService.dataSource,
                            ),
                        };
                        return {
                            ...context,
                            ...addons,
                        };
                    } catch (e) {
                        this.logger.error(e);
                    }
                },
                onOperation: async (message: { payload: any }, connection: ExecutionParams) => {
                    connection.formatResponse = (value: ExecutionResult) => ({
                        ...value,
                        errors:
                            value.errors &&
                            formatApolloErrors([...value.errors], {
                                formatter: this.requestOptions.formatError,
                                debug: this.requestOptions.debug,
                            }),
                    });
                    let context: Context = this.context ? this.context : { connection };
                    try {
                        context =
                            typeof this.context === 'function'
                                ? await this.context({ connection, payload: message.payload })
                                : context;
                    } catch (e) {
                        throw formatApolloErrors([e], {
                            formatter: this.requestOptions.formatError,
                            debug: this.requestOptions.debug,
                        })[0];
                    }

                    return { ...connection }; // TODO: we didn't add `context`
                },
            },
            {
                noServer: true,
            },
        );
        return this.subscriptionServer;
    }

    public disconnect() {
        if (this.subscriptionServer) {
            this.subscriptionServer.close();
        }
    }
}

\`\`\`

## servers/backend-server/src/server-setup/websocket-multipath-update.ts

\`\`\`ts



import * as url from 'url';
import { GRAPHQL_ROUTE } from '../constants';
import { GraphqlSubscriptionServer } from './graphql-subscription-server';
import * as WebSocket from 'ws';
import { IModuleService } from '../interfaces';
import { Server } from 'http';
import { RedisClusterCache, RedisCache } from 'apollo-server-cache-redis';

interface WebSocketsCache {
    [key: string]: WebSocket.Server;
}

interface MultiWebsocketConfig {
    [key: string]: any;
}
export class WebsocketMultiPathServer {

    private webSockets: WebSocketsCache = {};
    private graphqlSubscriptionServer: GraphqlSubscriptionServer;
    constructor(
        moduleService: IModuleService,
        cache: RedisCache | RedisClusterCache,
        multiplePathConfig?: MultiWebsocketConfig,
    ) {
        this.graphqlSubscriptionServer = new GraphqlSubscriptionServer(moduleService, cache);
        this.webSockets[GRAPHQL_ROUTE] = this.graphqlSubscriptionServer.create().server;
        for (let key in multiplePathConfig) {
            if (!multiplePathConfig.hasOwnProperty(key)) { continue; }

            if (!this.webSockets[key]) {
                this.webSockets[key] = new WebSocket.Server({ noServer: true });
                this.webSockets[key].on('connection', (ws, request) => {
                    Promise.all([
                        moduleService.createContext(request, null),
                        moduleService.serviceContext(request, null),
                    ])
                    .then(multiplePathConfig[key](ws));
                });
            }
        }
    }


    public httpServerUpgrade(httpServer: Server) {
        httpServer.on('upgrade', (request, socket, head) => {
            const pathname = url.parse(request.url).pathname;

            if (!this.webSockets[pathname]) {
                // need to destroy
                socket.destroy();
            }

            // code to run when a new connection is made
            this.webSockets[pathname].handleUpgrade(request, socket, head, (ws) => {
                this.webSockets[pathname].emit('connection', ws, request);
            });
        });
        return httpServer;
    }

    public close() {
        // tslint:disable-next-line:forin
        for (let key in this.webSockets) {
            this.webSockets[key].close();
        }
    }
}

\`\`\`

## servers/backend-server/src/service.ts

\`\`\`ts
import { StackServer } from './stack-server';
import { logger } from '@cdm-logger/server';
import * as url from 'url';
import { config } from './config';

const { port: serverPort, pathname, hostname } = url.parse(config.BACKEND_URL);

export class Service {

    private app: StackServer;

    public async initialize() {

        this.app = new StackServer();
        await this.app.initialize();
    }

    public async start() {
        await this.app.start();
        await this.app.httpServer.startListening(serverPort);
        logger.info(`API is now running on port ${serverPort}`);
    }

    public async gracefulShutdown(signal) {
        try {
            logger.info(`${signal} received. Closing connections, stopping server`);
            await this.app.cleanup();
            logger.info('Shutting down');
        } catch (err) {
            logger.error('Error during graceful shutdown');
            logger.error(err);
        } finally {
            process.exit(0);
        }
    }
}

\`\`\`

## servers/backend-server/src/stack-server.ts

\`\`\`ts
/* eslint-disable import/namespace */
/* eslint-disable import/no-unresolved */
/* eslint-disable import/no-extraneous-dependencies */
// version 08/25/2021
import * as http from 'http';
import * as express from 'express';
import { logger as serverLogger } from '@cdm-logger/server';
import { Feature } from '@common-stack/server-core';
import { ContainerModule, interfaces, Container } from 'inversify';
import { ServiceBroker, ServiceSettingSchema } from 'moleculer';
import { CommonType } from '@common-stack/core';
import * as _ from 'lodash';
import { CdmLogger } from '@cdm-logger/core';
import { expressApp } from './express-app';
import { GraphqlServer } from './server-setup/graphql-server';
import { config } from './config';
import { ConnectionBroker } from './connectors/connection-broker';
import * as brokerConfig from './config/moleculer.config';
import modules, { settings } from './modules';
import { GatewaySchemaBuilder } from './api/schema-builder';
import { WebsocketMultiPathServer } from './server-setup/websocket-multipath-update';
import { IModuleService } from './interfaces';
import { migrate } from './utils/migrations';
import { InterNamespaceMiddleware } from './middleware/moleculer-inter-namespace';
// This is temp and will be replaced one we add support for rules in Feature

type ILogger = CdmLogger.ILogger;

function startListening(port) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const server = this;
    return new Promise((resolve) => {
        server.listen(port, resolve);
    });
}

const infraModule = ({ broker, pubsub, mongoClient, logger }) =>
    new ContainerModule((bind: interfaces.Bind) => {
        bind('Logger').toConstantValue(logger);
        bind(CommonType.LOGGER).toConstantValue(logger);
        bind('Environment').toConstantValue(config.NODE_ENV || 'development');
        bind(CommonType.ENVIRONMENT).toConstantValue(config.NODE_ENV || 'development');
        bind('PubSub').toConstantValue(pubsub);
        bind(CommonType.PUBSUB).toConstantValue(pubsub);
        bind(CommonType.MOLECULER_BROKER).toConstantValue(broker);
        bind('MoleculerBroker').toConstantValue(broker);
        bind('MongoDBConnection').toConstantValue(mongoClient);
    });

/**
 *  Controls the lifecycle of the Application Server
 *
 * @export
 * @class StackServer
 */
export class StackServer {
    public httpServer: http.Server & { startListening?: (port) => void };

    private app: express.Express;

    private logger: ILogger;

    private connectionBroker: ConnectionBroker;

    private mainserviceBroker: ServiceBroker;

    private microserviceBroker: ServiceBroker;

    private multiPathWebsocket: WebsocketMultiPathServer;

    private serviceContainer: Container;

    private microserviceContainer: Container;

    constructor() {
        this.logger = serverLogger.child({ className: 'StackServer' });
    }

    public async initialize() {
        this.logger.info('StackServer initializing');

        // eslint-disable-next-line import/namespace
        this.connectionBroker = new ConnectionBroker(brokerConfig.transporter, this.logger);
        const redisClient = this.connectionBroker.redisDataloaderClient;

        const mongoClient = await this.connectionBroker.mongoConnection;

        // Moleculer Broker Setup
        this.mainserviceBroker = new ServiceBroker({
            ...brokerConfig,
            middlewares: [
                InterNamespaceMiddleware([
                    {
                        namespace: 'api-admin',
                        transporter: brokerConfig.transporter,
                    },
                ]),
            ],
            started: async () => {
                await modules.preStart(this.serviceContainer);
                if (config.NODE_ENV === 'development') {
                    // await modules.microservicePreStart(this.micorserviceContainer);
                }

                try {
                    await migrate(mongoClient, this.serviceContainer);
                } catch (e) {
                    this.logger.error('Error while running migrations', e);
                    this.logger.error(e.stack);
                }

                try {
                    await modules.postStart(this.serviceContainer);
                } catch (e) {
                    this.logger.error('Error while running Post Start', e);
                    this.logger.error(e.stack);
                }
                // start DB migration

                if (config.NODE_ENV === 'development') {
                    // await modules.microservicePostStart(this.micorserviceContainer);
                }
            },

            // created,
            async created() {
                return Promise.resolve();
            },
        });

        if (config.NODE_ENV === 'development') {
            this.microserviceBroker = new ServiceBroker({
                ...brokerConfig,
                nodeID: 'node-broker-2',
                started: async () => {
                    await modules.microservicePreStart(this.microserviceContainer);
                    await modules.microservicePostStart(this.microserviceContainer);
                },
                // created,
                created: async () => Promise.resolve(),
            });
        }
        const pubsub = await this.connectionBroker.graphqlPubsub;
        const InfraStructureFeature = new Feature({
            createContainerFunc: [
                () =>
                    infraModule({
                        broker: this.mainserviceBroker,
                        pubsub,
                        mongoClient,
                        logger: serverLogger,
                    }),
            ],
            createServiceFunc: (container) => ({ moleculerBroker: container.get(CommonType.MOLECULER_BROKER) }),
            createHemeraContainerFunc: [
                () =>
                    infraModule({
                        broker: this.mainserviceBroker,
                        pubsub,
                        mongoClient,
                        logger: serverLogger,
                    }),
            ],
        });

        const allModules = new Feature(InfraStructureFeature, modules as Feature);
        const executableSchema = await new GatewaySchemaBuilder({
            schema: allModules.schemas,
            resolvers: allModules.createResolvers({
                pubsub,
                logger: serverLogger,
                subscriptionID: `${settings.subTopic}`,
            }),
            directives: allModules.createDirectives({ logger: this.logger }),
            logger: serverLogger,
        }).build();

        // set the service container
        this.serviceContainer = await allModules.createContainers({ ...settings, mongoConnection: mongoClient });
        const createServiceContext = allModules.createServiceContext({ ...settings, mongoConnection: mongoClient });
        const serviceBroker: IModuleService = {
            serviceContainer: this.serviceContainer,
            serviceContext: createServiceContext,
            dataSource: allModules.createDataSource(),
            defaultPreferences: allModules.createDefaultPreferences(),
            createContext: async (req, res) => allModules.createContext(req, res),
            logger: serverLogger,
            schema: executableSchema,
        };
        allModules.loadMainMoleculerService({
            broker: this.mainserviceBroker,
            container: this.serviceContainer,
            settings,
        });
        if (config.NODE_ENV === 'development') {
            this.microserviceContainer = await allModules.createHemeraContainers({
                ...settings,
                mongoConnection: mongoClient,
            });
            allModules.loadClientMoleculerService({
                broker: this.microserviceBroker,
                container: this.microserviceContainer,
                settings,
            });
        }

        // initialize Servers
        this.httpServer = http.createServer();
        this.app = await expressApp(serviceBroker, null, this.httpServer);

        this.httpServer.startListening = startListening.bind(this.httpServer);
        this.httpServer.on('request', this.app);
        this.httpServer.on('close', () => {
            this.httpServer = undefined;
        });

        const customWebsocket = allModules.getWebsocketConfig();
        const customWebsocketEnable = !_.isEmpty(customWebsocket);

        if (customWebsocketEnable) {
            this.multiPathWebsocket = new WebsocketMultiPathServer(serviceBroker, redisClient, customWebsocket);
            this.httpServer = this.multiPathWebsocket.httpServerUpgrade(this.httpServer);
        }
        const graphqlServer = new GraphqlServer(
            this.app,
            this.httpServer,
            redisClient,
            serviceBroker,
            !customWebsocketEnable,
        );

        await graphqlServer.initialize();
    }

    public async start() {
        if (config.NODE_ENV === 'development') {
            await Promise.all([this.mainserviceBroker.start(), this.microserviceBroker.start()]);
        } else {
            await this.mainserviceBroker.start();
        }
    }

    public async cleanup() {
        if (this.multiPathWebsocket) {
            this.multiPathWebsocket.close();
        }
        if (this.httpServer) {
            await this.httpServer.close();
        }
        if (this.connectionBroker) {
            await this.connectionBroker.stop();
        }
        if (this.mainserviceBroker) {
            await this.mainserviceBroker.stop();
        }
        if (this.microserviceBroker) {
            await this.microserviceBroker.stop();
        }
    }
}

\`\`\`

## servers/backend-server/src/utils/migrations.ts

\`\`\`ts
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable consistent-return */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/restrict-template-expressions */
import { Schema, Connection } from 'mongoose';
import { Container } from 'inversify';

export const MigrationSchema = new Schema({
    migrated_at: Date,
    name: { required: true, type: String },
});

export async function migrate(db: Connection, container: Container) {
    try {
        const migrations = container.getAll<{ up: any; id: any }>('MongodbMigration');
        const model = db.model<any, any>('Migration', MigrationSchema);
        return await Promise.all(
            migrations.map(async (migration) => {
                const exists = await model.findOne({ name: migration.id });
                if (!exists) {
                    try {
                        await migration.up();
                        await model.create({ name: migration.id, migrated_at: new Date() });
                    } catch (e) {
                        console.log(`Can not process migration ${migration.id}: `, e);
                    }
                }

                return migration.id;
            }),
        );
    } catch (err) {
        console.warn('ignoring migrate database due to ', err.message);
    }
}

\`\`\`

## servers/backend-server/tsconfig.json

\`\`\`json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "sourceMap": true,
    "declaration": false,
    "rootDirs": ["./src","../knexfile.ts"],
    "outDir": "./dist"
  },
  "include": [
    "../../typings/*.d.ts",
  ],
  "awesomeTypescriptLoaderOptions": {
    "reportFiles": [
      "../../typings/*.d.ts",
      "**/*.ts",
      "**/*.tsx"
    ]
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
\`\`\`

## servers/backend-server/webpack.config.lint.js

\`\`\`js
module.exports = require('zenjs').createWebpackConfig(__dirname, '.zenrc.js', 'server');
\`\`\`

## servers/frontend-server/.zenrc.js

\`\`\`js
const path = require('path');
var nodeExternals = require('webpack-node-externals');
const debug = process.env.DEBUGGING || false;
const { merge } = require('webpack-merge');
const webpack = require('webpack');
const Dotenv = require('dotenv-webpack');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const LodashModuleReplacementPlugin = require('lodash-webpack-plugin');

const config = {
    builders: {
        web: {
            webpackDLL: false,
            entry: './src/index.tsx',
            output: {
                chunkFilename: '[name].bundle.js',
                sourceMapFilename: '[file].map',
            },
            stack: ['web', 'react'],
            tsLoaderOptions: {
                // "configFile": "./tsconfig.json"
            },
            webpackDevPort: 3000,
            openBrowser: true,
            defines: {
                __CLIENT__: true,
            },
            test: {
                role: ['build', 'watch']
            },
            htmlTemplate: "../../tools/html-plugin-template.ejs",
            // Wait for backend to start prior to letting webpack load frontend page
            waitOn: ['tcp:localhost:8080'],
            enabled: true,
            webpackConfig: {
                plugins: [
                    new LodashModuleReplacementPlugin({
                        // Necessary as a workaround for https://github.com/apollographql/react-apollo/issues/1831
                        flattening: true
                      }),
                ],
                // for additional webpack configuration.
                resolve: process.env.NODE_ENV !== 'production'
                    ? {
                        alias: {
                            'react-dom': '@hot-loader/react-dom'
                        }
                    }
                    : {},
            }
        },
        server: {
            entry: './src/backend/app.ts',
            stack: ['server'],
            tsLoaderOptions: {
                // configFileName: "./tsconfig.json"
            },
            defines: {
                __SERVER__: true,
            },
            enabled: false,
            webpackConfig: {
                output: {
                    filename: 'main.js',
                    sourceMapFilename: '[file].map',
                },
                plugins: [
                    new CopyWebpackPlugin({
                        patterns: [{
                            from: '../../tools/esm-wrapper.js',
                            to: 'index.js',
                        }]
                    }),
                    new LodashModuleReplacementPlugin({
                        // Necessary as a workaround for https://github.com/apollographql/react-apollo/issues/1831
                        flattening: true
                      }),
                ],
                externals: [
                    nodeExternals(),
                    nodeExternals({ allowlist: [/webpack\/hot/i, /babel-polyfill/], modulesDir: "../../node_modules" })
                ],
            }
        },
        test: {
            stack: ['server'],
            roles: ['test'],
            defines: {
                __TEST__: true
            }
        }
    },
    options: {
        stack: [
            "apollo",
            "ts",
            "react",
            "webpack",
            "css"
        ],
        cache: '../../.cache',
        backendBuildDir: "dist",
        frontendBuildDir: "dist",
        dllBuildDir: "dist/.build/dll",
        ssr: false,
        backendUrl: "http://localhost:8080",
        webpackDll: true,
        reactHotLoader: true,
        useDefaultPostCss: true,
        persistGraphQL: false,
        frontendRefreshOnBackendChange: true,
        nodeDebugger: false,
        overridesConfig: "./tools/webpackAppConfig.js",
        plugins: [
            new Dotenv({
                path: process.env.ENV_FILE
            })
        ],
        defines: {
            __DEV__: process.env.NODE_ENV === 'development',
            __GRAPHQL_URL__: '"http://localhost:8080/graphql"',
        }
    }
};
if (process.env.NODE_ENV === 'development') {
    const dotEnvPlugin = {
        plugins: [
            new Dotenv({
                path: process.env.ENV_FILE
            })
        ],
    }
    config.builders.web.webpackConfig = merge(config.builders.web.webpackConfig, dotEnvPlugin);

}

if (process.env.SSR) {
    config.builders.server.enabled = true;
    config.options.defines.__BACKEND_URL__ = '"http://localhost:3010"';
    config.options.ssr = true;
    config.options.backendUrl = "http://localhost:3010";
}
if (process.env.NODE_ENV !== 'development') {
    config.builders.server.enabled = true;
    config.options.defines.__BACKEND_URL__ = '"http://localhost:3010"';
    config.options.ssr = true;
    config.options.backendUrl = "http://localhost:3010";
}

if (process.env.NODE_ENV === 'production') {
    // Generating source maps for production will slowdown compilation for roughly 25%
    config.options.sourceMap = false;
}


config.options.devProxy = config.options.ssr;

const extraDefines = {
    __SSR__: config.options.ssr,
    __PERSIST_GQL__: `'${config.options.persistGraphQL}'`,
    __FRONTEND_BUILD_DIR__: `'${config.options.frontendBuildDir}'`,
    __DLL_BUILD_DIR__: `'${config.options.dllBuildDir}'`,
    __DEBUGGING__: `'${debug}'`
};

if (process.env.NODE_ENV !== 'production') {

    if (!config.options.ssr) {
        console.log('Warning! exposing env variables in UI, only run in development.');
        var dotenv = require('dotenv-safe')
            .config(
                {
                    allowEmptyValues: true,
                    path: process.env.ENV_FILE,
                    example: '../../config/development/dev.env',
                });
        const envPlugin = {
            plugins: [
                new webpack.DefinePlugin({
                    "__ENV__": JSON.stringify(dotenv.parsed)
                }),
            ],
        }
        config.builders.web.webpackConfig = merge(config.builders.web.webpackConfig, envPlugin);
    }
}

config.options.defines = Object.assign(config.options.defines, extraDefines);
module.exports = config;
\`\`\`

## servers/frontend-server/src/app/500.tsx

\`\`\`tsx
import * as React from 'react';
import { Result, Button } from 'antd';

export const Error500 = ({ error }: any) => {
    React.useEffect(() => {
        console.trace(error);
    }, [error]);

    return (
        <Result
            title="500"
            status="500"
            subTitle={`Sorry, the server is wrong. Error: ${error}`}
            extra={<Button href={process.env.CLIENT_URL} type="primary">Back Home</Button>}
        />
    );
}

\`\`\`

## servers/frontend-server/src/app/ErrorBoundary.tsx

\`\`\`tsx
import * as React from 'react';
import { Error500 } from './500';
import { ServerError } from './ServerError';

type IErrorBoundryState = { error: any, type: string }


export class ErrorBoundary extends React.Component<any, IErrorBoundryState> {
    constructor(props) {
        super(props);
        const serverError: any = __CLIENT__ ? window.__SERVER_ERROR__ : null;
        if (serverError) {
            this.state = { error: new ServerError(serverError), type: 'serverError' };
        } else {
            this.state = { error: undefined, type: undefined };
        }
    }

    componentDidCatch(error) {
        let type = undefined;

        if (process.env.NODE_ENV === 'production') {
            type = '404'
        } else {
            type = '500'
        }
        // Update state so the next render will show the fallback UI.
        this.setState({ error, type });
    }


    render() {
        const { error, type } = this.state;
        if (error) {
            return <Error500 error={error} />
        }
        return this.props.children;
    }
}
\`\`\`

## servers/frontend-server/src/app/Main.tsx

\`\`\`tsx
/// <reference path='../../../../typings/index.d.ts' />
import { hot } from 'react-hot-loader/root';
import * as React from 'react';
import { RendererProvider } from 'react-fela';
import { ApolloProvider } from '@apollo/client';
import { Provider } from 'react-redux';
import { rehydrate } from 'fela-dom';
import { ConnectedRouter } from 'connected-react-router';
import { PersistGate } from 'redux-persist/integration/react';
import { persistStore } from 'redux-persist';
import createRenderer from '../config/fela-renderer';
import { createReduxStore } from '../config/redux-config';
import { createClientContainer } from '../config/client.service';
import modules, { MainRoute } from '../modules';
import { ErrorBoundary } from './ErrorBoundary';

const { apolloClient: client } = createClientContainer();

const { store, history } = createReduxStore();

export class Main extends React.Component<{}, {}> {
  public render() {
    const renderer = createRenderer();
    let persistor = persistStore(store);
    rehydrate(renderer);
    return (
      <ErrorBoundary>
        <Provider store={store}>
          <ApolloProvider client={client}>
            <RendererProvider renderer={renderer}>
              <PersistGate persistor={persistor}>
                {modules.getWrappedRoot(
                  (
                    <ConnectedRouter history={history}>
                      <MainRoute />
                    </ConnectedRouter>
                  ),
                )}
              </PersistGate>
            </RendererProvider>
          </ApolloProvider>
        </Provider>
      </ErrorBoundary>
    );
  }
}

export default hot(Main);

\`\`\`

## servers/frontend-server/src/app/ServerError.tsx

\`\`\`tsx

class ServerError extends Error {
    constructor(error: any) {
        super();
        for (const key of Object.getOwnPropertyNames(error)) {
            this[key] = error[key];
        }
        this.name = 'ServerError';
    }
}

export { ServerError };
\`\`\`

## servers/frontend-server/src/backend/app.ts

\`\`\`ts
// tslint:disable-next-line:no-unused-expression
process.env.ENV_FILE !== null && (require('dotenv')).config({ path: process.env.ENV_FILE });

import { logger } from '@cdm-logger/server';
import './server';

process.on('uncaughtException', ex => {
    logger.error(ex);
    process.exit(1);
});

process.on('unhandledRejection', reason => {
    logger.error(reason);
});

if ((module as any).hot) {
    (module as any).hot.status(event => {
        if (event === 'abort' || event === 'fail') {
            logger.error('HMR error status: ' + event);
            // Signal webpack.run.js to do full-reload of the back-end
            process.exit(250);
        }
    });

    (module as any).hot.accept();
}

\`\`\`

## servers/frontend-server/src/backend/middlewares/cors.ts

\`\`\`ts
import cors from 'cors';
import { config } from '../../config';
import { logger } from '@common-stack/client-core';

const CLIENT_URL = config.CLIENT_URL;
const BACKEND_URL = config.BACKEND_URL;


const corsWhitelist = [
    CLIENT_URL,
    BACKEND_URL,
];
logger.info('corsWhitelist (%j)', corsWhitelist);

const corsOptions: cors.CorsOptions = {
    origin: (origin, callback) => {
        if (corsWhitelist.indexOf(origin) !== -1) {
            callback(null, true);
        } else {
            // TODO: only throw when in debug mode
            logger.error('url (%s) is not in the whitelist', origin);
            // callback(new Error('Not allowed by CORS'))
            logger.warn('allowing all origins temporarily, you need to disable it.');
            callback(null, true);
        }
    },
    credentials: false,
};

export const corsMiddleware = cors(corsOptions);

\`\`\`

## servers/frontend-server/src/backend/middlewares/error.ts

\`\`\`ts
/// <reference path='../../../../../typings/index.d.ts' />

import * as path from 'path';
import * as fs from 'fs';
import * as url from 'url';
import { logger } from '@cdm-logger/server';


let assetMap;

const stripCircular = (from, seen?: any) => {
    const to = Array.isArray(from) ? [] : {};
    seen = seen || [];
    seen.push(from);
    Object.getOwnPropertyNames(from).forEach(key => {
        if (!from[key] || (typeof from[key] !== 'object' && !Array.isArray(from[key]))) {
            to[key] = from[key];
        } else if (seen.indexOf(from[key]) < 0) {
            to[key] = stripCircular(from[key], seen.slice(0));
        } else { to[key] = '[Circular]'; }
    });
    return to;
};

const { pathname } = url.parse(__BACKEND_URL__);

export const errorMiddleware =
    (e, req, res, next) => {
        if (req.path === pathname) {
            const stack = e.stack.toString().replace(/[\n]/g, '\\n');
            res.status(200).send(`[{"data": {}, "errors":[{"message": "${stack}"}]}]`);
        } else {
            logger.error(e);

            if (__DEV__ || !assetMap) {
                assetMap = JSON.parse(fs.readFileSync(path.join(__FRONTEND_BUILD_DIR__, 'assets.json')).toString());
            }

            const serverErrorScript = `<script charset="UTF-8">window.__SERVER_ERROR__=${JSON.stringify(
                stripCircular(e),
            )};</script>`;
            const vendorScript = assetMap['vendor.js']
                ? `<script src="/${assetMap['vendor.js']}" charSet="utf-8"></script>`
                : '';

            res.status(200).send(
                `<html>${serverErrorScript}<body><div id="content"></div>
        ${vendorScript}
            <script src="/${assetMap['index.js']}" charSet="utf-8"></script>
            </body></html>`,
            );
        }
    };



\`\`\`

## servers/frontend-server/src/backend/modules/index.ts

\`\`\`ts
import modules from './modules';
export default modules;

\`\`\`

## servers/frontend-server/src/backend/modules/modules.ts

\`\`\`ts
import { Feature } from '@common-stack/server-core';

export default new Feature({});


\`\`\`

## servers/frontend-server/src/backend/server.ts

\`\`\`ts
import 'reflect-metadata';
import express from 'express';
import * as bodyParser from 'body-parser';
import * as http from 'http';
import * as path from 'path';
import * as url from 'url';
import 'isomorphic-fetch';
import { logger } from '@cdm-logger/server';
import { websiteMiddleware } from './website';
import { corsMiddleware } from './middlewares/cors';
import { errorMiddleware } from './middlewares/error';
import { config } from '../config';
const cookiesMiddleware = require('universal-cookie-express');
import modules from './modules';

let server;

const app = express();


app.use(corsMiddleware);
app.options('*', corsMiddleware);

for (const applyBeforeware of modules.beforewares) {
    applyBeforeware(app);
}

app.use(cookiesMiddleware());


// By default it uses backend_url port, which may conflict with graphql server.
const { port: serverPort } = url.parse(config.LOCAL_BACKEND_URL);

// Don't rate limit heroku
app.enable('trust proxy');

app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());

app.use(
    '/',
    express.static(path.join(__FRONTEND_BUILD_DIR__, 'web'), {
        maxAge: '180 days',
    }),
);


if (__DEV__) {
    app.use('/', express.static(__DLL_BUILD_DIR__, { maxAge: '180 days' }));
}

app.use(websiteMiddleware);

if (__DEV__) {
    app.use(errorMiddleware);
}

server = http.createServer(app);

server.listen(serverPort, () => {
    logger.info(`Client Server is now running on port ${serverPort}`);
});

server.on('close', () => {
    server = undefined;
});

if ((module as any).hot) {
    (module as any).hot.dispose(() => {
        try {
            if (server) {
                server.close();
            }
        } catch (error) {
            logger.error(error.stack);
        }
    });
    (module as any).hot.accept(['./website'], () => {
        logger.debug('...reloading middleware');
    });

    (module as any).hot.accept();
}


export default server;

\`\`\`

## servers/frontend-server/src/backend/ssr/html.tsx

\`\`\`tsx
/// <reference path='../../../../../typings/index.d.ts' />

import * as React from 'react';
import serialize from 'serialize-javascript';
import { HelmetData } from 'react-helmet';
import modules from '../../modules';

/**
 * A simple herlper function to prepare the HTML markup. This loads:
 *      - Page title
 *      - SEO meta tags
 *      - Preloaded state (for Redux, Apollo, additional Environment variables) depending on the current route
 *      - Code-split script tags depending on the current route
 * @param param0
 */
const Html = ({
    content,
    state,
    reduxState,
    fela,
    env,
    assetMap,
    styleSheet,
    helmet,
}:
    { content?: any, state: any, reduxState: any, assetMap?: string[], env: any, fela?: any, styleSheet?: any[], helmet?: HelmetData }) => {
    const htmlAttrs = helmet.htmlAttributes.toComponent(); // react-helmet html document tags
    const bodyAttrs = helmet.bodyAttributes.toComponent(); // react-helmet body document tags

    return (
        <html lang="en" {...htmlAttrs}>
            <head>
                {helmet.title.toComponent()}
                {helmet.meta.toComponent()}
                {helmet.link.toComponent()}
                <meta charSet="utf-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" />
                {<link rel="stylesheet" type="text/css" href={`${assetMap['index.css']}`} />}
                {assetMap['vendor.css'] && <link rel="stylesheet" type="text/css" href={`${assetMap['vendor.css']}`} />}
                <style id="font-stylesheet" />
                {!!__DEV__ && (
                    <style
                        dangerouslySetInnerHTML={{
                            __html: modules.stylesInserts.map(style => style._getCss()).join(''),
                        }}
                    />
                )}
                {styleSheet.map(({ type, rehydration, css, media, support }) => (
                    <style
                        id="stylesheet"
                        dangerouslySetInnerHTML={{ __html: css }}
                        data-fela-rehydration={rehydration}
                        data-fela-type={type}
                        data-fela-support={support}
                        key={`${type}-${media}`}
                        media={media}
                    />
                ))}
                {modules.scriptsInserts.map((script, i) => {
                    if (script) {
                        return <script key={i} src={script} />;
                    }
                })}
            </head>
            <body {...bodyAttrs}>
                <div id="root"/>
                <div className="demo">
                    <div
                        id="content"
                        dangerouslySetInnerHTML={
                            {
                                __html: content ||
                                    'Try building the app:<br/> ...and refreshing this page!',
                            }}
                    />
                </div>
                <script
                    dangerouslySetInnerHTML={{
                        __html: `window.__ENV__=${serialize(env, {
                            isJSON: true,
                        })};`,
                    }}
                    charSet="UTF-8"
                />
                <script
                    dangerouslySetInnerHTML={{
                        __html: `window.__APOLLO_STATE__=${serialize(state, {
                            isJSON: true,
                        })};`,
                    }}
                    charSet="UTF-8"
                />
                <script
                    dangerouslySetInnerHTML={{
                        __html: `window.__PRELOADED_STATE__=${serialize(reduxState, {
                            isJSON: true,
                        })};`,
                    }}
                    charSet="UTF-8"
                />
                {assetMap['vendor.js'] && <script src={`${assetMap['vendor.js']}`} charSet="utf-8" />}
                <script src={`${assetMap['index.js']}`} charSet="utf-8" />
            </body>
        </html>
    );
};

export { Html };

\`\`\`

## servers/frontend-server/src/backend/website.tsx

\`\`\`tsx
import * as React from 'react';
import * as ReactDOMServer from 'react-dom/server';
import { ApolloProvider } from '@apollo/client';
import { getDataFromTree } from '@apollo/client/react/ssr';
import { Html } from './ssr/html';
import Helmet from 'react-helmet';
import path from 'path';
import fs from 'fs';
import { renderToMarkup, renderToSheetList } from 'fela-dom';
import { Provider as ReduxProvider } from 'react-redux';
import { StaticRouter } from 'react-router';
import { logger } from '@cdm-logger/server';
import { createClientContainer } from '../config/client.service';
import * as ReactFela from 'react-fela';
import createRenderer from '../config/fela-renderer';
import { createReduxStore } from '../config/redux-config';
import publicEnv from '../config/public-config';
import clientModules from '../modules';

let assetMap;
async function renderServerSide(req, res) {
    try {

        const { apolloClient: client } = createClientContainer();

        let context: { pageNotFound?: boolean, url?: string } = { pageNotFound: false };
        const { store } = createReduxStore();
        const renderer = createRenderer();
        const App = () =>
            clientModules.getWrappedRoot(
                // tslint:disable-next-line:jsx-wrap-multiline
                <ReduxProvider store={store} >
                    <ApolloProvider client={client}>
                        <ReactFela.Provider renderer={renderer} >
                            <StaticRouter location={req.url} context={context}>
                                {clientModules.getRouter()}
                            </StaticRouter>
                        </ReactFela.Provider>
                    </ApolloProvider>
                </ReduxProvider>,
                req,
            );

        await getDataFromTree(App);
        if (context.pageNotFound === true) {
            res.status(404);
        } else {
            res.status(200);
        }

        const html = ReactDOMServer.renderToString(App as any);

        // this comes after Html render otherwise we don't see fela rules generated
        const appStyles = renderToSheetList(renderer);

        // We need to tell Helmet to compute the right meta tags, title, and such.
        const helmet = Helmet.renderStatic(); // Avoid memory leak while tracking mounted instances

        if (context.url) {
            res.writeHead(301, { Location: context.url });
            res.end();
        } else {
            if (__DEV__ || !assetMap) {
                assetMap = JSON.parse(fs.readFileSync(path.join(__FRONTEND_BUILD_DIR__, 'web', 'assets.json')).toString());
            }
            const apolloState = Object.assign({}, client.extract());
            const reduxState = Object.assign({}, store.getState());
            const env = {
                ...publicEnv,
            };
            const page = (
                <Html
                    content={html}
                    state={apolloState}
                    assetMap={assetMap}
                    helmet={helmet}
                    styleSheet={appStyles}
                    env={env}
                    reduxState={reduxState}
                />
            );
            res.send(`<!doctype html>\n${ReactDOMServer.renderToStaticMarkup(page)}`);
            res.end();
        }
    } catch (err) {
        logger.error('SERVER SIDE RENDER failed due to (%j) ', err.message);
        logger.debug(err);
    }
}
export const websiteMiddleware = async (req, res, next) => {
    try {
        if (req.path.indexOf('.') < 0 && __SSR__) {
            return await renderServerSide(req, res);
        } else if (req.path.indexOf('.') < 0 && !__SSR__ && req.method === 'GET' && !__DEV__) {
            logger.debug('FRONEND_BUILD_DIR with index.html')
            res.sendFile(path.resolve(__FRONTEND_BUILD_DIR__, 'index.html'));
        } else {
            next();
        }
    } catch (e) {
        logger.error('RENDERING ERROR:', e);
        return next(e);
    }
};

\`\`\`

## servers/frontend-server/src/config/__mocks__/mockFetch.ts

\`\`\`ts
import 'whatwg-fetch';


// This is an implementation of a mocked window.fetch implementation similar in
// structure to the MockedNetworkInterface.


export interface MockedIResponse {
    ok: boolean;
    status: number;
    statusText?: string;
    json(): Promise<Object>;
}

export interface MockedFetchResponse {
    url: string;
    opts: RequestInit;
    result: MockedIResponse;
    delay?: number;
}

export function createMockedIResponse(
    result: Object,
    options?: any,
): MockedIResponse {
    const status = (options && options.status) || 200;
    const statusText = (options && options.statusText) || undefined;

    return {
        ok: status === 200,
        status,
        statusText,
        json() {
            return Promise.resolve<Object>(result);
        },
    };
}

export class MockFetch {
    private mockedResponsesByKey: { [key: string]: MockedFetchResponse[] };

    constructor(...mockedResponse: MockedFetchResponse[]) {
        this.mockedResponsesByKey = {};

        mockedResponses.forEach(mockedResponse => {
            this.addMockedResponse(mockedResponse);
        });
    }

    public addMockedResponse(mockedResponse: MockedFetchResponse) {
        const key = this.fetchParamsToKey(mockedResponse.url, mockedResponse.opts);
        let mockedResponses = this.mockedResponsesByKey[key];

        if (!mockedResponses) {
            mockedResponses = [];
            this.mockedResponsesByKey[key] = mockedResponses;
        }

        mockedResponses.push(mockedResponse);
    }

    public fetch(url: string, opts: RequestInit) {
        const key = this.fetchParamsToKey(url, opts);
        const responses = this.mockedResponsesByKey[key];
        if (!responses || response.length === 0) {
            throw new Error(
                `No more mocked fetch responses for the params ${url} and ${opts}`,
            );
        }

        const { result, delay } = responses.shift();

        if (!result) {
            throw new Error(`Mocked fetch response should contain a result.`);
        }

        return new Promise((resolve) => {
            setTimeout(() => {
                resolve(result);
            }, delay ? delay : 0);
        });
    }

    public fetchParamsToKey(url: string, opts: RequestInit): string {
        return JSON.stringify({
            url,
            opts: sortByKey(opts),
        });
    }
}
\`\`\`

## servers/frontend-server/src/config/__mocks__/mockWatchQuery.ts

\`\`\`ts

\`\`\`

## servers/frontend-server/src/config/__tests__/apollo-client-subscribe-to-more.ts

\`\`\`ts
import gql from 'graphql-tag';
import { Operation } from '@apollo/client';
import { InMemoryCache } from 'apollo-cache-inmemory';
import { DocumentNode, OperationDefinitionNode } from 'graphql';
import { mockSingleLink, mockObservableLink } from '@apollo/client/testing';


const isSub = (operation: Operation) =>
    (operation.query as DocumentNode).definitions
        .filter(x => x.kind === 'OperationDefinition')
        .some((x: OperationDefinitionNode) => x.operation === 'subscription');

describe('subscribeToMore', () => {
    const query = gql`
        query aQuery {
            entry {
                value
            }
        }
    `;
    const result = {
        data: {
            entry: {
                value: '1',
            },
        },
    };

    const req1 = { request: { query } as Operation, result };

    const results = ['Dahivat Pandya', 'Amanda Liu'].map(name => ({
        result: { data: { name } },
        delay: 10,
    }));

    const results2 = [
        { result: { data: { name: 'Amanda Liu' } }, delay: 10 },
        { error: new Error('You cant touch this'), delay: 10 },
    ];

    const results3 = [
        { error: new Error('You cant touch this'), delay: 10 },
        { result: { data: { name: 'Amanda Liu' } }, delay: 10 },
    ];

    const result4 = {
        data: {
            entry: [{ value: '1' }, { value: '2' }],
        },
    };
    const req4 = { request: { query } as Operation, result: result4 };


});

\`\`\`

## servers/frontend-server/src/config/base-apollo-client.ts

\`\`\`ts
// version 09/18/2021
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
import { ApolloClient, ApolloClientOptions, ApolloLink } from '@apollo/client';
import { InMemoryCache } from '@apollo/client/cache';
import { HttpLink, createHttpLink } from '@apollo/client/link/http';
import { BatchHttpLink } from '@apollo/client/link/batch-http';
import { onError } from '@apollo/client/link/error';
import { WebSocketLink } from '@apollo/client/link/ws';
import { getOperationAST } from 'graphql';
import { invariant } from 'ts-invariant';
import { IClientState } from '@common-stack/client-core';
import fetch from 'node-fetch';
import { ConnectionParams } from 'subscriptions-transport-ws';
import { isBoolean, merge } from 'lodash';
import { CdmLogger } from '@cdm-logger/core';
import { RetryLink } from '@apollo/client/link/retry';

const schema = `

`;

interface IApolloClientParams {
    initialState?: any;
    scope: 'browser' | 'server' | 'native';
    getDataIdFromObject: (x?: any) => string;
    clientState: IClientState;
    isDebug: boolean;
    isDev: boolean;
    isSSR: boolean;
    httpGraphqlURL: string;
    httpLocalGraphqlURL: string;
    logger: CdmLogger.ILogger;
}

const errorLink = onError(({ graphQLErrors, networkError }) => {
    if (graphQLErrors) {
        graphQLErrors.map(({ message, locations, path }) =>
            // tslint:disable-next-line
            invariant.warn(`[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`),
        );
    }
    if (networkError) {
        // tslint:disable-next-line
        invariant.warn(`[Network error]: ${networkError}`);
    }
});

let _apolloClient: ApolloClient<any>;
let _memoryCache: InMemoryCache;
export const createApolloClient = ({
    scope,
    isDev,
    isDebug,
    isSSR,
    getDataIdFromObject,
    clientState,
    httpGraphqlURL,
    httpLocalGraphqlURL,
    initialState,
    logger,
}: IApolloClientParams) => {
    const isBrowser = scope === 'browser';
    const isServer = scope === 'server';
    let link;

    const cache = new InMemoryCache({
        dataIdFromObject: getDataIdFromObject,
        possibleTypes: clientState.possibleTypes,
    });

    const attemptConditions = async (count: number, operation: any, error: Error) => {
        const promises = (clientState.retryLinkAttemptFuncs || []).map((func) => func(count, operation, error));

        try {
            const result = await promises;
            return !!result.find((item) => item && isBoolean(item));
        } catch (e) {
            logger.trace('Error occured in retryLink Attempt condition', e);
            throw e;
        }
    };

    const retrylink = new RetryLink({
        attempts: attemptConditions,
    });

    if (_apolloClient && _memoryCache) {
        // return quickly if client is already created.
        return {
            apolloClient: _apolloClient,
            cache: _memoryCache,
        };
    }
    _memoryCache = cache;
    if (isBrowser) {
        const connectionParams = async () => {
            const param: ConnectionParams = {};
            for (const connectionParam of clientState.connectionParams) {
                merge(param, await connectionParam);
            }
            return param;
        };

        const wsLink = new WebSocketLink({
            uri: httpGraphqlURL.replace(/^http/, 'ws'),
            options: {
                reconnect: true,
                timeout: 20000,
                reconnectionAttempts: 10,
                lazy: true,
                connectionParams,
                connectionCallback: async (error, result) => {
                    if (error) {
                        logger.error(error, '[WS connectionCallback error] %j');
                    }
                    const promises = (clientState.connectionCallbackFuncs || []).map((func) =>
                        func(wsLink, error, result),
                    );
                    try {
                        await promises;
                    } catch (e) {
                        logger.trace('Error occured in connectionCallback condition', e);
                        throw e;
                    }
                },
            },
            inactivityTimeout: 10000,
        });

        link = ApolloLink.split(
            ({ query, operationName }) => {
                if (operationName.endsWith('_WS')) {
                    return true;
                }
                const operationAST = getOperationAST(query as any, operationName);
                return !!operationAST && operationAST.operation === 'subscription';
            },
            wsLink,
            new HttpLink({
                uri: httpGraphqlURL,
            }),
        );
    } else if (isServer) {
        link = new BatchHttpLink({ uri: httpLocalGraphqlURL, fetch: fetch as any });
    } else {
        link = createHttpLink({ uri: httpLocalGraphqlURL, fetch: fetch as any });
    }

    const links = [errorLink, retrylink, ...(clientState.preLinks || []), link];

    // Add apollo logger during development only
    if (isBrowser && (isDev || isDebug)) {
        const apolloLogger = require('apollo-link-logger');
        links.unshift(apolloLogger.default);
    }

    const params: ApolloClientOptions<any> = {
        queryDeduplication: true,
        typeDefs: schema.concat(<string>clientState.typeDefs),
        resolvers: clientState.resolvers as any,
        link: ApolloLink.from(links),
        cache,
        connectToDevTools: isBrowser && (isDev || isDebug),
    };
    if (isSSR) {
        if (isBrowser) {
            if (initialState) {
                cache.restore(initialState);
            }
            params.ssrForceFetchDelay = 100;
        } else if (isServer) {
            params.ssrMode = true;
        }
    }
    _apolloClient = new ApolloClient<any>(params);

    clientState?.defaults?.forEach((x) => {
        if (x.type === 'query') {
            cache.writeQuery(x);
        } else if (x.type === 'fragment') {
            cache.writeFragment(x);
        }
    });

    return { apolloClient: _apolloClient, cache };
};

\`\`\`

## servers/frontend-server/src/config/base-redux-config.ts

\`\`\`ts
// version 11/12/2021
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable global-require */
/* eslint-disable no-underscore-dangle */
import {
    createStore,
    combineReducers,
    applyMiddleware,
    StoreEnhancer,
    Middleware,
    compose,
    Action,
    ReducersMapObject,
    PreloadedState,
} from 'redux';
import { EpicMiddleware, Epic } from 'redux-observable';
import { persistReducer, PersistConfig } from 'redux-persist';

interface IReduxStore<S = any> {
    scope: 'browser' | 'server' | 'native' | 'ElectronMain';
    isDebug: boolean;
    isDev: boolean;
    reducers: ReducersMapObject<S>;
    rootEpic?: Epic<Action<S>, Action<any>, void, any>;
    epicMiddleware?: EpicMiddleware<Action<S>, Action<any>>;
    preMiddleware?: Middleware[];
    postMiddleware?: Middleware[];
    middleware?: Middleware[];
    initialState: PreloadedState<S>;
    persistConfig?: PersistConfig<S, any>;
}
/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = ({
    scope,
    isDebug,
    isDev,
    reducers,
    rootEpic,
    epicMiddleware,
    preMiddleware,
    postMiddleware,
    middleware,
    initialState = {},
    persistConfig,
}: IReduxStore<any>) => {
    const isBrowser = scope === 'browser';
    const isElectronMain = scope === 'ElectronMain';
    /**
     * Add middleware that required for this app.
     */

    const middlewares: Middleware[] = [];
    // add epicMiddleware
    if (epicMiddleware) {
        middlewares.push(epicMiddleware);
    }
    if (preMiddleware) {
        middlewares.unshift(...preMiddleware);
    }
    // Add redux logger during development only
    if ((isDev || isDebug) && isBrowser) {
        const { createLogger } = require('redux-logger');

        middlewares.push(
            createLogger({
                level: 'info',
                collapsed: true,
            }),
        );
    }

    if (middleware) {
        middlewares.push(...middleware);
    }

    if (postMiddleware) {
        middlewares.push(...postMiddleware);
    }

    const enhancers: () => StoreEnhancer<any>[] = () => [applyMiddleware(...middlewares)];

    const composeEnhancers: any =
        ((isDev || isDebug) && isBrowser && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) || compose;

    const rootReducer = combineReducers(reducers);
    const persistedReducer = persistConfig ? persistReducer(persistConfig, rootReducer) : rootReducer;

    const store = createStore(persistedReducer, initialState, composeEnhancers(...enhancers()));
    if (isBrowser || isElectronMain) {
        // no SSR for now
        if (epicMiddleware) {
            epicMiddleware.run(rootEpic);
        }
    }

    return store;
};

\`\`\`

## servers/frontend-server/src/config/client.service.ts

\`\`\`ts
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable import/no-extraneous-dependencies */
import { ClientTypes } from '@common-stack/client-core';
import { Container } from 'inversify';
import { ApolloClient } from '@apollo/client';
import { CdmLogger } from '@cdm-logger/core';
import modules, { container, logger } from '../modules';
import { createApolloClient } from './base-apollo-client';
import { PUBLIC_SETTINGS } from './public-config';

let __CLIENT_SERVICE__: {
    apolloClient: ApolloClient<any>;
    container: Container;
    services: any;
    logger: CdmLogger.ILogger;
};
export const createClientContainer = () => {
    if (__CLIENT_SERVICE__) {
        return __CLIENT_SERVICE__;
    }
    const clientState = modules.getStateParams({ resolverContex: () => modules.createService({}, {}) });
    const { cache, apolloClient } = createApolloClient({
        httpGraphqlURL: PUBLIC_SETTINGS.GRAPHQL_URL,
        httpLocalGraphqlURL: PUBLIC_SETTINGS.LOCAL_GRAPHQL_URL,
        isDev: process.env.NODE_ENV === 'development',
        isDebug: __DEBUGGING__,
        isSSR: __SSR__,
        scope: __CLIENT__ ? 'browser' : 'server',
        clientState,
        getDataIdFromObject: (result) => modules.getDataIdFromObject(result),
        initialState: null,
        logger,
    });
    // attaching the context to client as a workaround.
    container.bind(ClientTypes.ApolloClient).toConstantValue(apolloClient);
    container.bind(ClientTypes.InMemoryCache).toConstantValue(cache);
    const services = modules.createService({}, {});
    (apolloClient as any).container = services;

    __CLIENT_SERVICE__ = {
        container,
        apolloClient,
        services,
        logger,
    };
    if ((module as any).hot) {
        (module as any).hot.dispose(() => {
            // Force Apollo to fetch the latest data from the server
            delete window.__APOLLO_STATE__;
        });
    }
    return __CLIENT_SERVICE__;
};

\`\`\`

## servers/frontend-server/src/config/config.ts

\`\`\`ts
import * as envalid from 'envalid';

const { str, bool, num } = envalid;

export const config = envalid.cleanEnv(process.env, {
    NODE_ENV: str({ default: 'production', choices: ['production', 'staging', 'development', 'test'] }),
    BACKEND_URL: str({ devDefault: __BACKEND_URL__ }),
    LOCAL_BACKEND_URL: str({ devDefault: __BACKEND_URL__ }),
    LOCAL_GRAPHQL_URL: str({ default: __GRAPHQL_URL__ }),
    GRAPHQL_URL: str({ devDefault: __GRAPHQL_URL__ }),
    LOG_LEVEL: str({ devDefault: 'trace' }),
    APP_NAME: str({ devDefault: 'FullStack' }),
    CLIENT_URL: str({ devDefault: __BACKEND_URL__ }),
    CONNECTION_ID: str({ devDefault: 'CONNECTION_ID' }),
    NAMESPACE: str({ default: 'default' }),
});

\`\`\`

## servers/frontend-server/src/config/epic-config.ts

\`\`\`ts
import { combineEpics, ofType } from 'redux-observable';
import { BehaviorSubject } from 'rxjs';
import { mergeMap, takeUntil } from 'rxjs/operators';
import modules from '../modules';

export const epic$ = new BehaviorSubject(combineEpics(...modules.epics));

// Since we're using mergeMap, by default any new
// epic that comes in will be merged into the previous
// one, unless an EPIC_END action is dispatched first,
// which would cause the old one(s) to be unsubscribed
export const rootEpic = (action$, ...rest) =>
    epic$.pipe(mergeMap((epic) => epic(action$, ...rest).pipe(takeUntil(action$.pipe(ofType('EPIC_END'))))));

\`\`\`

## servers/frontend-server/src/config/fela-renderer.ts

\`\`\`ts
import { createRenderer, IRenderer } from 'fela';
import webPreset from 'fela-preset-web';

export default () => {
  const renderer = createRenderer({
    plugins: [
      ...webPreset,
    ],
    devMode: process.env.NODE_ENV ? process.env.NODE_ENV !== 'production' : false,
  });
  renderer.renderStatic(
    `
        html, body, #demo, .content{
            height: 100%;
          }
          body {
            background-color: #fff;
            color: #ccc;
            padding: 0;
            margin: 0;
            font-family: sans-serif;
            font-size: 13px;
          }
          div, a {
            outline: none !important;
          }
          a {
            text-decoration: none;
            cursor: pointer;
          }
          footer {
            position:fixed;
            bottom: 0;
            left: 0;
            right:0;
            height: 20px;
            background: #007acc;
          }
          footer > .container {
            padding: 2px;
          }
          #content {
            height: calc(100vh - 20px);
          }
          #container {
            height: 100%;
          }
          .editor-container {
            height: 100%;
            overflow: hidden;
          }
          .error {
            color: orangered;
          }
        `,
  );

  return renderer;
};


\`\`\`

## servers/frontend-server/src/config/index.ts

\`\`\`ts
export * from './config';

\`\`\`

## servers/frontend-server/src/config/public-config.ts

\`\`\`ts
/// <reference path='../../../../typings/index.d.ts' />
import { logger } from '@cdm-logger/client';
import { lowerCase } from 'lodash';

/**
 * This file opens up in public site, so make sure it is
 * not dependent on any other file that compromises the security.
 */
const publicEnv = [
    'NODE_ENV',
    'GRAPHQL_URL',
    'FACEBOOK_APP_ID',
    'GA_ID',
    'LOG_LEVEL',
];

const isBrowser = typeof window !== 'undefined';
const base = (isBrowser ? ( window.__ENV__ || __ENV__) : process.env) || {};

const env: any = {};
for (const v of publicEnv) {
    env[v] = base[v];
}

export default env;

if (isBrowser) {
    process[lowerCase('env')] = env; // to avoid webpack to replace `process` with actual value.
    process.APP_ENV = env;
}

try {
    global.process = process;
    logger.info('Process Update Success!');
} catch (e) {
    logger.warn(e);
    logger.info('Encountered above issue while running "global.process = process", will automatically try again in next render');

}
export const PUBLIC_SETTINGS: __PUBLIC_SETTINGS__ = {
    apolloLogging: false,
    GRAPHQL_URL: process.env.GRAPHQL_URL || env.GRAPHQL_URL || __GRAPHQL_URL__,
    LOCAL_GRAPHQL_URL: process.env.LOCAL_GRAPHQL_URL || __GRAPHQL_URL__,
    LOG_LEVEL: process.env.LOG_LEVEL || 'trace',
};

\`\`\`

## servers/frontend-server/src/config/redux-config.ts

\`\`\`ts
/* eslint-disable no-param-reassign */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable global-require */
import storage from 'redux-persist/lib/storage';
import { combineReducers } from 'redux';
import autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2';
import { createEpicMiddleware } from 'redux-observable';
import { connectRouter, routerMiddleware } from 'connected-react-router';
import { persistReducer } from 'redux-persist';
import thunkMiddleware from 'redux-thunk';
import { createReduxStore as createBaseReduxStore } from './base-redux-config';
import modules, { logger } from '../modules';
import { createClientContainer } from './client.service';
import { rootEpic, epic$ } from './epic-config';

const history = require('./router-history');

const { apolloClient, container, services } = createClientContainer();

export const epicMiddleware = createEpicMiddleware({
    dependencies: {
        apolloClient,
        routes: modules.getConfiguredRoutes(),
        services,
        container,
        logger,
    },
});

export const persistConfig = {
    key: 'root',
    storage,
    stateReconciler: autoMergeLevel2,
    transforms: modules.reduxPersistStateTransformers,
};

export const storeReducer = (hist) =>
    combineReducers({
        router: connectRouter(hist),
        ...modules.reducers,
    });

/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = (url = '/') => {
    // only in server side, url will be passed.
    const newHistory = __CLIENT__ ? history : history(url);
    // middleware
    const router = connectRouter(newHistory);

    let store;
    if ((module as any).hot && (module as any).hot.data && (module as any).hot.data.store) {
        // console.log('Restoring Redux store:', JSON.stringify((module as any).hot.data.store.getState()));
        store = (module as any).hot.data.store;
        // replace the reducers always as we don't have ablity to find
        // new reducer added through our `modules`
        store.replaceReducer(
            persistReducer(persistConfig, storeReducer((module as any).hot.data.history || newHistory)),
        );
        // store.replaceReducer(storeReducer((module as any).hot.data.history || history));
    } else {
        // If we have preloaded state, save it.
        const initialState = __CLIENT__
            ? { ...window.__PRELOADED_STATE__ } // #952 TODO we need cookie to have id_token for SSR to work properly
            : {};
        // Delete it once we have it stored in a variable
        if (__CLIENT__) {
            delete window.__PRELOADED_STATE__;
        }
        store = createBaseReduxStore({
            scope: __CLIENT__ ? 'browser' : 'server',
            isDebug: true,
            isDev: process.env.NODE_ENV === 'development',
            initialState,
            persistConfig,
            middleware: [thunkMiddleware, routerMiddleware(newHistory)],
            epicMiddleware,
            rootEpic: rootEpic as any,
            reducers: { router, ...modules.reducers },
        });
    }
    if ((module as any).hot) {
        (module as any).hot.dispose((data) => {
            // console.log("Saving Redux store:", JSON.stringify(store.getState()));
            data.store = store;
            data.history = history;
        });
        (module as any).hot.accept('../config/epic-config', () => {
            // we may need to reload epic always as we don't
            // know whether it is updated using our `modules`
            const nextRootEpic = require('./epic-config').rootEpic;
            // First kill any running epics
            store.dispatch({ type: 'EPIC_END' });
            // Now setup the new one
            epic$.next(nextRootEpic);
        });
    }
    container.bind('ReduxStore').toConstantValue(store);
    return { store, history };
};

\`\`\`

## servers/frontend-server/src/config/router-history.ts

\`\`\`ts
import { createBrowserHistory, createMemoryHistory } from 'history';

if (__CLIENT__) {
    module.exports = createBrowserHistory();
} else {
    module.exports = (url) =>
        createMemoryHistory({
            initialEntries: [url],
        });
}

\`\`\`

## servers/frontend-server/src/index.tsx

\`\`\`tsx
import 'reflect-metadata';
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-explicit-any */
import 'antd/dist/antd.css';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
// load environment config
import './config/public-config';
import Main from './app/Main';

// Virtual (module as any), generated in-memory by zenjs, contains count of backend rebuilds
// tslint:disable-next-line
import 'backend_reload';

const rootEl = document.getElementById('content');
let frontendReloadCount = 0;

const renderApp = ({ key }: { key: number }) => ReactDOM.render(<Main key={key} />, rootEl);
renderApp({ key: frontendReloadCount });
if (__DEV__) {
    if ((module as any).hot) {
        (module as any).hot.accept();
        (module as any).hot.accept('backend_reload', () => {
            // log.debug('Reloading front-end');
            // when the backend restarts wait for 5 seconds
            setTimeout(() => window.location.reload(), 5000);
            // window.location.reload();
        });
        (module as any).hot.accept((err) => {
            if (err) {
                console.error('Cannot apply HMR update.', err);
            }
        });
        //  React-hot-loader v4 doesn't require following code any more.
        //  but if RHL not working we can uncomment below code to make normal HMR to refresh the page
        (module as any).hot.accept('./app/Main', () => {
            try {
                console.log('Updating front-end');
                frontendReloadCount = (frontendReloadCount || 0) + 1;

                renderApp({ key: frontendReloadCount });
            } catch (err) {
                // log(err.stack);
            }
        });
    }
}

\`\`\`

## servers/frontend-server/src/modules/index.ts

\`\`\`ts
import '../config/public-config';
import { ClientLogger } from '@cdm-logger/client';
import { ClientTypes } from '@common-stack/client-react';
import modules, { MainRoute } from './module';

class UtilityClass {
    // tslint:disable-next-line:no-shadowed-variable
    constructor(private modules) {}

    public getCacheKey(storeObj) {
        return this.modules.getDataIdFromObject(storeObj);
    }
}

const utility = new UtilityClass(modules);

const logger = ClientLogger.create(process.env.APP_NAME || 'Fullstack-Pro', {
    level: (process.env.LOG_LEVEL as any) || 'info',
});
// additional bindings to container
const container = modules.createContainers({}) as any;
container.bind(ClientTypes.Logger).toConstantValue(logger);
container.bind(ClientTypes.UtilityClass).toConstantValue(utility);

export default modules;
export { MainRoute, container, logger };

\`\`\`

## servers/frontend-server/src/modules/layout/components/SideMenu.tsx

\`\`\`tsx
import * as H from 'history';
import * as React from 'react';
import { Link } from 'react-router-dom';
import * as PropTypes from 'prop-types';
import pathToRegexp from 'path-to-regexp';
import { Layout, Menu, Avatar } from 'antd';
import { IMenuPosition } from '@common-stack/client-react';

const { Sider } = Layout;
const { SubMenu } = Menu;

export function urlToList(url) {
    const urllist = url.split('/').filter(i => i);
    return urllist.map((urlItem, index) => {
        return `/${urllist.slice(0, index + 1).join('/')}`;
    });
}

const getImageUrl = (picture) => {
    return picture || "data:image/png;base64,${new Identicon(Base64.encode('myawsomestringbebe'), 420).toString()}";
};

/**
 * Recursively flatten  the data
 * [{path: string}, {path: string}] => {path, path2}
 * @param menu
 */
export const getFlatMenuKeys = menu =>
    menu.reduce((keys, item) => {
        keys.push(item.path);
        if (item.children) {
            return keys.concat(getFlatMenuKeys(item.children));
        }
        return keys;
    }, []);


/**
 * Find all matched menu keys based on paths
 * @param flatMenuKeys: [/abc, /abc/:id, /abc/:id/info]
 * @param paths: [/abc/ /abc/11, /abc/11/info]
 */
export const getMenuMatchKeys = (flatMenuKeys, paths) =>
    paths.reduce((matchKeys, path) => (
        matchKeys.concat(
            flatMenuKeys.filter(item => pathToRegexp(item).test(path)),
        )), []);

export namespace ISiderMenu {
    export interface CompProps {
        menuData: any;
        segments: any;
        onCollapse?: any;
        state?: boolean;
        isMobile?: boolean;
        renderer?: any;
        Authorized?: any;
        collapsed?: boolean;
        logo?: any;
        user?: any;
        styles?: {
            grow?: any;
            logo?: any;
            sider?: any;
            icon?: any;
        };
    }

    export interface StateProps {
        location: H.Location;
    }

    export interface CompState {
        openKeys?: any;
    }

    export type Props = CompProps & StateProps;
    export type State = CompState;
}
export class SiderMenu extends React.PureComponent<ISiderMenu.Props, ISiderMenu.State> {

    private menus;
    private flatMenuKeys;

    constructor(props) {
        super(props);
        this.menus = props.menuData;
        this.flatMenuKeys = getFlatMenuKeys(props.menuData);
        this.state = {
            openKeys: this.getDefaultCollapsedSubMenus(props),
        };
    }

    public static contextTypes = {
        renderer: PropTypes.any.isRequired,
    };

    public static defaultProps() {
        return {
            user: {},
            isMobile: false,
        };
    }


    public UNSAFE_componentWillReceiveProps(nextProps) {
        if (nextProps.location.pathname !== this.props.location.pathname) {
            this.setState({
                openKeys: this.getDefaultCollapsedSubMenus(nextProps),
            });
        }
    }

    /**
     * Convert pathname to openKeys
     * /list/search/articles => ['list', '/list/search']
     * @param props
     */
    public getDefaultCollapsedSubMenus(props) {
        const { location: { pathname } } = props || this.props;
        return getMenuMatchKeys(this.flatMenuKeys, urlToList(pathname));
    }

    /**
     * Allow menu.js config icon as string or ReactNode
     * icon: 'setting',
     * icon: 'http://demo.com/icon.png',
     * icon: <Icon type="setting" />,
     * @param icon
     */
    private getIcon(icon) {
        const { styles = {} } = this.props;
        if (typeof icon === 'string' && icon.indexOf('http') === 0) {
            return <img src={icon} alt="icon" className={styles.icon} />;
        } if (typeof icon === 'string') {
            return <div data-type={icon} style={styles.icon} />;
        }
        return icon;
    }

    private getAvatar(menu) {
        const { styles = {}, user } = this.props;
        return (
            <span data-user={user.nickname} id={!user || user.isTest ? `cde-user-placeholder` : 'cde-user'}>
                <div style={{ marginRight: '7px' }} data-src={getImageUrl(user.picture)}>
                    {user.nickname || 'Guest'}
                </div>
                {' '}
                <span> {user.nickname || 'Guest'}</span>
            </span>
        );
    }

    /**
     * Judge whether it is http link.return or a Link
     * @memberOf SiderMenu
     */
    private getMenuItemPath = item => {
        const { styles = {} } = this.props;
        const itemPath = this.conversionPath(item.path);
        const icon = this.getIcon(item.icon);
        const { target, name } = item;
        // Is it a http link
        if (/^https?:\/\//.test(itemPath)) {
            return (
                <a href={itemPath} target={target}>
                    {icon}
                    <span>{name}</span>
                </a>
            );
        }
        return (
            <Link
                to={itemPath}
                target={target}
                replace={itemPath === this.props.location.pathname}
                onClick={
                    this.props.isMobile
                        ? () => {
                            this.props.onCollapse(true);
                        }
                        : undefined
                }
            >
                {icon}
                <span>{name}</span>
            </Link>
        );
    }
    /**
     * get SubMenu or Item
     */
    private getSubMenuOrItem = item => {
        const { styles = {} } = this.props;
        if (item.children && item.children.some(child => child.name)) {
            const childrenItems = this.getNavMenuItems(item.children);
            if (childrenItems && childrenItems.length > 0) {
                return (
                    <SubMenu title={item.name} key={item.path}>
                        {childrenItems}
                    </SubMenu>
                );
            }
            return null;
        } else {
            return <Menu.Item key={item.path}>{this.getMenuItemPath(item)}</Menu.Item>;
        }
    }
    /**
     * @memberof SiderMenu
     */
    private getNavMenuItems = menusData => {
        if (!menusData) {
            return [];
        }
        return menusData.filter(item => item.name && !item.hideInMenu)
            .map(item => {
                // make dom
                const ItemDom = this.getSubMenuOrItem(item);
                return this.checkPermissionItem(item.authority, ItemDom);
            })
            .filter(item => item);
    }

    /**
     * Generates LOGO
     * @memberof SiderMenu
     */
    private getLogo(logo) {
        const { styles = {} } = this.props;
        return logo && (
            <div className={styles.logo} key="logo">
                <Link to="/">
                    <img src={logo.icon} alt="logo" />
                    <h1>{logo.name}</h1>
                </Link>
            </div>
        );
    }

    // Get the currently selected menu
    private getSelectedMenuKeys = () => {
        const { location: { pathname } } = this.props;
        return getMenuMatchKeys(this.flatMenuKeys, urlToList(pathname));
    }
    // conversion Path
    private conversionPath = path => {
        if (path && path.indexOf('http') === 0) {
            return path;
        } else {
            return `/${path || ''}`.replace(/\/+/g, '/');
        }
    }
    // permission to check
    private checkPermissionItem = (authority, ItemDom) => {
        if (this.props.Authorized && this.props.Authorized.check) {
            const { check } = this.props.Authorized;
            return check(authority, ItemDom);
        }
        return ItemDom;
    }
    private isMainMenu = key => {
        return this.menus.some(item => key && (item.key === key || item.path === key));
    }
    private handleOpenChange = openKeys => {
        const lastOpenKey = openKeys[openKeys.length - 1];
        const moreThanOne = openKeys.filter(openKey => this.isMainMenu(openKey)).length > 1;
        this.setState({
            openKeys: moreThanOne ? [lastOpenKey] : [...openKeys],
        });
    }

    public render() {
        const { renderer } = this.context;
        const { logo, collapsed, segments = [], onCollapse, styles = {} } = this.props;
        const { openKeys } = this.state;
        // Don't show popup menu when it is been collapsed
        const menuProps = collapsed ? {} : { openKeys };
        // If pathname can't match, use the nearest parent's key
        let selectedKeys = this.getSelectedMenuKeys();
        if (!selectedKeys.length) {
            selectedKeys = [openKeys[openKeys.length - 1]];
        }

        return (
            <Sider
                trigger={null}
                collapsible={true}
                collapsed={collapsed}
                breakpoint="lg"
                onCollapse={onCollapse}
                width={256}
                className={styles.sider}
            >
                {this.getLogo((this.menus.filter(menu => menu.position === IMenuPosition.LOGO) || [])[0])}
                <div className={styles.grow}>
                    <Menu
                        key="Menu-Middle"
                        theme="dark"
                        mode="inline"
                        {...menuProps}
                        className={styles.grow}
                        onOpenChange={this.handleOpenChange}
                        selectedKeys={selectedKeys}
                        style={{ padding: '16px 0', width: '100%' }}
                    >
                        {this.getNavMenuItems(this.menus.filter(menu => menu.position === IMenuPosition.MIDDLE))}
                    </Menu>
                    {segments.map((segment, segmentIndex) => (
                        <div key={segmentIndex}>
                            {React.cloneElement(segment, { collapsed })}
                        </div>
                    ))}
                </div>
                <Menu
                    key="Menu-Bottom"
                    theme="dark"
                    mode="inline"
                    {...menuProps}
                    onOpenChange={this.handleOpenChange}
                    selectedKeys={selectedKeys}
                    style={{ padding: '16px 0', width: '100%' }}
                >
                    {this.getNavMenuItems(this.menus.filter(menu => menu.position === IMenuPosition.BOTTOM))}
                </Menu>
            </Sider>
        );
    }
}


\`\`\`

## servers/frontend-server/src/modules/layout/components/index.ts

\`\`\`ts
export * from './SideMenu';

\`\`\`

## servers/frontend-server/src/modules/layout/index.ts

\`\`\`ts
export * from './components';

\`\`\`

## servers/frontend-server/src/modules/module.tsx

\`\`\`tsx
import * as React from 'react';
import { Layout } from 'antd';
import counterModules from '@sample-stack/counter-module-browser';
import { Feature, FeatureWithRouterFactory } from '@common-stack/client-react';

import { SiderMenu } from './layout';

const features = new Feature(FeatureWithRouterFactory, counterModules);

console.log(features.getMenus());

export const MainRoute = props => (
    <Layout hasSider={true} style={{ minHeight: '100vh', display: 'flex' }}>
        <SiderMenu
            collapsed={false}
            menuData={features.getMenus()}
            location={window.location as any}
            segments={features.sidebarSegments}
        />
        <Layout>
            <Layout.Content style={{height: '100%'}}>
                <section className="flex-grow" style={{height: '100%'}}>
                    {features.getRoutes()}
                </section>
            </Layout.Content>
        </Layout>
    </Layout>
);

export default features;

\`\`\`

## servers/frontend-server/src/postcss.config.js

\`\`\`js
module.exports = {
    plugins: [
    ],
};

\`\`\`

## servers/frontend-server/tools/webpackAppConfig.js

\`\`\`js
const dependencyPlatforms = {
    '@cdm-logger/server': 'server',
    '@sample-stack/core': 'noddl',
    '@sample-stack/platform-browser': 'noddl',
    '@sample-stack/counter': 'noddl',
    bunyan: 'server',
    'export-dir': 'server',
    express: 'server',
    'body-parser': 'server',
    'apollo-server-express': 'server',
    'graphql-subscriptions': 'server',
    'graphql-tag': ['server', 'web'],
    'immutability-helper': ['ios', 'android', 'web'],
    'isomorphic-fetch': 'server',
    knex: 'server',
    mysql2: 'server',
    persistgraphql: ['server', 'web'],
    'graphql-nats-subscriptions': 'server',
    'graphql-server-core': 'server',
    'graphql-tools': 'server',
    helmet: 'server',
    'hemera-joi': 'server',
    'hemera-plugin': 'server',
    'hemera-safe-promises': 'server',
    'hemera-sql-store': 'server',
    'hemera-zipkin': 'server',
    inversify: 'server',
    morgan: 'server',
    nats: 'server',
    'nats-hemera': 'server',
    nconf: 'server',
    'node-pre-gyp': 'server',
    'prop-types': 'web',
    ramda: ['web', 'server'],
    'reflect-metadata': 'server',
    sequelize: 'server',
    'react-native': ['ios', 'android'],
    'react-navigation': ['ios', 'android'],
    'serialize-javascript': 'server',
    'source-map-support': 'server',
    sqlite3: 'server',
    'styled-components': ['server', 'web'],
    'subscriptions-transport-ws': ['ios', 'android', 'web'],
    ws: ['server'],
};

module.exports = { dependencyPlatforms };

\`\`\`

## servers/frontend-server/tsconfig.json

\`\`\`json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "declaration": false,
    "jsx": "react",
    "outDir": "./dist",
    "rootDir": "./src",
    "skipLibCheck": true
  },
  "include": ["../../typings/*.d.ts"],
  "exclude": ["node_modules", "lib", "dist", "webpack.config.js"]
}

\`\`\`

## servers/frontend-server/webpack.config.lint.js

\`\`\`js
module.exports = require('zenjs').createWebpackConfig(__dirname, '.zenrc.js', 'web');
\`\`\`

## servers/moleculer-server/.vscode/launch.json

\`\`\`json
{
	// Use IntelliSense to learn about possible Node.js debug attributes.
	// Hover to view descriptions of existing attributes.
	// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
	"version": "0.2.0",
	"configurations": [
		
		{
			"type": "node",
			"request": "launch",
			"name": "Debug",
			"program": "${workspaceRoot}/node_modules/moleculer/bin/moleculer-runner.js",
			"sourceMaps": true,
			"runtimeArgs": [
				"--nolazy",
				"-r",
				"ts-node/register"
			],
			"cwd": "${workspaceRoot}",
			"args": [
				"--mask **/*.service.ts",
				"--config",
				"moleculer.config.ts",
				"services"
			]
		},
		{
			"type": "node",
			"request": "launch",
			"name": "Jest",
			"program": "${workspaceRoot}/node_modules/jest-cli/bin/jest.js",
			"args": [
				"--runInBand"
			],
			"cwd": "${workspaceRoot}",
			"runtimeArgs": [
				"--inspect-brk",
				"--nolazy"
			]
		}
	]
}

\`\`\`

## servers/moleculer-server/src/config/config.ts

\`\`\`ts
import * as envalid from 'envalid';
process.env.ENV_FILE !== null && (require('dotenv')).config({ path: process.env.ENV_FILE });


const { str, bool, json } = envalid;

export const config = envalid.cleanEnv(process.env, {
    NODE_ENV: str({ default: 'production', choices: ['production', 'staging', 'development', 'test'] }),
    NATS_URL: str(),
    NATS_USER: str(),
    NATS_PW: str(),
    MONGO_URL: str(),
    REDIS_CLUSTER_URL: json({devDefault: '[{"port":6379,"host":"localhost"}]',  example: '[{"port":6379,"host":"localhost"}]'}),
    REDIS_URL: str({ devDefault: 'localhost' }),
    REDIS_CLUSTER_ENABLED: bool({ devDefault: false }),
    REDIS_SENTINEL_ENABLED: bool({ devDefault: true }),
    CONNECTION_ID: str({devDefault: 'CONNECTION_ID'}),
    NAMESPACE: str({default: 'default'}),
    LOG_LEVEL: str({ default: 'info', choices: ['info', 'debug', 'trace'] }),
});


\`\`\`

## servers/moleculer-server/src/config/index.ts

\`\`\`ts
export * from './config';

\`\`\`

## servers/moleculer-server/src/config/moleculer.config.ts

\`\`\`ts
'use strict';
import { BrokerOptions, Errors } from 'moleculer';
import { config } from './config';

/**
 * Moleculer ServiceBroker configuration file
 *
 * More info about options:
 *         https://moleculer.services/docs/0.14/configuration.html
 *
 *
 * Overwrite options in production:
 * ================================
 * 	You can overwrite any option with environment variables.
 * 	For example to overwrite the 'logLevel', use `LOGLEVEL=warn` env var.
 * 	To overwrite a nested parameter, e.g. retryPolicy.retries, use `RETRYPOLICY_RETRIES=10` env var.
 *
 * 	To overwrite broker’s deeply nested default options, which are not presented in 'moleculer.config.ts',
 * 	via environment variables, use the `MOL_` prefix and double underscore `__` for nested properties in .env file.
 * 	For example, to set the cacher prefix to `MYCACHE`, you should declare an env var as `MOL_CACHER__OPTIONS__PREFIX=MYCACHE`.
 */
const brokerConfig: BrokerOptions = {
    // Namespace of nodes to segment your nodes on the same network.
    namespace: config.NAMESPACE,
    // namespace: null,
    // Unique node identifier. Must be unique in a namespace.
    // nodeID: config.CONNECTION_ID,


    // Enable/disable logging or use custom logger. More info: https://moleculer.services/docs/0.14/logging.html
    // Available logger types: 'Console', 'File', 'Pino', 'Winston', 'Bunyan', 'debug', 'Log4js', 'Datadog'
    logger: {
        type: 'Console',
        options: {
            // Using colors on the output
            colors: true,
            // Print module names with different colors (like docker-compose for containers)
            moduleColors: false,
            // Line formatter. It can be 'json', 'short', 
            // 'simple', 'full', a `Function` or a template string like '{timestamp} {level} {nodeID}/{mod}: {msg}'
            formatter: 'full',
            // Custom object printer. If not defined, it uses the `util.inspect` method.
            objectPrinter: null,
            // Auto-padding the module name in order to messages begin at the same column.
            autoPadding: false,
        },
    },
    // Default log level for built-in console logger. It can be overwritten in logger options above.
    // Available values: trace, debug, info, warn, error, fatal
    logLevel: config.LOG_LEVEL as any,

    // Define transporter.
    // More info: https://moleculer.services/docs/0.14/networking.html
    // Note: During the development, you don't need to define it because all services will be loaded locally.
    // In production you can set it via `TRANSPORTER=nats://localhost:4222` environment variable.
    transporter: (config.NODE_ENV === 'development') ? 'TCP' : {
        type: 'NATS',
        options: {
            url: config.NATS_URL,
            user: config.NATS_USER,
            pass: config.NATS_PW,
            reconnectTimeWait: 1000,
        },
    },

    // Define a cacher.
    // More info: https://moleculer.services/docs/0.14/caching.html
    // cacher: {
    //     type: 'Redis',
    //     enabled: false,
    //     options: {

    //         // Redis settings
    //         redis: {

    //         }
    //     }
    // },

    // Define a serializer.
    // Available values: 'JSON', 'Avro', 'ProtoBuf', 'MsgPack', 'Notepack', 'Thrift'.
    // More info: https://moleculer.services/docs/0.13/networking.html
    serializer: 'JSON',

    // Number of milliseconds to wait before reject a request with a RequestTimeout error. Disabled: 0
    requestTimeout: 10 * 1000,

    // Retry policy settings. More info: https://moleculer.services/docs/0.13/fault-tolerance.html#Retry
    retryPolicy: {
        // Enable feature
        enabled: false,
        // Count of retries
        retries: 5,
        // First delay in milliseconds.
        delay: 100,
        // Maximum delay in milliseconds.
        maxDelay: 1000,
        // Backoff factor for delay. 2 means exponential backoff.
        factor: 2,
        // A function to check failed requests.
        check: (err: Errors.MoleculerRetryableError) => err && !!err.retryable,
    },

    // Limit of calling level. If it reaches the limit, broker will throw an MaxCallLevelError error. (Infinite loop protection)
    maxCallLevel: 100,

    // Number of seconds to send heartbeat packet to other nodes.
    heartbeatInterval: 5,
    // Number of seconds to wait before setting node to unavailable status.
    heartbeatTimeout: 15,

    // tslint:disable-next-line:max-line-length
    // Tracking requests and waiting for running requests before shutdowning. More info: https://moleculer.services/docs/0.13/fault-tolerance.html
    tracking: {
        // Enable feature
        enabled: false,
        // Number of milliseconds to wait before shutdowning the process
        shutdownTimeout: 5000,
    },

    // Disable built-in request & emit balancer. (Transporter must support it, as well.)
    disableBalancer: false,

    // Settings of Service Registry. More info: https://moleculer.services/docs/0.14/registry.html
    registry: {
        // Define balancing strategy. More info: https://moleculer.services/docs/0.14/balancing.html
        // Available values: 'RoundRobin', 'Random', 'CpuUsage', 'Latency'
        strategy: 'RoundRobin',
        // Enable local action call preferring.
        preferLocal: true,
    },

    // Settings of Circuit Breaker. More info: https://moleculer.services/docs/0.14/fault-tolerance.html#Circuit-Breaker
    circuitBreaker: {
        // Enable feature
        enabled: false,
        // Threshold value. 0.5 means that 50% should be failed for tripping.
        threshold: 0.5,
        // Minimum request count. Below it, CB does not trip.
        minRequestCount: 20,
        // Number of seconds for time window.
        windowTime: 60,
        // Number of milliseconds to switch from open to half-open state
        halfOpenTime: 10 * 1000,
        // A function to check failed requests.
        check: (err: Errors.MoleculerRetryableError) => err && err.code >= 500,
    },

    // Settings of bulkhead feature. More info: https://moleculer.services/docs/0.14/fault-tolerance.html#Bulkhead
    bulkhead: {
        // Enable feature.
        enabled: false,
        // Maximum concurrent executions.
        concurrency: 10,
        // Maximum size of queue
        maxQueueSize: 100,
    },

    // Enable action & event parameter validation. More info: https://moleculer.services/docs/0.14/validating.html
    validator: true,

    errorHandler: null,

    // Enable/disable built-in metrics function. More info: https://moleculer.services/docs/0.14/metrics.html
    metrics: {
        enabled: false,
        // Available built-in reporters: 'Console', 'CSV', 'Event', 'Prometheus', 'Datadog', 'StatsD'
        reporter: {
            type: 'Prometheus',
            options: {
                // HTTP port
                port: 3030,
                // HTTP URL path
                path: '/metrics',
                // Default labels which are appended to all metrics labels
                defaultLabels: registry => ({
                    namespace: registry.broker.namespace,
                    nodeID: registry.broker.nodeID,
                }),
            },
        },
    },

    // Enable built-in tracing function. More info: https://moleculer.services/docs/0.14/tracing.html
    tracing: {
        enabled: true,
        // Available built-in exporters: 'Console', 'Datadog', 'Event', 'EventLegacy', 'Jaeger', 'Zipkin'
        exporter: {
            type: 'Console', // Console exporter is only for development!
            options: {
                // Custom logger
                logger: null,
                // Using colors
                colors: true,
                // Width of row
                width: 100,
                // Gauge width in the row
                gaugeWidth: 40,
            },
        },
    },

    // Register internal services ('$node'). More info: https://moleculer.services/docs/0.13/services.html#Internal-services
    internalServices: true,
    // Register internal middlewares. More info: https://moleculer.services/docs/0.13/middlewares.html#Internal-middlewares
    internalMiddlewares: true,

    // Watch the loaded services and hot reload if they changed. 
    // You can also enable it in Moleculer Runner with `--hot` argument
    hotReload: false,

    // Register custom middlewares
    middlewares: [],

    // Called after broker created.
    created(broker) {

    },

    // Called after broker starte.
    started(broker) {

    },

    // Called after broker stopped.
    stopped(broker) {

    },

    // Register custom REPL commands.
    replCommands: null,
};

export = brokerConfig;

\`\`\`

## servers/moleculer-server/src/connectors/connection-broker.ts

\`\`\`ts

import { MongoConnector } from './mongo-connector';
import { NatsConnector } from './nats-connector';
import { RedisConnector } from './redis-connector';
import { config } from '../config';
import { GraphqlPubSubConnector } from './graphql-pubsub-connector';
import { Transporter, GenericObject } from 'moleculer';
import { CdmLogger } from '@cdm-logger/core';
type ILogger = CdmLogger.ILogger;

/**
 *  Connection broker class
 *
 * @class ConnectionBroker
 */
export class ConnectionBroker {


    private _mongoConnector: MongoConnector;

    private _redisConnector: RedisConnector;

    private _natsConnector: NatsConnector;

    private _graphqlPubsubConnector: GraphqlPubSubConnector;

    /**
     * Creates an instance of ConnectionBroker.
     * @param {*} options
     * @memberof ConnectionBroker
     */
    constructor(transporter: string | GenericObject, logger: ILogger) {

        if (typeof transporter === 'string') {
            if (transporter === 'TCP') {
                this._graphqlPubsubConnector = new GraphqlPubSubConnector({ logger, type: 'TCP' });
            } else if (transporter === 'NATS') {
                this._natsConnector = new NatsConnector({});
                this._graphqlPubsubConnector = new GraphqlPubSubConnector({ logger, type: 'NATS', client: this._natsConnector});
            }
        } else {
            if (transporter.type === 'NATS') {
                this._natsConnector = new NatsConnector(transporter.options);
                this._graphqlPubsubConnector = new GraphqlPubSubConnector({ logger, ...transporter, client: this._natsConnector});
            }
        }

        this._mongoConnector = new MongoConnector(config.MONGO_URL as any);
        this._redisConnector = new RedisConnector(); // TODO pass constructor options
    }


    public get mongoConnection() {
        return this._mongoConnector.connect();
    }

    public get redisDataloaderClient() {
        return this._redisConnector.getRedisDataloaderClient();
    }

    public get natsConnection() {
        return this._natsConnector.connect();
    }

    public get graphqlPubsub() {
        return this._graphqlPubsubConnector.getClient();
    }

    public async stop() {
        this._mongoConnector && await this._mongoConnector.disconnect();
        this._redisConnector && await this._redisConnector.disconnect();
        this._natsConnector &&  await this._natsConnector.disconnect();
    }
}

\`\`\`

## servers/moleculer-server/src/connectors/graphql-pubsub-connector.ts

\`\`\`ts
import { PubSub, PubSubEngine } from 'graphql-subscriptions';
import { NatsPubSub } from 'graphql-nats-subscriptions';
import { logger } from '@cdm-logger/server';
import { ClientOpts } from 'nats';
import { Transporter, GenericObject } from 'moleculer';
import { CdmLogger } from '@cdm-logger/core';
type ILogger = CdmLogger.ILogger;



type PubSubOptions = {
    apolloLogging?: boolean;
    logger: ILogger;
} & GenericObject;


export class GraphqlPubSubConnector {


    private client: PubSubEngine | NatsPubSub;
    private opts: PubSubOptions;
    private logger: ILogger;

    /**
     * Creates an instance of GraphqlPubSubConnector.
     * @param {*} opts
     * @memberof GraphqlPubSubConnector
     */
    constructor(opts?: PubSubOptions) {
        if (opts === undefined || opts.type === undefined) {
            this.opts = { ...opts, apolloLogging: true, type: 'TCP' };
        }
        this.opts = opts;
        this.logger = opts.logger.child({className: 'GraphqlPubSubConnector'});
    }

    public async getClient() {
        if (this.opts.type === 'TCP') {
            return this.client = new PubSub();
        } else if (this.opts.type === 'NATS') {
            // console.log('--this.copts', this.opts.client)
            const natsClient = await this.opts.client.connect();
            return this.client = new NatsPubSub({ client: natsClient, logger });
        } else {
            this.logger.warn('Did not defined known transporter [%s], return default pubsub', this.opts.type);
            return this.client = new PubSub();
        }
    }
}

\`\`\`

## servers/moleculer-server/src/connectors/mongo-connector.ts

\`\`\`ts
import { createConnection, connection, ConnectionOptions, Connection } from 'mongoose';
import * as _ from 'lodash';
import { Db } from 'mongodb';
import { logger } from '@cdm-logger/server';
import { CdmLogger } from '@cdm-logger/core';

type ILogger = CdmLogger.ILogger;

export class MongoConnector {
    private client: Connection;

    private db: Db;

    private opts: ConnectionOptions;

    private uri: string;

    private logger: ILogger;

    constructor(uri: string, opts?: ConnectionOptions) {
        this.opts = _.defaultsDeep(opts, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
        });
        this.uri = uri;
        this.logger = logger.child({ className: 'MongoConnector' });
    }

    /**
     * Connect to database
     *
     * @memberof MongoConnector
     */
    public async connect(): Promise<Connection> {
        if (this.client) {
            return this.client;
        }
        const conn = createConnection(this.uri, this.opts);

        conn.then((result) => {
            this.client = conn;

            if ((result as any).connection) {
                this.db = (result as any).conection.db;
            } else {
                this.db = result.db;
            }

            this.logger.info(' MongoDB has connected successfully.');

            this.db.on('disconnected', () => this.logger.warn('Mongoose has disconnected.'));
            this.db.on('error', (err) => this.logger.error('MongoDB error.', err));
            this.db.on('reconnect', () => this.logger.info('Mongoose has reconnected.'));
        });
        return conn;
    }

    /**
     * Disconnect from database
     *
     * @memberof MongoConnector
     */
    public async disconnect() {
        if (!this.client) {
            return;
        }
        if (this.db && (this.db as any).close) {
            await (this.db as any).close();
        }
        await connection.close();
    }
}

\`\`\`

## servers/moleculer-server/src/connectors/nats-connector.ts

\`\`\`ts
import * as nats from 'nats';
import * as _ from 'lodash';
import { logger } from '@cdm-logger/server';
import { CdmLogger } from '@cdm-logger/core';

type ILogger = CdmLogger.ILogger;

export class NatsConnector {
    private opts: nats.ClientOpts;

    private client: nats.Client;

    private logger: ILogger;

    private connected: boolean;

    constructor(opts: nats.ClientOpts) {
        this.opts = _.defaultsDeep(opts, {});
        this.logger = logger.child({ className: 'NatsConnector' });
    }

    /**
     * Connect to a NATS server
     *
     * @memberof NatsConnector
     */
    public connect() {
        if (this.client) {
            return this.client;
        }
        return new Promise<nats.Client>((resolve, reject) => {
            const client = nats.connect(this.opts);

            client.on('connect', () => {
                this.client = client;
                this.connected = true;
                this.logger.info('NATS client is connected.');
                resolve(client);
            });

            client.on('reconnect', () => {
                this.logger.info('NATS client is reconnected.');
                this.connected = true;
            });

            client.on('reconnecting', () => {
                this.logger.warn('NATS client is reconnecting...');
            });

            client.on('disconnect', () => {
                if (this.connected) {
                    this.logger.warn('NATS client is disconnected.');
                    this.connected = false;
                }
            });

            client.on('error', (e) => {
                this.logger.error('NATS error.', e.message);
                this.logger.debug(e);
                reject(e);
            });

            client.on('close', () => {
                this.logger.fatal('NATS connection close.');
            });
        });
    }

    /**
     * Disconnect from a NATS server
     *
     * @memberof NatsTransporter
     */
    public disconnect() {
        if (this.client) {
            this.client.flush(() => {
                this.client.close();
                this.client = null;
            });
        }
    }
}

\`\`\`

## servers/moleculer-server/src/connectors/redis-connector.ts

\`\`\`ts


import * as _ from 'lodash';
import { RedisClusterCache, RedisCache } from 'apollo-server-cache-redis';
import * as IORedis from 'ioredis';
import { logger } from '@cdm-logger/server';
import { config } from '../config';
import { CdmLogger } from '@cdm-logger/core';
type ILogger = CdmLogger.ILogger;

export class RedisConnector {


    private client: RedisClusterCache | RedisCache;
    private opts: IORedis.ClusterOptions | IORedis.RedisOptions;
    private logger: ILogger;

    /**
     * Creats an instance of Redis.
     *
     * @param {object} opts
     */
    constructor(opts?: IORedis.ClusterOptions | IORedis.RedisOptions) {
        this.opts = _.defaultsDeep(opts, {
            prefix: null,
        });
        this.logger = logger.child({ className: 'RedisConnector' });
    }

    /**
     * Connect to the server
     *
     * @memberof RedisConnector
     */
    public connect() {
        return new Promise((resolve, reject) => {
            reject('this method not implemented');
        });
    }


    /**
     * Return redis or redis.cluster Dataloader Client
     *
     * @memberof RedisConnection
     */
    public getRedisDataloaderClient() {
        let client: RedisClusterCache | RedisCache;
        if (config.REDIS_CLUSTER_ENABLED) {
            if (!config.REDIS_CLUSTER_URL) {
                throw new Error(`No nodes defined for cluster, ${config.REDIS_CLUSTER_URL}`);
            }
            this.logger.info('Setting Redis.Cluster connection');
            client = new RedisClusterCache(config.REDIS_CLUSTER_URL as any, this.opts);
        } else {
            this.logger.info('Setting Redis connection');
            client = new RedisCache(config.REDIS_URL as any || this.opts);
        }
        return client;
    }

    /**
     * Close Redis client connection.
     *
     * @memberof RedisConnection
     */
    public disconnect() {
        if (!this.client) {
            return;
        }
        return this.client.close();
    }
}

\`\`\`

## servers/moleculer-server/src/index.ts

\`\`\`ts
///<reference types="webpack-env" />

import 'reflect-metadata';
import { StackServer } from './stack-server';
import { logger } from '@cdm-logger/server';


declare var module: __WebpackModuleApi.Module;


const service = new StackServer();
async function start() {
    await service.initialize();
    await service.start();
}

if (module.hot) {
    module.hot.status(event => {
        if (event === 'abort' || event === 'fail') {
            logger.error('HMR error status: ' + event);
            // Signal webpack.run.js to do full-reload of the back-end
            service.cleanup();
        }
        // adddintionally when event is idle due to external modules
        if (event === 'idle') {
            service.cleanup();
        }
    });
    module.hot.accept();
}

start();

\`\`\`

## servers/moleculer-server/src/modules/index.ts

\`\`\`ts
import modules, { settings } from './module';

export default modules;
export { settings };

\`\`\`

## servers/moleculer-server/src/modules/module.ts

\`\`\`ts
import { ContainerModule, interfaces } from 'inversify';
import CounterModule from '@sample-stack/counter-module-server';
import { config } from '../config';
import { NATS_MOLECULER_COUNTER_SERIVCE } from '@sample-stack/counter-module-server';
import { Feature } from '@common-stack/server-core';


const subTopic = config.CONNECTION_ID; // version.topic.action

export const settings: any & { name: string } = {
    name: NATS_MOLECULER_COUNTER_SERIVCE,
    connectionId: config.CONNECTION_ID,
    namespace: config.NAMESPACE,
    subTopic,
    logger: config.LOG_LEVEL,
    workspaceId: config.CONNECTION_ID || 'DEFAULT',
    configPath: process.env.CONFIG_PATH,
};


const defaultModule =
    () => new ContainerModule((bind: interfaces.Bind) => {
        bind('Settings').toConstantValue(settings).whenTargetTagged('default', true);
        bind('Settings').toConstantValue(settings).whenTargetTagged('microservice', true);
        bind('MongoOptions').toConstantValue({});
    });

const DefaultFeature = new Feature({
    createContainerFunc: [defaultModule],
    createHemeraContainerFunc: [defaultModule],
});

export default new Feature(
    DefaultFeature,
    CounterModule,
);

\`\`\`

## servers/moleculer-server/src/stack-server.ts

\`\`\`ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable import/namespace */
import { logger as serverLogger } from '@cdm-logger/server';
import { Feature } from '@common-stack/server-core';
import { ContainerModule, interfaces, Container } from 'inversify';
import { ServiceBroker } from 'moleculer';
import { CommonType } from '@common-stack/core';
import { CdmLogger } from '@cdm-logger/core';
import * as brokerConfig from './config/moleculer.config';
import modules, { settings } from './modules';
import { config } from './config';
import { ConnectionBroker } from './connectors/connection-broker';

type ILogger = CdmLogger.ILogger;

const infraModule = ({ broker, pubsub, mongoClient, logger }) =>
    new ContainerModule((bind: interfaces.Bind) => {
        bind('Logger').toConstantValue(logger);
        bind(CommonType.LOGGER).toConstantValue(logger);
        bind('Environment').toConstantValue(config.NODE_ENV || 'development');
        bind(CommonType.ENVIRONMENT).toConstantValue(config.NODE_ENV || 'development');
        bind('PubSub').toConstantValue(pubsub);
        bind(CommonType.PUBSUB).toConstantValue(pubsub);
        bind(CommonType.MOLECULER_BROKER).toConstantValue(broker);
        bind('MoleculerBroker').toConstantValue(broker);
        bind('MongoDBConnection').toConstantValue(mongoClient);
    });

/**
 *  Controls the lifecycle of the Application Server
 *
 * @export
 * @class StackServer
 */
export class StackServer {
    private logger: ILogger;

    private connectionBroker: ConnectionBroker;

    private microserviceBroker: ServiceBroker;

    private serviceContainer: Container;

    private microserviceContainer: Container;

    constructor() {
        this.logger = serverLogger.child({ className: 'StackServer' });
    }

    public async initialize() {
        this.logger.info('StackServer initializing');

        this.connectionBroker = new ConnectionBroker(brokerConfig.transporter, this.logger);
        const redisClient = this.connectionBroker.redisDataloaderClient;

        const mongoClient = await this.connectionBroker.mongoConnection;

        this.microserviceBroker = new ServiceBroker({
            ...brokerConfig,
            started: async () => {
                await modules.microservicePreStart(this.microserviceContainer);
                await modules.microservicePostStart(this.microserviceContainer);
            },
        });

        const pubsub = await this.connectionBroker.graphqlPubsub;
        const InfraStructureFeature = new Feature({
            createHemeraContainerFunc: [
                () =>
                    infraModule({
                        broker: this.microserviceBroker,
                        pubsub,
                        mongoClient,
                        logger: serverLogger,
                    }),
            ],
        });
        const allModules = new Feature(InfraStructureFeature, modules);
        this.microserviceContainer = await allModules.createHemeraContainers({
            ...settings,
            mongoConnection: mongoClient,
        });
        const serviceBroker = {
            microserviceContainer: this.microserviceContainer,
            logger: this.logger,
        };
        // set the service container
        this.microserviceContainer = serviceBroker.microserviceContainer;
        allModules.loadClientMoleculerService({
            broker: this.microserviceBroker,
            container: this.microserviceContainer,
            settings,
        });
    }

    public async start() {
        await this.microserviceBroker.start();
    }

    public async cleanup() {
        if (this.connectionBroker) {
            await this.connectionBroker.stop();
        }
        if (this.microserviceBroker) {
            await this.microserviceBroker.stop();
        }
    }
}

\`\`\`

## servers/moleculer-server/src/test/unit/greeter.spec.ts

\`\`\`ts
'use strict';

// import { ServiceBroker, Errors } from 'moleculer';
// import TestService from '../../greeter.service';

// describe("Test 'greeter' service", () => {
//     let broker = new ServiceBroker();
//     broker.createService(TestService);

//     beforeAll(() => broker.start());
//     afterAll(() => broker.stop());

//     describe("Test 'greeter.hello' action", () => {

//         it("should return with 'Hello Moleculer'", () => {
//             expect(broker.call("greeter.hello")).resolves.toBe("Hello Moleculer");
//         });

//     });

//     describe("Test 'greeter.welcome' action", () => {

//         it("should return with 'Welcome'", () => {
//             expect(broker.call("greeter.welcome", { name: "Adam" })).resolves.toBe("Welcome, Adam");
//         });

//         it("should reject an ValidationError", () => {
//             expect(broker.call("greeter.welcome")).rejects.toBeInstanceOf(Errors.ValidationError);
//         });

//     });

// });


\`\`\`

## servers/moleculer-server/tsconfig.json

\`\`\`json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "sourceMap": true,
    "declaration": false,
    "outDir": "./dist",
    "pretty": true,
    "skipLibCheck": true,
    "types": [
      "jest",
      "node"
    ]
  },
  "exclude": [
    "node_modules",
    "test",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
\`\`\`

## servers/moleculer-server/webpack.config.js

\`\`\`js
var nodeExternals = require('webpack-node-externals');
const CopyWebpackPlugin = require('copy-webpack-plugin');
var webpack = require('webpack');
var path = require('path');
var fs = require('fs');

var webpackOpts = {   
  mode: 'development',
  entry: {
    main: './src/index.ts',
    'moleculer.config': './src/config/moleculer.config.ts',
  },
  target: 'node',
  output: {
    filename: "[name].js",
    libraryTarget: "commonjs2"
  },
  resolve: {
    extensions: ['.ts', '.js', '.json']
  },
  plugins: [
    new CopyWebpackPlugin({
      patterns: [{
        from: '../../tools/esm-wrapper.js',
        to: 'index.js',
      }]
    }),
    new webpack.LoaderOptionsPlugin({
      options: {
        test: /\.ts$/,
        ts: {
          compiler: 'typescript',
          configFile: 'tsconfig.json'
        },
        tslint: {
          emitErrors: true,
          failOnHint: true
        }
      }
    })
  ],
  devtool: 'source-map',
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: 'ts-loader',
        exclude: /(node_modules)/
      }
    ]
  },
  externals: [
    nodeExternals({ modulesDir: "../../node_modules" }),
    nodeExternals()
  ]

};

module.exports = webpackOpts;

\`\`\`

## tools/cli/command-invoker.js

\`\`\`js
const { MODULE_TEMPLATES } = require('./config');

/**
 * Class CommandInvoker. Takes all CLI operations and calls certain CLI operation depends of variables.
 */
class CommandInvoker {
    /**
     * Sets CLI operations (functions).
     * @constructor
     *
     * @param addModule - The function for creating a new module.
     * @param deleteModule - The function for deleting existing module.
     */
    constructor(addModule, deleteModule) {
        this.addModule = addModule;
        this.deleteModule = deleteModule;
    }

    /**
     * Calls CLI operation with correct location.
     *
     * @param func - The func to call.
     * @param location - The location for a new module [browser|server|both].
     * @param args - The function for deleting existing module.
     */
    static runCommand(func, location, ...args) {
        // browser
        if (location === 'browser' || location === 'both') {
            func(...args, 'browser');
        }
        // server
        if (location === 'server' || location === 'both') {
            func(...args, 'server');
        }
    }

    /**
     * Runs operation (function) for creating a new module.
     */
    runAddModule(args, options, logger) {
        const { moduleName, location = 'both' } = args;
        CommandInvoker.runCommand(this.addModule, location, logger, MODULE_TEMPLATES, moduleName);
    }

    /**
     * Runs operation (function) for deleting existing module.
     */
    runDeleteModule(args, options, logger) {
        const { moduleName, location = 'both' } = args;
        CommandInvoker.runCommand(this.deleteModule, location, logger, moduleName);
    }
}

module.exports = CommandInvoker;

\`\`\`

## tools/cli/commands/add-module.js

\`\`\`js
const shell = require('shelljs');
const fs = require('fs');
const chalk = require('chalk');
const { copyFiles, renameFiles, computeModulesPath, runPrettier } = require('../helpers/util');

/**
 * Adds application module to browser or server code and adds it to the module list.
 *
 * @param logger - The Logger.
 * @param templatesPath - The path to the templates for a new module.
 * @param moduleName - The name of a new module.
 * @param location - The location for a new module [browser|server|both].
 * @param finished - The flag about the end of the generating process.
 */
function addModule(logger, templatesPath, moduleName, location, finished = true) {
    logger.info(`Copying ${location} files…`);

    // create new module directory
    const destinationPath = computeModulesPath(location, moduleName);
    const newModule = shell.mkdir(destinationPath);

    // continue only if directory does not jet exist
    if (newModule.code !== 0) {
        console.log(newModule)
        logger.error(`creating destination '${destinationPath} failed.`)
        logger.error(chalk.red(`The ${moduleName} directory is already exists.`));
        process.exit();
    }
    //copy and rename templates in destination directory
    copyFiles(destinationPath, templatesPath, location);
    renameFiles(destinationPath, moduleName);

    logger.info(chalk.green(`✔ The ${location} files have been copied!`));

    // get index file path
    const modulesPath = computeModulesPath(location);
    const indexFullFileName = fs.readdirSync(modulesPath).find(name => name.search(/index/) >= 0);
    const indexPath = modulesPath + indexFullFileName;
    let indexContent;

    try {
        // prepend import module
        indexContent = `import ${moduleName} from './${moduleName}';\n` + fs.readFileSync(indexPath);
    } catch (e) {
        logger.error(chalk.red(`Failed to read ${indexPath} file`));
        process.exit();
    }

    // extract application modules
    const appModuleRegExp = /Module\(([^()]+)\)/g;
    const [, appModules] = appModuleRegExp.exec(indexContent) || ['', ''];

    // add module to app module list
    shell
        .ShellString(indexContent.replace(RegExp(appModuleRegExp, 'g'), `Module(${moduleName}, ${appModules})`))
        .to(indexPath);
    runPrettier(indexPath);

    if (finished) {
        logger.info(chalk.green(`✔ Module for ${location} successfully created!`));
    }
}

module.exports = addModule;
\`\`\`

## tools/cli/commands/delete-module.js

\`\`\`js
const shell = require('shelljs');
const fs = require('fs');
const chalk = require('chalk');
const { computeModulesPath, runPrettier } = require('../helpers/util');

/**
 * Removes the module from browser, server or both locations and removes the module from the module list.
 *
 * @param logger - The Logger.
 * @param moduleName - The name of a new module.
 * @param location - The location for a new module [browser|server|both].
 */
function deleteModule(logger, moduleName, location) {
    logger.info(`Deleting ${location} files…`);
    const modulePath = computeModulesPath(location, moduleName);

    if (fs.existsSync(modulePath)) {
        // remove module directory
        shell.rm('-rf', modulePath);

        const modulesPath = computeModulesPath(location);

        // get index file path
        const indexFullFileName = fs.readdirSync(modulesPath).find(name => name.search(/index/) >= 0);
        const indexPath = modulesPath + indexFullFileName;
        let indexContent;

        try {
            indexContent = fs.readFileSync(indexPath);
        } catch (e) {
            logger.error(chalk.red(`Failed to read ${indexPath} file`));
            process.exit();
        }

        // extract application modules
        const appModuleRegExp = /Module\(([^()]+)\)/g;
        const [, appModules] = appModuleRegExp.exec(indexContent) || ['', ''];
        const appModulesWithoutDeleted = appModules.split(',').filter(appModule => appModule.trim() !== moduleName);

        const contentWithoutDeletedModule = indexContent
            .toString()
            // remove module from modules list
            .replace(appModuleRegExp, `Module(${appModulesWithoutDeleted.toString().trim()})`)
            // remove module import
            .replace(RegExp(`import ${moduleName} from './${moduleName}';\n`, 'g'), '');

        fs.writeFileSync(indexPath, contentWithoutDeletedModule);
        runPrettier(indexPath);

        logger.info(chalk.green(`✔ Module for ${location} successfully deleted!`));
    } else {
        logger.info(chalk.red(`✘ Module ${location} location for ${modulePath} not found!`));
    }
}

module.exports = deleteModule;
\`\`\`

## tools/cli/config.js

\`\`\`js
const path = require('path');

const BASE_PATH = path.resolve(`${__dirname}/../..`);
const TEMPLATES_DIR = `${BASE_PATH}/tools/templates`;
const MODULE_TEMPLATES = `${TEMPLATES_DIR}/module`;

module.exports = {
    BASE_PATH,
    TEMPLATES_DIR,
    MODULE_TEMPLATES
};
\`\`\`

## tools/cli/helpers/util.js

\`\`\`js
const shell = require('shelljs');
const fs = require('fs');
const { pascalize, decamelize } = require('humps');
const { startCase } = require('lodash');
const { BASE_PATH } = require('../config');

/**
 * Copies the templates to the destination directory.
 *
 * @param destinationPath - The destination path for a new module.
 * @param templatesPath - The path to the templates for a new module.
 * @param location - The location for a new module [client|server|both].
 */
function copyFiles(destinationPath, templatesPath, location) {
    shell.cp('-R', `${templatesPath}/${location}/*`, destinationPath);
}

/**
 * Renames the templates in the destination directory.
 *
 * @param destinationPath - The destination path of a new module.
 * @param moduleName - The name of a new module.
 */
function renameFiles(destinationPath, moduleName) {
    const Module = pascalize(moduleName);

    // change to destination directory
    shell.cd(destinationPath);

    // rename files
    shell.ls('-Rl', '.').forEach(entry => {
        if (entry.isFile()) {
            shell.mv(entry.name, entry.name.replace('Module', Module));
        }
    });

    // replace module names
    shell.ls('-Rl', '.').forEach(entry => {
        if (entry.isFile()) {
            shell.sed('-i', /\$module\$/g, moduleName, entry.name);
            shell.sed('-i', /\$_module\$/g, decamelize(moduleName), entry.name);
            shell.sed('-i', /\$Module\$/g, Module, entry.name);
            shell.sed('-i', /\$MoDuLe\$/g, startCase(moduleName), entry.name);
            shell.sed('-i', /\$MODULE\$/g, moduleName.toUpperCase(), entry.name);
        }
    });
}

/**
 * Gets the computed path of the module or modules dir path.
 *
 * @param location - The location for a new module [client|server|both].
 * @param moduleName - The name of a new module.
 * @returns {string} - Return the computed path
 */
function computeModulesPath(location, moduleName = '') {
    return `${BASE_PATH}/packages-modules/${moduleName}/${location}`;
}

/**
 * Run prettier on file that was changed.
 *
 * @param pathToFile
 */
function runPrettier(pathToFile) {
    if (fs.existsSync(pathToFile)) {
        shell.exec(`prettier --print-width 120 --single-quote --loglevel error --write ${pathToFile}`);
    }
}

module.exports = {
    renameFiles,
    copyFiles,
    computeModulesPath,
    runPrettier
};
\`\`\`

## tools/cli.js

\`\`\`js
/* eslint-disable @typescript-eslint/no-var-requires */
// require('babel-register')({ presets: ['env'], plugins: ['transform-class-properties'] });
// require('babel-polyfill');
const prog = require('caporal');

const addModuleCommand = require('./cli/commands/add-module');
const deleteModuleCommand = require('./cli/commands/delete-module');
const CommandInvoker = require('./cli/command-invoker');

const commandInvoker = new CommandInvoker(addModuleCommand, deleteModuleCommand);

prog
  .version('1.0.0')
  .description('Full info: https://github.com/sysgears/apollo-universal-starter-kit/wiki/Apollo-Starter-Kit-CLI')
  // Add module
  .command('addmodule', 'Create a new Module.')
  .argument('<moduleName>', 'Module name')
  .argument(
    '[location]',
    'Where should new module be created. [both, server, browser]',
    ['both', 'server', 'browser'],
    'both',
  )
  .action((args, options, logger) => commandInvoker.runAddModule(args, options, logger))
  // Delete module
  .command('deletemodule', 'Delete a Module')
  .argument('<moduleName>', 'Module name')
  .argument('[location]', 'Where should we delete module. [both, server, browser]', ['both', 'server', 'browser'], 'both')
  .action((args, options, logger) => commandInvoker.runDeleteModule(args, options, logger));

prog.parse(process.argv);

\`\`\`

## tools/esm-wrapper.js

\`\`\`js
/* eslint-disable import/no-unresolved */
/* eslint-disable no-global-assign */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable @typescript-eslint/no-unsafe-call */
require = require('esm')(module, { cjs: true });
module.exports = require('./main.js');

\`\`\`

## tools/get-symlinked-modules.js

\`\`\`js
const fs = require('fs');
const path = require('path');

/**
 * Returns a mapping from the names of symlinked packages to the physical paths of each package.
 */
module.exports = function getSymlinkedNodeModulesForDirectory(packagePath) {
    const nodeModulesPath = path.join(packagePath, 'node_modules');
    const directories = listDirectoryContents(nodeModulesPath);

    const modules = {};
    for (const directory of directories) {
        // The directory is either a scope or a package
        if (directory.startsWith('@')) {
            const scopePath = path.join(nodeModulesPath, directory);
            const scopedPackageDirectories = fs.readdirSync(scopePath);
            for (const subdirectory of scopedPackageDirectories) {
                const dependencyName = `${directory}/${subdirectory}`;
                const dependencyPath = path.join(scopePath, subdirectory);
                if (fs.lstatSync(dependencyPath).isSymbolicLink()) {
                    modules[dependencyName] = fs.realpathSync(dependencyPath);
                }
            }
        } else {
            const dependencyName = directory;
            const dependencyPath = path.join(nodeModulesPath, directory);
            if (fs.lstatSync(dependencyPath).isSymbolicLink()) {
                modules[dependencyName] = fs.realpathSync(dependencyPath);
            }
        }
    }
    return modules;
};

function listDirectoryContents(directory) {
    try {
        return fs.readdirSync(directory);
    } catch (e) {
        if (e.code === 'ENOENT') {
            return [];
        }
        throw e;
    }
}

\`\`\`

## tools/templates/module/browser/src/constants/constants.ts

\`\`\`ts
export const $Module$_NAMESPACE = '@$Module$_NAMESPACE';



export enum $Module$_API_ROUTES {
    $Module$_ROOT = '@$Module$/ROOT',
}

\`\`\`

## tools/templates/module/browser/src/constants/index.ts

\`\`\`ts
export * from './constants';

\`\`\`

## tools/templates/module/browser/src/graphql/index.ts

\`\`\`ts
export * from './queries';
// export * from './mutations';

\`\`\`

## tools/templates/module/browser/src/graphql/link/index.ts

\`\`\`ts

\`\`\`

## tools/templates/module/browser/src/graphql/mutations/index.ts

\`\`\`ts

\`\`\`

## tools/templates/module/browser/src/graphql/queries/index.ts

\`\`\`ts
import * as ModuleQuery from './module-query';

\`\`\`

## tools/templates/module/browser/src/graphql/schema.ts

\`\`\`ts

\`\`\`

## tools/templates/module/browser/src/index.tsx

\`\`\`tsx
import $module$ from './module';
import { Feature } from '@common-stack/client-react';

export default new Feature($module$);

\`\`\`

## tools/templates/module/browser/src/locales/en/translations.json

\`\`\`json
{
    "navLink": "$Module$ nav link",
    "title": "$Module$ module",
    "meta": "$Module$ example",
    "welcomeText": "Hello, This is the $Module$ module"
}
\`\`\`

## tools/templates/module/browser/src/locales/index.ts

\`\`\`ts
/*
* The index.ts can be empty, it's just needed to point the loader to the root directory of the locales.
* https://github.com/alienfast/i18next-loader#option-2-use-with-import-syntax
*/
export default {};

\`\`\`

## tools/templates/module/browser/src/locales/ru/translations.json

\`\`\`json
{
    "navLink": "$Module$ ссылка",
    "title": "$Module$ модуль",
    "meta": "$Module$ пример",
    "welcomeText": "Привет, это $Module$ модуль"
}
\`\`\`

## tools/templates/module/browser/src/module.tsx

\`\`\`tsx
import { Feature } from '@common-stack/client-react';
import { $Module$_NAMESPACE, $Module$_API_ROUTES } from './constants';


export default new Feature({
  routeConfig: [{
    [$Module$_API_ROUTES.$Module$_ROOT]: { component: RepositoriesContainer },
  }],
});


\`\`\`

## tools/templates/module/browser/src/selectors/index.ts

\`\`\`ts

\`\`\`

## tools/templates/module/browser/src/utils/index.ts

\`\`\`ts

\`\`\`

## tools/templates/module/browser/tsconfig.json

\`\`\`json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "rootDir": "./src",
    "outDir": "../lib",
    "declarationDir": "../lib",
    "typeRoots": [
      "../../../node_modules/@types"
    ],
    "skipLibCheck": true
  },
  "include": [
    "../../../typings/*.d.ts",
  ],
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
\`\`\`

## tools/templates/module/browser/webpack.config.js

\`\`\`js
var nodeExternals = require('webpack-node-externals');
var webpack = require('webpack');
var path = require('path');
var fs = require('fs');

var webpackOpts = {
  mode: 'development',
  entry: './src/index.tsx',
  target: 'node',
  output: {
    path: path.join(__dirname, 'lib'),
    filename: 'index.js',
    libraryTarget: "commonjs2",
  },
  node: {
    __dirname: false
  },
  resolve: {
    extensions: ['.ts', '.tsx', '.graphql', '.gql'],
  },
  plugins: [
    new webpack.LoaderOptionsPlugin({
      options: {
        test: /\.tsx?$/,
        ts: {
          compiler: 'typescript',
          configFile: 'tsconfig.json'
        },
        tslint: {
          emitErrors: true,
          failOnHint: true
        }
      }
    })
  ],
  devtool: 'source-map',
  module: {
    rules: [{
      test: /\.tsx?$/,
      loaders: 'ts-loader'
    }, {
      test: /\.graphql?/,
      exclude: /node_modules/,
      use: 'raw-loader',
    }, {
      test: /\.(gql)$/,
      exclude: /node_modules/,
      use: ['graphql-tag/loader']
    }
    ]
  },
  externals: [
    nodeExternals({ modulesDir: "../../../node_modules" }),
    nodeExternals()
  ]
};

module.exports = webpackOpts;

\`\`\`

## tools/templates/module/server/src/config/index.ts

\`\`\`ts
export * from './env-config';

\`\`\`

## tools/templates/module/server/src/constants/index.ts

\`\`\`ts
export * from './types';

export const ACTIVITY_DEBOUNCE = 900000;
// export const ACTIVITY_DEBOUNCE = 10000;

\`\`\`

## tools/templates/module/server/src/constants/types.ts

\`\`\`ts
export const TYPES = {
    ActivityStorage: 'ActivityStorage',
    ActivityCollector: 'ActivityCollector',
    ActivityDBConnection: 'ActivityDBConnection',
};

export enum EActivityScopes {
    User = 'user',
    Team = 'team',
    Cluster = 'cluster',
    Default = 'default',
    Workspace = 'workspace',
    Organization = 'organization',
}

export const MODELS = {
    ActivityStorageModel: 'ActivityStorageModel',
};

export enum HemeraTopics {
    ActivityStorage = 'ActivityStorage',
    ActivityCollector = 'ActivityCollector',
}

export enum HemeraCommands {
    Collect = 'Collect',

    StorageSet = 'StorageSet',
    StorageGet = 'StorageGet',
    StorageDelete = 'StorageDelete',

    StorageGetActive = 'StorageGetActive',
    StorageGetInactive = 'StorageGetInactive',
}

\`\`\`

## tools/templates/module/server/src/containers/index.ts

\`\`\`ts
export * from './module';

\`\`\`

## tools/templates/module/server/src/containers/module.ts

\`\`\`ts
import { TaggedType } from '@common-stack/core';
import { ContainerModule, interfaces, Container } from 'inversify';

import { TYPES } from '../constants';
import { IActivityCollector } from '../interfaces';
import { ActivityLocalservice, ActivityMicroservice } from '../services';

import { Redis } from '../storage/Redis';

export const activityModule: (settings: any, pubsub?) => interfaces.ContainerModule =
    (settings) => new ContainerModule((bind: interfaces.Bind) => {
        bind(TYPES.ActivityStorage).to(Redis);
        bind(TYPES.ActivityDBConnection).toConstantValue(settings.mongoConnection);

        bind<IActivityCollector>(TYPES.ActivityCollector)
            .to(ActivityLocalservice)
            .inSingletonScope()
            .whenTargetIsDefault();
    });

export const activityModuleNats: (settings: any, pubsub?: any) => interfaces.ContainerModule =
    settings =>
    new ContainerModule((bind: interfaces.Bind) => {
        bind(TYPES.ActivityStorage).to(Redis);
        bind(TYPES.ActivityDBConnection).toConstantValue(settings.mongoConnection);

        bind<IActivityCollector>(TYPES.ActivityCollector)
            .to(ActivityMicroservice)
            .inSingletonScope()
            .whenTargetNamed(TaggedType.MICROSERVICE);
    });

\`\`\`

## tools/templates/module/server/src/index.ts

\`\`\`ts
import { Feature } from '@common-stack/server-core';
import module from './module';

export * from './constants';
export default new Feature(module);

\`\`\`

## tools/templates/module/server/src/interfaces/index.ts

\`\`\`ts

\`\`\`

## tools/templates/module/server/src/module.ts

\`\`\`ts
import * as _ from 'lodash';
import { TaggedType } from '@common-stack/core';
import { Feature } from '@common-stack/server-core';

import { TYPES } from './constants';
import { activityModule, activityModuleNats } from './containers';
import { interfaces } from 'inversify';
import { IActivityCollector } from './interfaces';
import { config } from './config';

const createActivityServiceFunc = (container: interfaces.Container) => {
    const environment = container.get('Environment');
    if (environment === 'development') {
        return {
            activityService: container.get<IActivityCollector>(TYPES.ActivityCollector),
        };
    } else {
        return {
            activityService: container.getNamed<IActivityCollector>(TYPES.ActivityCollector, TaggedType.MICROSERVICE),
        };
    }
};


export default new Feature({
    createContainerFunc: config.isDevelopment ? [activityModule] : [activityModule, activityModuleNats],
    createServiceFunc: createActivityServiceFunc,
    beforeware: [
        (app) => {
            app.use('/graphql', (req, res, next) => {
                const user = _.get(req.user, 'sub');
                req.services.activityService.user({ key: user, timestamp: Date.now() });

                next();
            });
        },
    ],
});

\`\`\`

## tools/templates/module/server/src/plugin/index.ts

\`\`\`ts
import * as ILogger from 'bunyan';
const Hp = require('hemera-plugin');
import * as Hemera from 'nats-hemera';
import { Container } from 'inversify';
const HemeraJoi = require('hemera-joi');
import { NatsPubSub } from 'graphql-nats-subscriptions';


function WorkspaceServicePlugin(hemera: Hemera, options: { settings: any, client: any }, done) {

  const { settings, client } = options;
  const topic = `${HemeraTopics.ActivityCollector}/${settings.subTopic}`;

  const pubsub = new NatsPubSub({ client, logger: hemera.log });

  let container = new Container();

}

module.exports = Hp(WorkspaceServicePlugin, {
  hemera: '>=2.0.0-0',
  name: require('../../package.json').name,
});

\`\`\`

## tools/templates/module/server/src/services/index.ts

\`\`\`ts

\`\`\`

## tools/templates/module/server/tsconfig.json

\`\`\`json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "rootDir": "./src",
    "outDir": "../lib",
    "declarationDir": "../lib",
    "typeRoots": [
      "../../../node_modules/@types"
    ],
    "skipLibCheck": true
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
\`\`\`

## tools/templates/module/server/webpack.config.js

\`\`\`js
var nodeExternals = require('webpack-node-externals');
var webpack = require('webpack');
var path = require('path');
var fs = require('fs');

var webpackOpts = {
  mode: 'development',
  entry: {
    index: './src/index.ts',
    plugin: './src/plugin/index.ts',
  },
  target: 'node',
  output: {
    path: path.join(__dirname, 'lib'),
    filename: '[name].js',
    libraryTarget: "commonjs2",
  },
  node: {
    __dirname: false
  },
  resolve: {
    extensions: ['.ts', '.tsx', '.graphql', '.gql'],
  },
  plugins: [
    new webpack.LoaderOptionsPlugin({
      options: {
        test: /\.tsx?$/,
        ts: {
          compiler: 'typescript',
          configFile: 'tsconfig.json'
        },
        tslint: {
          emitErrors: true,
          failOnHint: true
        }
      }
    })
  ],
  devtool: 'source-map',
  module: {
    rules: [{
      test: /\.tsx?$/,
      loaders: 'ts-loader'
    }, {
      test: /\.graphql?/,
      exclude: /node_modules/,
      use: 'raw-loader',
    }, {
      test: /\.(gql)$/,
      exclude: /node_modules/,
      use: ['graphql-tag/loader']
    }
    ]
  },
  externals: [
    nodeExternals({ modulesDir: "../../../node_modules" }),
    nodeExternals()
  ]
};

module.exports = webpackOpts;

\`\`\`

## tools/update-dependency-version.js

\`\`\`js
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable @typescript-eslint/no-floating-promises */
/* eslint-disable no-restricted-syntax */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-shadow */
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/restrict-template-expressions */
/* eslint-disable consistent-return */
const glob = require('glob');
const path = require('path');
const fs = require('fs');

const SERVER_FOLDER = './servers';
const simpleGit = require('simple-git/promise');

const git = simpleGit();

glob(
    './+(servers|packages|packages-modules)/**/package.json',
    { onlyFiles: false, ignore: ['**/node_modules/**'] },
    (err, files) => {
        if (err) return console.error(`Unable to scan directory: ${err}`);
        files.forEach((file) => {
            fs.readFile(file, 'utf-8', (err, data) => {
                if (err) return console.error(`Unable to scan directory: ${err}`);
                try {
                    const obj = JSON.parse(data);
                    const { dependencies } = obj;
                    const fileWrie = file;
                    const packageDir = path.dirname(file);
                    console.log('---PACKAGE DIR', packageDir);
                    for (const key in dependencies) {
                        if (dependencies[key].includes('link:')) {
                            const relativeDepFolder = dependencies[key].split('link:')[1];
                            console.log('--FOLDER ROAD', relativeDepFolder);
                            const dependencyFolder = path.join(packageDir, relativeDepFolder);
                            try {
                                fs.readdirSync(dependencyFolder);
                            } catch (err) {
                                console.log(
                                    `--- err Search for dependency of ${file} with package path ${relativeDepFolder} not found`,
                                );
                                console.log(`--- err ${err.message}`);
                                return;
                            }
                            glob(`${dependencyFolder}/package.json`, null, (err, files) => {
                                if (err) return console.error(`Unable to scan directory: ${err}`);
                                console.log(files);
                                files.forEach((file) => {
                                    fs.readFile(file, 'utf-8', (err, data) => {
                                        if (err) return console.error(`Unable to scan directory: ${err}`);

                                        const objVersion = JSON.parse(data);
                                        const { version } = objVersion;
                                        dependencies[key] = `${version}`;
                                        const str = JSON.stringify(obj, null, 2);
                                        fs.writeFileSync(fileWrie, str, 'ascii');
                                    });
                                });
                            });
                        }
                    }
                } catch (err) {
                    console.error(`Errored at ${file}`);
                    console.error(err);
                }
            });
        });
        git.add('.')
            .then(() => {
                git.status()
                    .then((status) => {
                        console.log('POST GIT CHANGES', status);
                        if (status.modified.length) {
                            const fileArray = status.modified.filter((element) => element.includes('package.json'));
                            const addArray = fileArray.map((element) => `./${element}`);
                            git.add(addArray);
                            git.commit('corrected packages version!');
                        } else console.log('no change');
                    })
                    .catch((err) => console.error(err));
            })
            .catch((err) => console.error(err));
    },
);

\`\`\`

## tools/webpack-util.js

\`\`\`js
/* eslint-disable no-multi-assign */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable func-names */
/* eslint-disable no-undef */

const path = require('path');
/* helper function to get into build directory */
module.exports = libPath = function (name) {
    if (undefined === name) {
        return path.join('dist');
    }

    return path.join('lib', name);
};

\`\`\`

## tools/webpackAppConfig.js

\`\`\`js
const dependencyPlatforms = {
    '@cdm-logger/server': 'server',
    bunyan: 'server',
    'export-dir': 'server',
    express: 'server',
    'body-parser': 'server',
    envalid: 'server',
    'apollo-server-express': 'server',
    'graphql-subscriptions': 'server',
    'graphql-tools': 'server',
    'graphql-tag': ['server', 'web'],
    'immutability-helper': ['ios', 'android', 'web'],
    'isomorphic-fetch': 'server',
    knex: 'server',
    mysql2: 'server',
    persistgraphql: ['server', 'web'],
    'graphql-nats-subscriptions': 'server',
    'graphql-server-core': 'server',
    helmet: 'server',
    'hemera-joi': 'server',
    'hemera-plugin': 'server',
    'hemera-safe-promises': 'server',
    'hemera-sql-store': 'server',
    'hemera-zipkin': 'server',
    inversify: 'server',
    morgan: 'server',
    nats: 'server',
    'nats-hemera': 'server',
    nconf: 'server',
    'node-pre-gyp': 'server',
    'prop-types': 'web',
    ramda: ['web', 'server'],
    'reflect-metadata': 'server',
    sequelize: 'server',
    'react-native': ['ios', 'android'],
    'react-navigation': ['ios', 'android'],
    'serialize-javascript': 'server',
    'source-map-support': 'server',
    sqlite3: 'server',
    'styled-components': ['server', 'web'],
    'subscriptions-transport-ws': ['ios', 'android', 'web'],
    ws: ['server'],
};

module.exports = { dependencyPlatforms };

\`\`\`

## transform.js

\`\`\`js
const config = {
    babelrc: false,
    presets: ["@babel/preset-env", "@babel/preset-react",
    // ["@babel/preset-typescript", { isTSX: true, allExtensions: true }]
  ],
    plugins: [
      ["@babel/plugin-proposal-class-properties", { loose: true }],
      "@babel/plugin-transform-runtime",
      "@babel/plugin-syntax-dynamic-import",
      "@babel/plugin-proposal-object-rest-spread",
    ],
  };
  module.exports = require("babel-jest").createTransformer(config);
  
\`\`\`

## tsconfig.json

\`\`\`json
{
  "compilerOptions": {
    "target": "es2017",
    "module": "commonjs",
    "moduleResolution": "node",
    "jsx": "react",
    "declaration": true,
    "experimentalDecorators": true,
    "preserveConstEnums": true,
    "sourceMap": true,
    "noImplicitAny": false,
    "allowSyntheticDefaultImports": false,
    "pretty": true,
    "removeComments": false,
    "lib": [
      "es2017",
      "dom",
      "esnext.asynciterable"
    ],
    "types": [
      "@types/node",
      "@types/jest"
    ]
  },
  "include": [
    "./typings/*.d.ts"
  ]
}
\`\`\`

## typings/graphql.d.ts

\`\`\`ts

declare module '*/AddCounter.client.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const addCounterState: DocumentNode;

  export default defaultDocument;
}
    

declare module '*/AddCounter.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const addCounter: DocumentNode;

  export default defaultDocument;
}
    

declare module '*/AddCounter_WS.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const AddCounter_WS: DocumentNode;

  export default defaultDocument;
}
    

declare module '*/SyncCachedCounter.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const SyncCachedCounter: DocumentNode;

  export default defaultDocument;
}
    

declare module '*/CounterCacheQuery_WS.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const counterCacheQuery: DocumentNode;

  export default defaultDocument;
}
    

declare module '*/CounterQuery.client.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const CounterState: DocumentNode;

  export default defaultDocument;
}
    

declare module '*/CounterQuery.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const counterQuery: DocumentNode;

  export default defaultDocument;
}
    

declare module '*/CounterSubscription.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const onCounterUpdated: DocumentNode;

  export default defaultDocument;
}
    
\`\`\`

## typings/index.d.ts

\`\`\`ts
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable @typescript-eslint/naming-convention */
/* eslint-disable no-underscore-dangle */
declare const __DEV__;
declare const __ENV__;
declare const __BACKEND_URL__;
declare const __GRAPHQL_URL__;
declare const __PERSIST_GQL__;
declare const __FRONTEND_BUILD_DIR__: string;
declare const __DLL_BUILD_DIR__: string;
declare const __SSR__;
declare const __CLIENT__;
declare const __SERVER__;
declare const __APOLLO_STATE__;
declare const __REDUX_DEVTOOLS_EXTENSION_COMPOSE__;
declare const __DEBUGGING__;

declare interface Window {
    /** Apollo Cache to restore in the browser in SSR mode */
    __APOLLO_STATE__?: any;
    /** Apollo Dev tools  */
    __APOLLO_CLIENT__?: any;
    __PRELOADED_STATE__?: any;
    __INITIAL_STATE__?: any;
    __ENV__?: any;
    __SERVER_ERROR__?: any;
    __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: <F extends Function>(f: F) => F;
}
declare module '*settings.json' {
    export const app: {
        apolloLogging: boolean;
    };
    export const database: {};
}

declare interface __ZEN_OPTIONS__ {
    backendBuildDir?: string;
    frontendBuildDir?: string;
    webpackDevPort?: number;
    ssr?: boolean;
    webpackDll?: boolean;
    dllBuildDir?: string;
    frontendRefreshOnBackendChange?: boolean;
    reactHotLoader?: boolean;
    debugSQL?: boolean;
    persistGraphQL?: boolean;
}

declare interface __PUBLIC_SETTINGS__ {
    apolloLogging: boolean;
    GRAPHQL_URL: string;
    GRAPHQL_SUBSCRIPTION_URL?: string;
    LOCAL_GRAPHQL_URL?: string;
    LOG_LEVEL?: string;
}

declare interface __SETTINGS__ extends __ZEN_OPTIONS__, __PUBLIC_SETTINGS__ {
    CLIENT_URL: string;
    BACKEND_URL: string;
    NATS_URL: string;
    NATS_USER: string;
    NATS_PW: number | string;
}

declare namespace NodeJS {
    export interface Process {
        APP_ENV?: ProcessEnv;
        env: ProcessEnv;
    }
}

declare module '*zenrc.json' {
    export const options: __ZEN_OPTIONS__;
}

declare module '*.json' {
    const value: any;
    export = value;
}

declare module '*.graphql' {
    const value: string;
    export default value;
}

declare module '*.graphqls' {
    const value: string;
    export default value;
}

declare module '*.png' {
    const content: any;
    export default content;
}

declare module '*.jpg' {
    const content: any;
    export default content;
}

declare module '*.svg' {
    const content: any;
    export default content;
}

declare module '*.gif' {
    const fileName: string;
    export = fileName;
}

declare module '*.html' {
    const fileName: string;
    export = fileName;
}

// This definition is used before typings-for-css-modules-loader generates .d.ts files.
// As soon as typings are found tsc will prefer them.
declare module '*.css' {
    interface IClassNames {
        [className: string]: string;
    }

    const classNames: IClassNames;
    export = classNames;
}

\`\`\`

## values.secret.json

\`\`\`json
 GITCRYPT �ߘ>WW����gvc"�u�V9x
\`\`\`


```

# codegen.yml

```yml
overwrite: true
schema: "./servers/backend-server/generated-schema.graphql"
generates:
  typings/graphql.d.ts:
    schema: 
      - "packages-modules/counter/browser/src/apollo-server-n-client/**/*.graphql"
      - packages-modules/counter/server/src/schema/**/*.graphql
    documents: "packages-modules/counter/browser/src/**/*.gql"
    plugins:
      - typescript-graphql-files-modules
  packages-modules/counter/browser/src/generated-models.ts:
    schema: 
      - "packages-modules/counter/browser/src/apollo-server-n-client/**/*.graphql"
      - packages-modules/counter/server/src/schema/**/*.graphql
    documents: "packages-modules/counter/browser/src/**/*.gql"
    config:
        noNamespaces: true
        withMutationFn: false
        withHOC: false
        withComponent: false
    plugins:
      - add:
          content: /* tslint:disable */
      - typescript
      - typescript-operations
      - typescript-resolvers
      - typescript-react-apollo
  packages-modules/counter/browser/src/apollo-server-n-client/generated-model.tsx:
    schema: 
      - "packages-modules/counter/browser/src/apollo-server-n-client/**/*.graphql"
      - packages-modules/counter/server/src/schema/**/*.graphql
    documents: "packages-modules/counter/browser/src/**/*.gql"
    config:
      withMutationFn: false
      withHOC: false
      withComponent: true
      withHooks: true
    preset: import-types-preset
    presetConfig:
      typesPath: "../generated-models"
      importTypesNamespace: SchemaTypes
    plugins:
      - add:
          content: /* tslint:disable */
      - typescript-react-apollo
```

# build.config.js

```js

const __SERVER_PORT__ = 8080;
const __SERVER_PROTOCOL__ = 'http';
const __SERVER_HOST__ = 'localhost';
const __GRAPHQL_ENDPOINT__ = 'graphql';
const config = {
    __SERVER__: false,
    __CLIENT__: true,
    __SSR__: false,
    __DEBUGGING__: false,
    __TEST__: false,
    __API_URL__: process.env.API_URL || `${__SERVER_PROTOCOL__}://${__SERVER_HOST__}:${__SERVER_PORT__}/${__GRAPHQL_ENDPOINT__}`,
    __WEBSITE_URL__: process.env.WEBSITE_URL || `${__SERVER_PROTOCOL__}://${__SERVER_HOST__}:${__SERVER_PORT__}`,
};

module.exports = config;

```

# babel.config.js

```js
module.exports = {
    compact: false,
    presets: [
        '@babel/preset-typescript',
        '@babel/preset-react',
        ['@babel/preset-env', { modules: 'commonjs', loose: true }],
    ],
    plugins: [
        'react-hot-loader/babel',
        '@babel/plugin-transform-modules-commonjs',
        '@babel/plugin-transform-destructuring',
        '@babel/plugin-transform-for-of',
        '@babel/plugin-transform-regenerator',
        '@babel/plugin-transform-runtime',
        '@babel/plugin-syntax-dynamic-import',
        '@babel/plugin-proposal-class-properties',
        ['@babel/plugin-proposal-decorators', { legacy: true }],
        '@babel/plugin-proposal-object-rest-spread',
        //   ['styled-components', { ssr: true }],
        ['import', { libraryName: '@ant-design/react-native' }],
    ],
    env: {
        production: {
            compact: true,
        },
    },
};

```

# ScreenShot.png

This is a binary file of the type: Image

# README.md

```md
# Full Stack Packages

*Fullstack packages to develop and test end to end; to use as packages or work independently.*

Purpose: 
---
The idea is to create modules for each package so it can work independently as well as integrated to another project as packages. 

## Screenshot
![screencast](./ScreenShot.png)


Useful commands:
---
|command|Description|
|--------------------------|-----------|    
|`lerna clean`|                 - removes the node_modules directory from all packages. |
|`npm start`|       - starts the web server and backend server. Or Use `yarn zen:watch`|
|`yarn zen:watch`|         - starts the web server and backend server in watch mode.|
|`yarn zen:watch:debug`|    - starts the web server and backend server in debug and watch mode.|
|`yarn watch`|               - build the packages in watchmode (Useful for development)|
|`yarn lerna`|               - install external dependencies at the repo root so they're |`lable to all packages.|
|`yarn build`|               - build all the packages|
|`yarn install`|                - runs `lerna` and `build`|
|`lerna publish`|               - publishes packages in the current Lerna project. |

Files explained:
---    
It uses `lerna.json` for creating the packages structure. Under packages you can create different modules based on its usage. For example:

     packages                    - Has the packages to organize the codebase into multi-package repositories.
         sample-core             - Core interfaces of the packages which can be shared between server and client.
         sample-platform/server      - Core platform interfaces and its implementation code for Server.   
         sample-platform/browser     - Core platform browser State related code which consists of Redux, Graphql Gql and UI Components.
         sample-platform/react-shared-components     - React pure components and containers are defined. 
     packages-modules            - Has the server and browser side packages designed for a specific module feature.
     servers                     - Has the servers to organize the codebase into multi-package repositories.
         frontend-server         - Frontend Client Server. This is useful to show demo of this package.
         backend-server          - Backend apollo server. 
    

## [Click here for Project Setup](docs/development/CodeContribution/Project_Setup.md)

In Order to get started with the development you need to go through the 
documentation first

- [Getting Started with lerna](./docs/development/CodeContribution/lerna-build-tools.md)
- [Running the servers](./docs/development/CodeContribution/How_to_Run_Various_Options.md)
- [Dos and Dont](./docs/development/CodeContribution/DoAndDont.md)


```

# LICENSE

```
The MIT License

Copyright (c) 2017 CDMBase LLC.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
```

# Jenkinsfile

```
// Global Variable so it can be changed between stages
def GIT_BRANCH_NAME=getGitBranchName()

pipeline {
  agent {
    kubernetes{
      label 'slave-2cpu-8gb'
    }
  }
  parameters {
    string(name: 'REPOSITORY_SERVER', defaultValue: 'gcr.io/stack-test-186501', description: 'Registry server URL to pull/push images', trim: true)
    string(name: 'NAMESPACE', defaultValue: 'default', description: 'In which namespace micro services needs to be deploy', trim: true)
    string(name: 'CONNECTION_ID', defaultValue: 'test', description: 'connection id', trim: true)
    string(name: 'WORKSPACE_ID', defaultValue: 'fullstack-pro', description: 'workspace id', trim: true)
    string(name: 'UNIQUE_NAME', defaultValue: 'default', description: 'chart name', trim: true)
    string(name: 'HEMERA_LOG_LEVEL', defaultValue: 'info', description: 'log level for hemera')
    string(name: 'LOG_LEVEL', defaultValue: 'info', description: 'log level')
    string(name: 'DEPLOYMENT_PATH', defaultValue: '/servers', description: 'folder path to load helm charts')
    string(name: 'PUBLISH_BRANCH', defaultValue: 'devpublish', description: 'publish branch')
    string(name: 'EXCLUDE_SETTING_NAMESPACE_FILTER', defaultValue: 'brigade', description: 'exclude setting namespace that matches search string')
    string(name: 'GIT_CREDENTIAL_ID', defaultValue: 'fullstack-pro-github-deploy-key', description: 'jenkins credential id of git deploy secret')
    string(name: 'REPOSITORY_SSH_URL', defaultValue: 'git@github.com:cdmbase/fullstack-pro.git', description: 'ssh url of the git repository')
    string(name: 'REPOSITORY_BRANCH', defaultValue: 'develop', description: 'the branch of repository')
    string(name: 'DEVELOP_BRANCH', defaultValue: 'develop', description: 'Develop branch as default for the development.')
    string(name: 'MASTER_BRANCH', defaultValue: 'master', description: 'Master branch as default branch for production.')

    // by default first value of the choice will be choosen
    choice choices: ['auto', 'force'], description: 'Choose merge strategy', name: 'NPM_PUBLISH_STRATEGY'
    choice choices: ['yarn', 'npm'], description: 'Choose build strategy', name: 'BUILD_STRATEGY'
    choice choices: ['0.4.0', '0.3.0', '0.1.22'], description: 'Choose Idestack chart version', name: 'IDESTACK_CHART_VERSION'
    choice choices: ['nodejs14', 'nodejs12'], description: 'Choose NodeJS version', name: 'NODEJS_TOOL_VERSION'    
    choice choices: ['buildOnly', 'buildAndTest', 'buildAndPublish',  'mobileBuild', 'mobilePreview', 'devDeployOnly', 'stageDeploy', 'prodDeploy', 'prodDeployOnly', 'allenv'], description: 'Where to deploy micro services?', name: 'ENV_CHOICE'
    booleanParam (defaultValue: false, description: 'Tick to enable debug mode', name: 'ENABLE_DEBUG')
    string(name: 'BUILD_TIME_OUT', defaultValue: '120', description: 'Build timeout in minutes', trim: true)
  }

 // Setup common + secret key variables for pipeline.
  environment {
    BUILD_COMMAND = getBuildCommand()
    PYTHON='/usr/bin/python'
    GCR_KEY = credentials('jenkins-gcr-login-key')
    EXPO_TOKEN = credentials('expo_cdmbase_token')
    GIT_PR_BRANCH_NAME = getGitPrBranchName()
    GITHUB_HELM_REPO_TOKEN = credentials('github-helm-repo-access-token')
  }

  // Initialize npm and docker commands using plugins
  tools {
    nodejs params.NODEJS_TOOL_VERSION
  }

  stages {

    stage('define environment') {
      steps {
        // skip the build if ends with `[skip ci]` which is equivalent to regex `.*\[skip ci\]$`
        scmSkip(deleteBuild: true, skipPattern:'.*\\[skip ci\\]\\s')
        checkout([$class: 'GitSCM', branches: [[name: '*/'+ params.REPOSITORY_BRANCH]],
        doGenerateSubmoduleConfigurations: false, extensions: [[$class: 'WipeWorkspace']],
        submoduleCfg: [], userRemoteConfigs: [[credentialsId: params.GIT_CREDENTIAL_ID, url: params.REPOSITORY_SSH_URL]]])
        sh "git checkout ${env.GIT_PR_BRANCH_NAME}"

        // env.NODEJS_HOME = "${tool 'node_v8'}"
  	    // env.PATH="${env.NODEJS_HOME}/bin:${env.PATH}"
  	    //sh 'npm --version'
      }
    }

    stage('Unlock secrets'){ //unlock keys for all runs
      environment{ deployment_env = 'dev' }
      steps{
        sh '''
           gpg --import /tmp/gpg-public-key/gpg-public-key.pub
           gpg --import /tmp/gpg-private-key/gpg-private-key.key
           git-crypt unlock
        '''
        load "./jenkins_variables.groovy"
        // if we need to load stag configuration for different location.
        // sh "curl -H 'Authorization: token ${env.GITHUB_ACCESS_TOKEN}' -H 'Accept: application/vnd.github.v3.raw' -O -L https://raw.githubusercontent.com/cdmbase/kube-orchestration/master/idestack/values-stage.yaml"
      }
    }

    // Install packages. If
    // a. any branch
    // b. ENV_CHOICE set not selected `dev`, `stage` or `prod`
    stage ('Install git repository'){
       steps{
          sh """
            echo "what is docker git version $GIT_BRANCH_NAME -- ${params.ENV_CHOICE}"
            ${params.BUILD_STRATEGY} install
            ${params.BUILD_STRATEGY} run lerna
          """
       }
    }

    stage ('Mobile Build'){
      when {
        expression { params.ENV_CHOICE == 'mobileBuild' || params.ENV_CHOICE == 'mobilePreview' }
      }
      steps{
        sh """
            rm .npmrc
            lerna exec --scope=*mobile-device ${params.BUILD_STRATEGY} ${env.BUILD_COMMAND}
        """
      }
    }

    // Run build for all cases except when ENV_CHOICE is 'buildAndPublish' and `dev`, `stage` or `prod`
    stage ('Build Packages'){
      when {
        expression { params.ENV_CHOICE == 'buildOnly' || params.ENV_CHOICE == 'buildAndTest' || params.ENV_CHOICE == 'buildAndPublish' }
      }
      steps{
        sh """
          ${params.BUILD_STRATEGY} run build
        """
      }
    }

    // Test build for all cases except when ENV_CHOICE is 'buildAndPublish' and `dev`, `stage` or `prod`
    stage ('Test Packages'){
      when {
        expression { params.ENV_CHOICE == 'buildAndTest' }
      }
      steps{
        sh """
          ${params.BUILD_STRATEGY} run test
        """
      }
    }

    // if PR is from branch other than `develop` then merge to `develop` if we chose ENV_CHOICE as 'buildAndPublish'.
    // Skip this stage. Future implementation.
    stage ('Merge PR, Install, Build'){
      when {
        expression { params.ENV_CHOICE == '1' }
      }
      steps{
        sh """
          git checkout ${params.DEVELOP_BRANCH}
          git merge ${env.GIT_PR_BRANCH_NAME} -m 'auto merging'
          ${params.BUILD_STRATEGY} install
          ${params.BUILD_STRATEGY} run lerna
          ${params.BUILD_STRATEGY} run build
        """
        script {
          GIT_BRANCH_NAME = params.DEVELOP_BRANCH
        }
      }
    }

    // publish packages to npm repository.
    // commit new package-lock.json that might get generated during install
    // Build will be ignore with tag '[skip ci]'
    stage ('Publish Packages'){
      when {
        expression { GIT_BRANCH_NAME == params.DEVELOP_BRANCH }
        expression { params.ENV_CHOICE == 'buildOnly' ||  params.ENV_CHOICE == 'buildAndPublish' }
      }
      steps{
        script {
          GIT_BRANCH_NAME=params.PUBLISH_BRANCH
        }
        sshagent (credentials: [params.GIT_CREDENTIAL_ID]) {
          sh """
            git add -A
            git diff --staged --quiet || git commit -am 'auto build\r\n[skip ci]'
            git fetch origin ${params.DEVELOP_BRANCH}
            git checkout ${params.DEVELOP_BRANCH}
            ${params.BUILD_STRATEGY} run devpublish:${params.NPM_PUBLISH_STRATEGY};
            git push origin ${params.DEVELOP_BRANCH}
            git checkout ${params.PUBLISH_BRANCH}
          """
        }
      }
    }

    stage('Docker login'){
      steps{
        sh 'cat "$GCR_KEY" | docker login -u _json_key --password-stdin https://gcr.io'
      }
    }

    stage('Dev Docker Images') {
      options {
         timeout(time: params.BUILD_TIME_OUT, unit: 'MINUTES')
       }
      when {
        // Docker build need be performed in PUBLISH branch only
        expression { GIT_BRANCH_NAME == params.PUBLISH_BRANCH }
        expression { params.ENV_CHOICE == 'buildOnly' }
      }

      // Below variable is only set to load all (variables, functions) from jenkins_variables.groovy file.
      environment{ deployment_env = 'dev' }
        steps{
          load "./jenkins_variables.groovy"
          script {
            def servers = getDirs(pwd() + params.DEPLOYMENT_PATH)
            def parallelStagesMap = servers.collectEntries {
             ["${it}" : generateBuildStage(it)]
            }
            parallel parallelStagesMap
          }
        }
    }

  // Below are dev stages
    stage('Dev deployment') {
      environment{
          deployment_env = 'dev'
      }
      when {
        expression { GIT_BRANCH_NAME == params.PUBLISH_BRANCH ||  GIT_BRANCH_NAME == params.DEVELOP_BRANCH }
        expression { params.ENV_CHOICE == 'buildOnly' || params.ENV_CHOICE == 'devDeployOnly' }
        beforeInput true
      }

      steps {
       withKubeConfig([credentialsId: 'kubernetes-preproduction-1-cluster', serverUrl: 'https://35.243.206.245']) {         
         sh """
            helm repo add stable https://charts.helm.sh/stable
            helm repo add incubator https://charts.helm.sh/incubator
            helm repo add kube-orchestration https://"""+ GITHUB_HELM_REPO_TOKEN +"""@raw.githubusercontent.com/cdmbase/kube-orchestration/develop
            helm repo update
         """
          script {

            nameSpaceCheck = sh(script: "kubectl get ns | tr '\\n' ','", returnStdout: true)
            if (!nameSpaceCheck.contains(params.NAMESPACE)) { sh "kubectl create ns " + params.NAMESPACE }

            def servers = getDirs(pwd() + params.DEPLOYMENT_PATH)
            def parallelStagesMap = servers.collectEntries {
             ["${it}" : generateStage(it, deployment_env)]
            }
            parallel parallelStagesMap
          }
        }
      }
    } // End of dev deployment code block.

  // Only master branch will be merged
    stage ('Merge Develop to master & Install'){
      when {
        expression { GIT_BRANCH_NAME == params.MASTER_BRANCH }
        expression { params.ENV_CHOICE == 'stageDeploy' || params.ENV_CHOICE == 'prodDeploy' }
      }
      steps{
        sh """
          git checkout ${params.REPOSITORY_BRANCH}
          git merge origin/${params.DEVELOP_BRANCH} -m 'auto merging'
          ${params.BUILD_STRATEGY} install
          ${params.BUILD_STRATEGY} run lerna
          ${params.BUILD_STRATEGY} run build
        """
        script {
          GIT_BRANCH_NAME = params.REPOSITORY_BRANCH
        }
      }
    }
  
    // Run build for all cases except when ENV_CHOICE is 'buildAndPublish' and `dev`, `stage` or `prod`
    stage ('Prod Build Packages'){
      when {
        expression { GIT_BRANCH_NAME == params.MASTER_BRANCH }
        expression { params.ENV_CHOICE == 'stageDeploy' || params.ENV_CHOICE == 'prodDeploy' }
      }
      steps{
        sh """
          ${params.BUILD_STRATEGY} run build
        """
      }
    }

  // publish packages to npm repository.
    // commit new package-lock.json that might get generated during install
    // Build will be ignore with tag '[skip ci]'
    stage ('Prod Publish Packages'){
      when {
        expression { GIT_BRANCH_NAME == params.MASTER_BRANCH }
        expression { params.ENV_CHOICE == 'stageDeploy' || params.ENV_CHOICE == 'prodDeploy' }
      }
      steps{
        script {
          GIT_BRANCH_NAME=params.PUBLISH_BRANCH
        }
        sshagent (credentials: [params.GIT_CREDENTIAL_ID]) {
          sh """
            git add -A
            git diff --staged --quiet || git commit -am 'auto build\r\n[skip ci]'
            git fetch origin ${params.MASTER_BRANCH}
            git checkout ${params.MASTER_BRANCH}
            ${params.BUILD_STRATEGY} run publish:${params.NPM_PUBLISH_STRATEGY};
            git checkout ${params.PUBLISH_BRANCH}
          """
        }
      }
    }
  
  // Build Docker containers for production.
    stage('Prod Docker Images') {
      options {
         timeout(time: params.BUILD_TIME_OUT, unit: 'MINUTES')
       }
      when {
        // required to be in Publish branch to build docker
        expression { GIT_BRANCH_NAME == params.PUBLISH_BRANCH }
        expression { params.ENV_CHOICE == 'stageDeploy' || params.ENV_CHOICE == 'prodDeploy' }
      }

      // Below variable is only set to load all (variables, functions) from jenkins_variables.groovy file.
      environment{ deployment_env = 'prod' }
        steps{
          load "./jenkins_variables.groovy"
          script {
            def servers = getDirs(pwd() + params.DEPLOYMENT_PATH)
            def parallelStagesMap = servers.collectEntries {
             ["${it}" : generateBuildStage(it)]
            }
            parallel parallelStagesMap
          }
        }
    } // End of production docker build.


  // Below are stage code block
    stage('Stage Deployment') {
      options {
         timeout(time: 300, unit: 'SECONDS')
       }
      environment{
        deployment_env = 'stage'
      }
      when {
        expression { GIT_BRANCH_NAME == params.MASTER_BRANCH || GIT_BRANCH_NAME == params.PUBLISH_BRANCH }
        expression {params.ENV_CHOICE == 'stageDeploy' || params.ENV_CHOICE == 'prodDeploy'}
        beforeInput true
      }

      steps {
        load "./jenkins_variables.groovy"
        withKubeConfig([credentialsId: 'kubernetes-dev-cluster', serverUrl: 'https://0.0.0.0']) {
          
          sh """
            helm repo add stable https://charts.helm.sh/stable
            helm repo add incubator https://charts.helm.sh/incubator
            helm repo add kube-orchestration https://"""+ GITHUB_HELM_REPO_TOKEN +"""@raw.githubusercontent.com/cdmbase/kube-orchestration/develop
            helm repo update
          """
          script {
            nameSpaceCheck = sh(script: "kubectl get ns | tr '\\n' ','", returnStdout: true)
            if (!nameSpaceCheck.contains(params.NAMESPACE)) { sh "kubectl create ns " + params.NAMESPACE }

            def servers = getDirs(pwd() + params.DEPLOYMENT_PATH)
            def parallelStagesMap = servers.collectEntries {
              ["${it}" : generateStage(it, deployment_env)]
            }
            parallel parallelStagesMap
          }
        }
      }
    } // End of staging deployment code block.



  // Below are production stages
    stage('Prod Deployment') {
      options {
        timeout(time: 300, unit: 'SECONDS')
      }
      environment{
        deployment_env = 'prod'
      }
      when {
        expression { GIT_BRANCH_NAME == params.MASTER_BRANCH || GIT_BRANCH_NAME == params.PUBLISH_BRANCH }
        expression { params.ENV_CHOICE == 'prodDeploy' || params.ENV_CHOICE == 'prodDeployOnly' }
        beforeInput true
      }

      input {
        message "Want to deploy fullstack-pro on prod cluster?"
        parameters {
          choice choices: ['yes', 'no'], description: 'Want to deploy micro service on prod?', name: 'PROD_DEPLOYMENT'
        }
      }

      steps {
        load "./jenkins_variables.groovy"
        withKubeConfig([credentialsId: 'kubernetes-prod-cluster', serverUrl: 'https://104.196.165.88']) {
          sh """
             helm repo add stable https://charts.helm.sh/stable
             helm repo add incubator https://charts.helm.sh/incubator
             helm repo add kube-orchestration https://"""+ GITHUB_HELM_REPO_TOKEN +"""@raw.githubusercontent.com/cdmbase/kube-orchestration/develop
             helm repo update
           """
          script {
            nameSpaceCheck = sh(script: "kubectl get ns | tr '\\n' ','", returnStdout: true)
            if (!nameSpaceCheck.contains(params.NAMESPACE)) { sh "kubectl create ns " + params.NAMESPACE }
            
            def servers = getDirs(pwd() + params.DEPLOYMENT_PATH)
            def parallelStagesMap = servers.collectEntries {
             ["${it}" : generateStage(it, deployment_env)]
            }
            parallel parallelStagesMap
          }
       }
      }
    } // End of production deployment code block.

  }

  post {
    always {
      deleteDir()
    }
    success{
      slackSend (color: '#00FF00', message: "SUCCESSFUL:  Job  '${env.JOB_NAME}'  BUILD NUMBER:  '${env.BUILD_NUMBER}'  Job success. click <${env.RUN_DISPLAY_URL}|here> to see the log.", channel: 'idestack-automation')
    }
    failure{
      slackSend (color: '#FF0000', message: "FAILED:  Job  '${env.JOB_NAME}'  BUILD NUMBER:  '${env.BUILD_NUMBER}'  Job failed. click <${env.RUN_DISPLAY_URL}|here> to see the log.", channel: 'idestack-automation')
    }
  }
}

def getBuildCommand(){
  if(params.ENV_CHOICE == 'mobileBuild'){
    return 'build:auto'
  }
  if(params.ENV_CHOICE == 'mobilePreview'){
    return 'build:preview'
  }
  if(params.ENABLE_DEBUG.toBoolean()){
    return 'build:debug'
  } else {
    return 'build'
  }
}

def getGitPrBranchName() {
    // The branch name could be in the BRANCH_NAME or GIT_BRANCH variable depending on the type of job
  //def branchName = env.BRANCH_NAME ? env.BRANCH_NAME : env.GIT_BRANCH
  //return branchName || ghprbSourceBranch
  if(env.ghprbSourceBranch){
    return env.ghprbSourceBranch
  } else {
    return params.REPOSITORY_BRANCH
  }
}

def getGitBranchName(){ // we can place some conditions in future
  if(env.ghprbSourceBranch){
    return env.ghprbSourceBranch
  } else {
    return params.REPOSITORY_BRANCH
  }
}

@NonCPS
//TODO: Fix below get method for Jenkins slave if possible.
def getDirs1(path){
  def currentDir = new File(path)
  def dirs = []
  currentDir.eachDir() {
      dirs << it.name
  }
  return dirs
}

// Below function to work in Jenkins slave
def getDirs(path){
    def currentDir = sh(script: "ls -CF "+path+" | tr '/' ' '", returnStdout: true)
    def dirs = []
    (currentDir.split()).each {
      dirs << "${it}"
    }
    return dirs
}

def generateStage(server, environmentType) {
  return {
    stage("stage: ${server}") {
      echo "This is ${server}."
      def filterExist = "${server}".contains(params.EXCLUDE_SETTING_NAMESPACE_FILTER)
      def namespace = filterExist ? '' : "--namespace=${params.NAMESPACE}"
      def name = getName(pwd() + "${params.DEPLOYMENT_PATH}/${server}/package.json")
      def version = getVersion(pwd() + params.DEPLOYMENT_PATH + "/${server}/package.json")
      def valuesFile = "values-${environmentType}.yaml"
      // deploy anything matching `*backend-server` or `*frontend-server` to use idestack chart
      try{
        if ("${server}".endsWith("backend-server") | "${server}".endsWith("frontend-server")) {
          echo "add deployment flag to - ${server} "

          if ("${server}".endsWith("frontend-server")){
            deployment_flag = " --set backend.enabled='false' --set external.enabled='true'"
          }

          if ("${server}".endsWith("backend-server")){
            deployment_flag = " --set frontend.enabled='false' --set external.enabled='false' --set ingress.enabled=false "
          }

          sh """
            helm upgrade -i \
            ${UNIQUE_NAME}-${server} \
            -f "${valuesFile}" \
            ${namespace} \
            ${deployment_flag} \
            --set frontend.image="${REPOSITORY_SERVER}/${name}" \
            --set frontend.imageTag=${version} \
            --set backend.image="${REPOSITORY_SERVER}/${name}" \
            --set backend.imageTag=${version} \
            --set settings.workspaceId="${WORKSPACE_ID}" \
            --set frontend.pullPolicy=Always \
            --set backend.pullPolicy=Always \
            --version=${IDESTACK_CHART_VERSION} \
              kube-orchestration/idestack
            """

        } else {
          sh """
            cd .${params.DEPLOYMENT_PATH}/${server}
            helm upgrade -i \
            ${UNIQUE_NAME}-${server}-api \
            -f "charts/chart/${valuesFile}" \
            ${namespace} \
            --set image.repository=${REPOSITORY_SERVER}/${name} \
            --set image.tag=${version} \
            charts/chart
          """

        }
      } catch (Exception err) {
        slackSend (color: '#FF0000', message: "FAILED:  Job  '${env.JOB_NAME}'  BUILD NUMBER:  '${env.BUILD_NUMBER}'  Job failed in stage deployment ${server}. click <${env.RUN_DISPLAY_URL}|here> to see the log. Error: ${err.toString()}", channel: 'idestack-automation')
        println err
        throw(err)
      }
    }
  }
}

// Docker build parllel loop
def generateBuildStage(server) {
  return {
    stage("stage: ${server}") {
     try{
      echo "This is ${server}."
      def name = getName(pwd() + params.DEPLOYMENT_PATH + "/${server}/package.json")
      def version = getVersion(pwd() + params.DEPLOYMENT_PATH + "/${server}/package.json")
        sh """
            lerna exec --scope=*${server} ${params.BUILD_STRATEGY} run docker:${env.BUILD_COMMAND};
            docker tag ${name}:${version} ${REPOSITORY_SERVER}/${name}:${version}
            docker push ${REPOSITORY_SERVER}/${name}:${version}
            docker rmi ${REPOSITORY_SERVER}/${name}:${version}
        """
      } catch (e) {
        slackSend (color: '#FF0000', message: "FAILED:  Job  '${env.JOB_NAME}'  BUILD NUMBER:  '${env.BUILD_NUMBER}'  Job failed in stage docker-build ${server}. click <${env.RUN_DISPLAY_URL}|here> to see the log. Error: ${e}", channel: 'idestack-automation')
        throw(e)
      }
    }
  }
}

import groovy.json.JsonSlurper
def getVersion(json_file_path){
  def inputFile = readFile(json_file_path)
  def InputJSON = new JsonSlurper().parseText(inputFile)
  def version = InputJSON.version
return version
}

def getName(json_file_path){
  def inputFile = readFile(json_file_path)
  def InputJSON = new JsonSlurper().parseText(inputFile)
  def name = InputJSON.name
return name
}

```

# ISSUES.md

```md
Resolving tags conflicts when running `lerna publish`
----
\`\`\`
$ git tag
v0.0.1
v0.0.4
\`\`\`
- remove the tag locally
\`\`\`
$ git tag -d v0.0.4
Deleted tag 'v0.0.4' (was c34157b)
$ git tag -d v0.0.1
Deleted tag 'v0.0.1' (was edfaa93)
\`\`\`
- remove the tag remotely
\`\`\`
$ git push origin :refs/tags/v0.0.4
To https://github.com/cdmbase/ide-stack.git
 - [deleted]         v0.0.4
$ git push origin :refs/tags/v0.0.1
To https://github.com/cdmbase/ide-stack.git
 - [deleted]         v0.0.1
\`\`\`


```

# Dockerfile

```
FROM jenkins/jenkins:lts
USER root
RUN apt-get clean && apt-get update && \
    apt-get install -y make python && \
    wget https://get.helm.sh/helm-v2.14.3-linux-amd64.tar.gz && \
    tar -xvf helm-v2.14.3-linux-amd64.tar.gz && \
    mv linux-amd64/helm /usr/bin/helm && \
    echo "git config --global core.sshCommand 'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'" >> /etc/profile && \
    rm -rf helm-v2.14.3-linux-amd64.tar.gz linux-amd64
USER jenkins

```

# CODE_OF_CONDUCT.md

```md
# Citizen Code of Conduct

## 1. Purpose

A primary goal of Fullstack Pro is to be inclusive to the largest number of contributors, with the most varied and diverse backgrounds possible. As such, we are committed to providing a friendly, safe and welcoming environment for all, regardless of gender, sexual orientation, ability, ethnicity, socioeconomic status, and religion (or lack thereof).

This code of conduct outlines our expectations for all those who participate in our community, as well as the consequences for unacceptable behavior.

We invite all those who participate in Fullstack Pro to help us create safe and positive experiences for everyone.

## 2. Open [Source/Culture/Tech] Citizenship

A supplemental goal of this Code of Conduct is to increase open [source/culture/tech] citizenship by encouraging participants to recognize and strengthen the relationships between our actions and their effects on our community.

Communities mirror the societies in which they exist and positive action is essential to counteract the many forms of inequality and abuses of power that exist in society.

If you see someone who is making an extra effort to ensure our community is welcoming, friendly, and encourages all participants to contribute to the fullest extent, we want to know.

## 3. Expected Behavior

The following behaviors are expected and requested of all community members:

 * Participate in an authentic and active way. In doing so, you contribute to the health and longevity of this community.
 * Exercise consideration and respect in your speech and actions.
 * Attempt collaboration before conflict.
 * Refrain from demeaning, discriminatory, or harassing behavior and speech.
 * Be mindful of your surroundings and of your fellow participants. Alert community leaders if you notice a dangerous situation, someone in distress, or violations of this Code of Conduct, even if they seem inconsequential.
 * Remember that community event venues may be shared with members of the public; please be respectful to all patrons of these locations.

## 4. Unacceptable Behavior

The following behaviors are considered harassment and are unacceptable within our community:

 * Violence, threats of violence or violent language directed against another person.
 * Sexist, racist, homophobic, transphobic, ableist or otherwise discriminatory jokes and language.
 * Posting or displaying sexually explicit or violent material.
 * Posting or threatening to post other people's personally identifying information ("doxing").
 * Personal insults, particularly those related to gender, sexual orientation, race, religion, or disability.
 * Inappropriate photography or recording.
 * Inappropriate physical contact. You should have someone's consent before touching them.
 * Unwelcome sexual attention. This includes, sexualized comments or jokes; inappropriate touching, groping, and unwelcomed sexual advances.
 * Deliberate intimidation, stalking or following (online or in person).
 * Advocating for, or encouraging, any of the above behavior.
 * Sustained disruption of community events, including talks and presentations.

## 5. Weapons Policy

No weapons will be allowed at Fullstack Pro events, community spaces, or in other spaces covered by the scope of this Code of Conduct. Weapons include but are not limited to guns, explosives (including fireworks), and large knives such as those used for hunting or display, as well as any other item used for the purpose of causing injury or harm to others. Anyone seen in possession of one of these items will be asked to leave immediately, and will only be allowed to return without the weapon. Community members are further expected to comply with all state and local laws on this matter.

## 6. Consequences of Unacceptable Behavior

Unacceptable behavior from any community member, including sponsors and those with decision-making authority, will not be tolerated.

Anyone asked to stop unacceptable behavior is expected to comply immediately.

If a community member engages in unacceptable behavior, the community organizers may take any action they deem appropriate, up to and including a temporary ban or permanent expulsion from the community without warning (and without refund in the case of a paid event).

## 7. Reporting Guidelines

If you are subject to or witness unacceptable behavior, or have any other concerns, please notify a community organizer as soon as possible. .



Additionally, community organizers are available to help community members engage with local law enforcement or to otherwise help those experiencing unacceptable behavior feel safe. In the context of in-person events, organizers will also provide escorts as desired by the person experiencing distress.

## 8. Addressing Grievances

If you feel you have been falsely or unfairly accused of violating this Code of Conduct, you should notify  with a concise description of your grievance. Your grievance will be handled in accordance with our existing governing policies. 



## 9. Scope

We expect all community participants (contributors, paid or otherwise; sponsors; and other guests) to abide by this Code of Conduct in all community venues--online and in-person--as well as in all one-on-one communications pertaining to community business.

This code of conduct and its related procedures also applies to unacceptable behavior occurring outside the scope of community activities when such behavior has the potential to adversely affect the safety and well-being of community members.

## 10. Contact info



## 11. License and attribution

The Citizen Code of Conduct is distributed by [Stumptown Syndicate](http://stumptownsyndicate.org) under a [Creative Commons Attribution-ShareAlike license](http://creativecommons.org/licenses/by-sa/3.0/). 

Portions of text derived from the [Django Code of Conduct](https://www.djangoproject.com/conduct/) and the [Geek Feminism Anti-Harassment Policy](http://geekfeminism.wikia.com/wiki/Conference_anti-harassment/Policy).

_Revision 2.3. Posted 6 March 2017._

_Revision 2.2. Posted 4 February 2016._

_Revision 2.1. Posted 23 June 2014._

_Revision 2.0, adopted by the [Stumptown Syndicate](http://stumptownsyndicate.org) board on 10 January 2013. Posted 17 March 2013._

```

# CHANGELOG.md

```md
# Changelog


## [0.8.0](https://github.com/cdmbase/fullstack-pro/compare/v0.0.40-alpha.12...v0.0.40-alpha.13) (2021-04-05)


> Dates follow the `dd/mm/yy` notation.
## 05/06/18 (v 0.3.2)
> Webpack4
** Breaking Change ** 
Removed `Staging` environment to go with standard `test` environment. 



## 11/10/17
| Package | Version | Changes |
| ---- | --- | --- |
| all | 0.1.1 | uses spinjs for build |

Still support backward compatibility for starting server.
```

# .travis.yml

```yml
language: node_js
node_js:
  - "8.4"
install:
  - npm config set spin=false
  - yarn install -g npm@5.2
  - yarn install -g coveralls
  - yarn install
os:
  - linux
  - osx
branches:
  only:
  - publish
script:
  - yarn test
# Allow Travis tests to run in containers.
sudo: false

```

# .npmrc

This is a binary file of the type: Binary

# .markdownlintignore

```
node_modules
dist
lib
.git
CHANGELOG.md
```

# .markdownlint.json

```json
{
    "default": true,
    "MD013": false,
    "MD042": false,
    "MD033": false
}
```

# .gitignore

```
dist
lib
# Logs
logs
*.log
npm-debug.log*

# remove unwanted
.expo 
.drawio-chrome

# Spinjs cache
.cache
.awcache

# Jest Env
globalConfig.json

# Runtime data
pids
*.pid
*.seed
*.sqlite3

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# node-waf configuration
.lock-wscript

# Compiled binary addons (http://nodejs.org/api/addons.html)
.build
build
build/Release

# Dependency directory
node_modules

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history
.dist

# IDE 
.idea
*.DS_Store
.DS_Store
dump.rdb
v8-compile-cache-0
```

# .gitattributes

```
values.secret.json filter=git-crypt diff=git-crypt
.npmrc filter=git-crypt diff=git-crypt
values-dev.yaml filter=git-crypt diff=git-crypt
values-stage.yaml filter=git-crypt diff=git-crypt
values-prod.yaml filter=git-crypt diff=git-crypt
```

# .eslintrc.js

```js
const common = {
    env: {
        node: true,
        es6: true,
        'jest/globals': true,
    },
    plugins: ['prettier', 'jest', 'markdown'],
    extends: ['airbnb-base', 'prettier', 'plugin:jest/all'],
    rules: {
        'prettier/prettier': 'error',
        'jest/no-disabled-tests': 'warn',
        'jest/no-focused-tests': 'error',
        'jest/no-identical-title': 'error',
        'jest/prefer-to-have-length': 'warn',
        'jest/valid-expect': 'error',
        'jest/expect-expect': 'off',
        'jest/prefer-expect-assertions': 'off',
        'jest/no-test-return-statement': 'off',
        'import/prefer-default-export': 'off',
        'import/extensions': 'off',
        'no-console': 'off',
        'no-iterator': 'off',
        'no-restricted-syntax': 'off',
        'no-await-in-loop': 'off',
        'consistent-return': 'off',
        'no-shadow': 'off',
        'no-unused-vars': 'off',
    },
};

module.exports = {
    root: true,
    overrides: [
        {
            /*
        eslint-plugin-markdown only finds javascript code block snippet.
        For specific spec, refer to https://github.com/eslint/eslint-plugin-markdown
        */
            files: ['**/*.js', '**/*.md'],
            ...common,
        },
        {
            files: ['**/*.ts'],
            parser: '@typescript-eslint/parser',
            env: common.env,
            plugins: [...common.plugins, '@typescript-eslint'],
            extends: [
                ...common.extends,
                'plugin:@typescript-eslint/recommended',
                'plugin:import/errors',
                'plugin:import/warnings',
                'plugin:import/typescript',
            ],
            rules: {
                ...common.rules,
                '@typescript-eslint/explicit-function-return-type': 'off',
            },
            settings: {
                'import/resolver': {
                    node: {
                        extensions: ['.js', '.jsx', '.ts', '.d.ts', '.tsx', '.graphql', '.gql'],
                    },
                    typescript: {
                        // alwaysTryTypes: true,
                        // paths: './tsconfig.json',
                    },
                },
            },
        },
    ],
};

```

# .eslintignore

```
node_modules
dist
lib
```

# .browserslistrc

```
defaults
not IE 11
not IE_Mob 11
```

# typings/index.d.ts

```ts
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable @typescript-eslint/naming-convention */
/* eslint-disable no-underscore-dangle */
declare const __DEV__;
declare const __ENV__;
declare const __BACKEND_URL__;
declare const __GRAPHQL_URL__;
declare const __PERSIST_GQL__;
declare const __FRONTEND_BUILD_DIR__: string;
declare const __DLL_BUILD_DIR__: string;
declare const __SSR__;
declare const __CLIENT__;
declare const __SERVER__;
declare const __APOLLO_STATE__;
declare const __REDUX_DEVTOOLS_EXTENSION_COMPOSE__;
declare const __DEBUGGING__;

declare interface Window {
    /** Apollo Cache to restore in the browser in SSR mode */
    __APOLLO_STATE__?: any;
    /** Apollo Dev tools  */
    __APOLLO_CLIENT__?: any;
    __PRELOADED_STATE__?: any;
    __INITIAL_STATE__?: any;
    __ENV__?: any;
    __SERVER_ERROR__?: any;
    __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: <F extends Function>(f: F) => F;
}
declare module '*settings.json' {
    export const app: {
        apolloLogging: boolean;
    };
    export const database: {};
}

declare interface __ZEN_OPTIONS__ {
    backendBuildDir?: string;
    frontendBuildDir?: string;
    webpackDevPort?: number;
    ssr?: boolean;
    webpackDll?: boolean;
    dllBuildDir?: string;
    frontendRefreshOnBackendChange?: boolean;
    reactHotLoader?: boolean;
    debugSQL?: boolean;
    persistGraphQL?: boolean;
}

declare interface __PUBLIC_SETTINGS__ {
    apolloLogging: boolean;
    GRAPHQL_URL: string;
    GRAPHQL_SUBSCRIPTION_URL?: string;
    LOCAL_GRAPHQL_URL?: string;
    LOG_LEVEL?: string;
}

declare interface __SETTINGS__ extends __ZEN_OPTIONS__, __PUBLIC_SETTINGS__ {
    CLIENT_URL: string;
    BACKEND_URL: string;
    NATS_URL: string;
    NATS_USER: string;
    NATS_PW: number | string;
}

declare namespace NodeJS {
    export interface Process {
        APP_ENV?: ProcessEnv;
        env: ProcessEnv;
    }
}

declare module '*zenrc.json' {
    export const options: __ZEN_OPTIONS__;
}

declare module '*.json' {
    const value: any;
    export = value;
}

declare module '*.graphql' {
    const value: string;
    export default value;
}

declare module '*.graphqls' {
    const value: string;
    export default value;
}

declare module '*.png' {
    const content: any;
    export default content;
}

declare module '*.jpg' {
    const content: any;
    export default content;
}

declare module '*.svg' {
    const content: any;
    export default content;
}

declare module '*.gif' {
    const fileName: string;
    export = fileName;
}

declare module '*.html' {
    const fileName: string;
    export = fileName;
}

// This definition is used before typings-for-css-modules-loader generates .d.ts files.
// As soon as typings are found tsc will prefer them.
declare module '*.css' {
    interface IClassNames {
        [className: string]: string;
    }

    const classNames: IClassNames;
    export = classNames;
}

```

# typings/graphql.d.ts

```ts

declare module '*/AddCounter.client.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const addCounterState: DocumentNode;

  export default defaultDocument;
}
    

declare module '*/AddCounter.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const addCounter: DocumentNode;

  export default defaultDocument;
}
    

declare module '*/AddCounter_WS.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const AddCounter_WS: DocumentNode;

  export default defaultDocument;
}
    

declare module '*/SyncCachedCounter.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const SyncCachedCounter: DocumentNode;

  export default defaultDocument;
}
    

declare module '*/CounterCacheQuery_WS.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const counterCacheQuery: DocumentNode;

  export default defaultDocument;
}
    

declare module '*/CounterQuery.client.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const CounterState: DocumentNode;

  export default defaultDocument;
}
    

declare module '*/CounterQuery.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const counterQuery: DocumentNode;

  export default defaultDocument;
}
    

declare module '*/CounterSubscription.gql' {
  import { DocumentNode } from 'graphql';
  const defaultDocument: DocumentNode;
  export const onCounterUpdated: DocumentNode;

  export default defaultDocument;
}
    
```

# tools/webpackAppConfig.js

```js
const dependencyPlatforms = {
    '@cdm-logger/server': 'server',
    bunyan: 'server',
    'export-dir': 'server',
    express: 'server',
    'body-parser': 'server',
    envalid: 'server',
    'apollo-server-express': 'server',
    'graphql-subscriptions': 'server',
    'graphql-tools': 'server',
    'graphql-tag': ['server', 'web'],
    'immutability-helper': ['ios', 'android', 'web'],
    'isomorphic-fetch': 'server',
    knex: 'server',
    mysql2: 'server',
    persistgraphql: ['server', 'web'],
    'graphql-nats-subscriptions': 'server',
    'graphql-server-core': 'server',
    helmet: 'server',
    'hemera-joi': 'server',
    'hemera-plugin': 'server',
    'hemera-safe-promises': 'server',
    'hemera-sql-store': 'server',
    'hemera-zipkin': 'server',
    inversify: 'server',
    morgan: 'server',
    nats: 'server',
    'nats-hemera': 'server',
    nconf: 'server',
    'node-pre-gyp': 'server',
    'prop-types': 'web',
    ramda: ['web', 'server'],
    'reflect-metadata': 'server',
    sequelize: 'server',
    'react-native': ['ios', 'android'],
    'react-navigation': ['ios', 'android'],
    'serialize-javascript': 'server',
    'source-map-support': 'server',
    sqlite3: 'server',
    'styled-components': ['server', 'web'],
    'subscriptions-transport-ws': ['ios', 'android', 'web'],
    ws: ['server'],
};

module.exports = { dependencyPlatforms };

```

# tools/webpack-util.js

```js
/* eslint-disable no-multi-assign */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable func-names */
/* eslint-disable no-undef */

const path = require('path');
/* helper function to get into build directory */
module.exports = libPath = function (name) {
    if (undefined === name) {
        return path.join('dist');
    }

    return path.join('lib', name);
};

```

# tools/update-dependency-version.js

```js
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable @typescript-eslint/no-floating-promises */
/* eslint-disable no-restricted-syntax */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-shadow */
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/restrict-template-expressions */
/* eslint-disable consistent-return */
const glob = require('glob');
const path = require('path');
const fs = require('fs');

const SERVER_FOLDER = './servers';
const simpleGit = require('simple-git/promise');

const git = simpleGit();

glob(
    './+(servers|packages|packages-modules)/**/package.json',
    { onlyFiles: false, ignore: ['**/node_modules/**'] },
    (err, files) => {
        if (err) return console.error(`Unable to scan directory: ${err}`);
        files.forEach((file) => {
            fs.readFile(file, 'utf-8', (err, data) => {
                if (err) return console.error(`Unable to scan directory: ${err}`);
                try {
                    const obj = JSON.parse(data);
                    const { dependencies } = obj;
                    const fileWrie = file;
                    const packageDir = path.dirname(file);
                    console.log('---PACKAGE DIR', packageDir);
                    for (const key in dependencies) {
                        if (dependencies[key].includes('link:')) {
                            const relativeDepFolder = dependencies[key].split('link:')[1];
                            console.log('--FOLDER ROAD', relativeDepFolder);
                            const dependencyFolder = path.join(packageDir, relativeDepFolder);
                            try {
                                fs.readdirSync(dependencyFolder);
                            } catch (err) {
                                console.log(
                                    `--- err Search for dependency of ${file} with package path ${relativeDepFolder} not found`,
                                );
                                console.log(`--- err ${err.message}`);
                                return;
                            }
                            glob(`${dependencyFolder}/package.json`, null, (err, files) => {
                                if (err) return console.error(`Unable to scan directory: ${err}`);
                                console.log(files);
                                files.forEach((file) => {
                                    fs.readFile(file, 'utf-8', (err, data) => {
                                        if (err) return console.error(`Unable to scan directory: ${err}`);

                                        const objVersion = JSON.parse(data);
                                        const { version } = objVersion;
                                        dependencies[key] = `${version}`;
                                        const str = JSON.stringify(obj, null, 2);
                                        fs.writeFileSync(fileWrie, str, 'ascii');
                                    });
                                });
                            });
                        }
                    }
                } catch (err) {
                    console.error(`Errored at ${file}`);
                    console.error(err);
                }
            });
        });
        git.add('.')
            .then(() => {
                git.status()
                    .then((status) => {
                        console.log('POST GIT CHANGES', status);
                        if (status.modified.length) {
                            const fileArray = status.modified.filter((element) => element.includes('package.json'));
                            const addArray = fileArray.map((element) => `./${element}`);
                            git.add(addArray);
                            git.commit('corrected packages version!');
                        } else console.log('no change');
                    })
                    .catch((err) => console.error(err));
            })
            .catch((err) => console.error(err));
    },
);

```

# tools/html-plugin-template.ejs

```ejs
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>
        <%= htmlWebpackPlugin.options.title %>
    </title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <div class="demo">
        <div id="content">
            Try building the demo:
            <pre>
        </pre> ...and refreshing this page!
        </div>
    </div>
    <footer class="dark">
        <section class="container copyright">
            CDMBase LLC
        </section>
    </footer>
</body>

</html>
```

# tools/get-symlinked-modules.js

```js
const fs = require('fs');
const path = require('path');

/**
 * Returns a mapping from the names of symlinked packages to the physical paths of each package.
 */
module.exports = function getSymlinkedNodeModulesForDirectory(packagePath) {
    const nodeModulesPath = path.join(packagePath, 'node_modules');
    const directories = listDirectoryContents(nodeModulesPath);

    const modules = {};
    for (const directory of directories) {
        // The directory is either a scope or a package
        if (directory.startsWith('@')) {
            const scopePath = path.join(nodeModulesPath, directory);
            const scopedPackageDirectories = fs.readdirSync(scopePath);
            for (const subdirectory of scopedPackageDirectories) {
                const dependencyName = `${directory}/${subdirectory}`;
                const dependencyPath = path.join(scopePath, subdirectory);
                if (fs.lstatSync(dependencyPath).isSymbolicLink()) {
                    modules[dependencyName] = fs.realpathSync(dependencyPath);
                }
            }
        } else {
            const dependencyName = directory;
            const dependencyPath = path.join(nodeModulesPath, directory);
            if (fs.lstatSync(dependencyPath).isSymbolicLink()) {
                modules[dependencyName] = fs.realpathSync(dependencyPath);
            }
        }
    }
    return modules;
};

function listDirectoryContents(directory) {
    try {
        return fs.readdirSync(directory);
    } catch (e) {
        if (e.code === 'ENOENT') {
            return [];
        }
        throw e;
    }
}

```

# tools/esm-wrapper.js

```js
/* eslint-disable import/no-unresolved */
/* eslint-disable no-global-assign */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable @typescript-eslint/no-unsafe-call */
require = require('esm')(module, { cjs: true });
module.exports = require('./main.js');

```

# tools/cli.js

```js
/* eslint-disable @typescript-eslint/no-var-requires */
// require('babel-register')({ presets: ['env'], plugins: ['transform-class-properties'] });
// require('babel-polyfill');
const prog = require('caporal');

const addModuleCommand = require('./cli/commands/add-module');
const deleteModuleCommand = require('./cli/commands/delete-module');
const CommandInvoker = require('./cli/command-invoker');

const commandInvoker = new CommandInvoker(addModuleCommand, deleteModuleCommand);

prog
  .version('1.0.0')
  .description('Full info: https://github.com/sysgears/apollo-universal-starter-kit/wiki/Apollo-Starter-Kit-CLI')
  // Add module
  .command('addmodule', 'Create a new Module.')
  .argument('<moduleName>', 'Module name')
  .argument(
    '[location]',
    'Where should new module be created. [both, server, browser]',
    ['both', 'server', 'browser'],
    'both',
  )
  .action((args, options, logger) => commandInvoker.runAddModule(args, options, logger))
  // Delete module
  .command('deletemodule', 'Delete a Module')
  .argument('<moduleName>', 'Module name')
  .argument('[location]', 'Where should we delete module. [both, server, browser]', ['both', 'server', 'browser'], 'both')
  .action((args, options, logger) => commandInvoker.runDeleteModule(args, options, logger));

prog.parse(process.argv);

```

# tools/.eslintrc

```
{
    "rules": {
        "import/no-extraneous-dependencies": 0
    }
}
```

# docs/References.md

```md



Hot Reload in Apollo Server 2
--
https://github.com/apollographql/apollo-server/issues/1275
```

# docs/Moleculer.md

```md


Connecting to moleculer
---

moleculer connect --ns default


References:
https://moleculer.services/docs/0.14/moleculer-cli.html
```

# .vscode/settings.json

```json
{
    "typescript.tsdk": "node_modules/typescript/lib"
}
```

# .vscode/launch.json

```json
{
    // Use IntelliSense to learn about possible Node.js debug attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            // Name of configuration; appears in the launch configuration drop down menu.
            "name": "Run jest",
            // Type of configuration. Possible values: "node", "mono".
            "type": "node",
            "request": "launch",
            // Workspace relative or absolute path to the program.
            "program": "${workspaceRoot}/node_modules/jest-cli/bin/jest.js",
            // Automatically stop program after launch.
            "stopOnEntry": false,
            // Command line arguments passed to the program.
            "args": [
                "--runInBand",
                "--testPathPattern",
                "index.test"
            ],
            // Workspace relative or absolute path to the working directory of the program being debugged. Default is the current workspace.
            "cwd": "${workspaceRoot}/packages/sample-graphql-schema",
            // Workspace relative or absolute path to the runtime executable to be used. Default is the runtime executable on the PATH.
            "runtimeExecutable": null,
            // Environment variables passed to the program.
            "env": {
                "NODE_ENV": "development"
            },
            "console": "integratedTerminal",
            "sourceMaps": false
        }
    ]
}
```

# .vscode/extensions.json

```json
{
"recommendations": [
    "dbaeumer.vscode-eslint"
]
}
```

# .git-crypt/.gitattributes

```
# Do not edit this file.  To specify the files to encrypt, create your own
# .gitattributes file in the directory where your files are.
* !filter !diff
*.gpg binary

```

# tools/cli/config.js

```js
const path = require('path');

const BASE_PATH = path.resolve(`${__dirname}/../..`);
const TEMPLATES_DIR = `${BASE_PATH}/tools/templates`;
const MODULE_TEMPLATES = `${TEMPLATES_DIR}/module`;

module.exports = {
    BASE_PATH,
    TEMPLATES_DIR,
    MODULE_TEMPLATES
};
```

# tools/cli/command-invoker.js

```js
const { MODULE_TEMPLATES } = require('./config');

/**
 * Class CommandInvoker. Takes all CLI operations and calls certain CLI operation depends of variables.
 */
class CommandInvoker {
    /**
     * Sets CLI operations (functions).
     * @constructor
     *
     * @param addModule - The function for creating a new module.
     * @param deleteModule - The function for deleting existing module.
     */
    constructor(addModule, deleteModule) {
        this.addModule = addModule;
        this.deleteModule = deleteModule;
    }

    /**
     * Calls CLI operation with correct location.
     *
     * @param func - The func to call.
     * @param location - The location for a new module [browser|server|both].
     * @param args - The function for deleting existing module.
     */
    static runCommand(func, location, ...args) {
        // browser
        if (location === 'browser' || location === 'both') {
            func(...args, 'browser');
        }
        // server
        if (location === 'server' || location === 'both') {
            func(...args, 'server');
        }
    }

    /**
     * Runs operation (function) for creating a new module.
     */
    runAddModule(args, options, logger) {
        const { moduleName, location = 'both' } = args;
        CommandInvoker.runCommand(this.addModule, location, logger, MODULE_TEMPLATES, moduleName);
    }

    /**
     * Runs operation (function) for deleting existing module.
     */
    runDeleteModule(args, options, logger) {
        const { moduleName, location = 'both' } = args;
        CommandInvoker.runCommand(this.deleteModule, location, logger, moduleName);
    }
}

module.exports = CommandInvoker;

```

# servers/moleculer-server/webpack.config.js

```js
var nodeExternals = require('webpack-node-externals');
const CopyWebpackPlugin = require('copy-webpack-plugin');
var webpack = require('webpack');
var path = require('path');
var fs = require('fs');

var webpackOpts = {   
  mode: 'development',
  entry: {
    main: './src/index.ts',
    'moleculer.config': './src/config/moleculer.config.ts',
  },
  target: 'node',
  output: {
    filename: "[name].js",
    libraryTarget: "commonjs2"
  },
  resolve: {
    extensions: ['.ts', '.js', '.json']
  },
  plugins: [
    new CopyWebpackPlugin({
      patterns: [{
        from: '../../tools/esm-wrapper.js',
        to: 'index.js',
      }]
    }),
    new webpack.LoaderOptionsPlugin({
      options: {
        test: /\.ts$/,
        ts: {
          compiler: 'typescript',
          configFile: 'tsconfig.json'
        },
        tslint: {
          emitErrors: true,
          failOnHint: true
        }
      }
    })
  ],
  devtool: 'source-map',
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: 'ts-loader',
        exclude: /(node_modules)/
      }
    ]
  },
  externals: [
    nodeExternals({ modulesDir: "../../node_modules" }),
    nodeExternals()
  ]

};

module.exports = webpackOpts;

```

# servers/moleculer-server/tsconfig.json

```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "sourceMap": true,
    "declaration": false,
    "outDir": "./dist",
    "pretty": true,
    "skipLibCheck": true,
    "types": [
      "jest",
      "node"
    ]
  },
  "exclude": [
    "node_modules",
    "test",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
```

# servers/moleculer-server/package.json

```json
{
  "name": "sample-stack-moleculer-server",
  "version": "0.0.1",
  "private": true,
  "description": "My Moleculer microservices project",
  "keywords": [
    "microservices",
    "moleculer"
  ],
  "author": "",
  "scripts": {
    "prebuild": "yarn build:clean",
    "build": "cross-env NODE_ENV=production yarn build:dist",
    "build:clean": "rimraf dist",
    "build:debug": "cross-env DEBUGGING=true NODE_ENV=production yarn build:dist",
    "build:dist": "webpack",
    "build:watch": "yarn build:dist -- --watch",
    "cli": "moleculer connect --config ./dist/moleculer.config.js",
    "cli:dev": " cross-env ENV_FILE=../../config/development/dev.env yarn cli",
    "cli:docker": " cross-env NODE_ENV=staging ENV_FILE=../../config/staging/docker-staging.env  yarn cli",
    "cli:staging": " cross-env NODE_ENV=staging ENV_FILE=../../config/staging/staging.env  yarn cli",
    "cli:test": " cross-env NODE_ENV=test ENV_FILE=../../config/test/test.env  yarn cli",
    "docker:build": "yarn build && docker build . -t $npm_package_name:$npm_package_version",
    "docker:run": "docker run -it --env-file ../../config/staging/docker-staging.env  $npm_package_name:$npm_package_version",
    "jest": "./node_modules/.bin/jest",
    "start": "node dist/index.js",
    "start:dev": "cross-env ENV_FILE=../../config/development/dev.env nodemon dist",
    "start:staging": "cross-env NODE_ENV=staging ENV_FILE=../../config/staging/staging.env node --harmony dist",
    "start:test": "cross-env NODE_ENV=test ENV_FILE=../../config/test/test.env nodemon dist",
    "pretest": "yarn build",
    "test": "jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn start:dev"
  },
  "dependencies": {
    "@cdm-logger/client": "^7.0.8",
    "@cdm-logger/server": "^7.0.7",
    "@common-stack/client-core": "0.1.11",
    "@common-stack/core": "0.1.11",
    "@common-stack/server-core": "0.1.11",
    "@sample-stack/core": "link:../../packages/sample-core",
    "@sample-stack/counter-module-server": "link:../../packages-modules/counter/server",
    "@sample-stack/platform-server": "link:../../packages/sample-platform/server",
    "apollo-datasource": "^0.7.0",
    "apollo-logger": "^0.3.3",
    "apollo-server-cache-memcached": "^0.6.7",
    "apollo-server-cache-redis": "^1.2.3",
    "apollo-server-caching": "^0.5.3",
    "apollo-server-errors": "^2.4.2",
    "dotenv": "^8.2.0",
    "envalid": "^7.2.2",
    "esm": "^3.2.25",
    "graphql": "^14.7.0",
    "graphql-bigint": "^1.0.0",
    "graphql-nats-subscriptions": "^1.5.0",
    "graphql-subscriptions": "^1.2.0",
    "graphql-tag": "^2.11.0",
    "graphql-type-json": "^0.3.1",
    "helmet": "^3.21.2",
    "inversify": "^5.0.1",
    "inversify-logger-middleware": "^3.1.0",
    "ioredis": "^4.14.1",
    "iterall": "1.3.0",
    "lodash": "^4.17.15",
    "moleculer": "^0.14.2",
    "moleculer-zipkin": "0.2.2",
    "mongoose": "^5.13.5",
    "nats": "^1.3.2",
    "reflect-metadata": "^0.1.13"
  },
  "devDependencies": {
    "cross-env": "^6.0.3",
    "pm2": "^4.2.1",
    "rimraf": "^3.0.0"
  },
  "peerDependencies": {
    "@cdm-logger/core": "*"
  },
  "engines": {
    "node": ">= 8.x.x"
  }
}

```

# servers/moleculer-server/draft.toml

```toml
[environments]
  [environments.development]
    name = "hemera-server"
    namespace = "default"
    wait = true
    watch = false
    watch-delay = 2
    auto-connect = false
    dockerfile = "Dockerfile"
    chart = ""
.LOG_LEVEL=trace",
          "env.HEMERA_LOG_LEVEL=trace",
          "env.CONNECTION_ID=v1",
          "env.NATS_URL=nats://microstack-nats.main-system.svc.cluster.local:4222",
          "env.NATS_USER=ruser",
          "env.NATS_PW=T0pS3cr3t",
          "env.REDIS_URL=redis://microstack-redis-cache.main-system.svc.cluster.local:6379",
          "env.MONGO_URL=mongodb://mongo-ha-mongodb-replicaset.main-system.svc.cluster.local:27017/idestack",
          "env.ZIPKIN_URL=microstack-zipkin.main-system.svc.cluster.local",
          "env.ZIPKIN_PORT=9411",
          ]
    chart = ""
  [environments.staging]
    name = "hemera-server"
    namespace = "default"
    wait = true
    watch = false
    watch-delay = 2
    auto-connect = false
    dockerfile = "Dockerfile"
    set = ["env.LOG_LEVEL=info",
          "env.HEMERA_LOG_LEVEL=info",
          "env.CONNECTION_ID=v1",
          "env.NATS_URL=nats://microstack-nats.main-system.svc.cluster.local:4222",
          "env.NATS_USER=ruser",
          "env.NATS_PW=T0pS3cr3t",
          "env.REDIS_URL=redis://microstack-redis-cache.main-system.svc.cluster.local:6379",
          "env.MONGO_URL=mongodb://mongo-ha-mongodb-replicaset.main-system.svc.cluster.local:27017/idestack",
          "env.ZIPKIN_URL=microstack-zipkin.main-system.svc.cluster.local",
          "env.ZIPKIN_PORT=9411",
          ]
    chart = ""
  [environments.production]
    name = "hemera-server"
    namespace = "default"
    wait = true
    watch = false
    watch-delay = 2
    auto-connect = false
    dockerfile = "Dockerfile"
    set = ["env.LOG_LEVEL=info",
          "env.HEMERA_LOG_LEVEL=info",
          "env.CONNECTION_ID=v1",
          "env.NATS_URL=nats://adminide-idestack-nats.adminide.svc.cluster.local:4222",
          "env.NATS_USER=ruser",
          "env.NATS_PW=T0pS3cr3t",
          "env.REDIS_URL=redis://microstack-redis-cache.main-system.svc.cluster.local:6379",
          "env.MONGO_URL=mongodb://mongo-ha-mongodb-replicaset.main-system.svc.cluster.local:27017/idestack",
          "env.ZIPKIN_URL=microstack-zipkin.main-system.svc.cluster.local",
          "env.ZIPKIN_PORT=9411",
          ]
    chart = ""


```

# servers/moleculer-server/README.md

```md
[![Moleculer](https://badgen.net/badge/Powered%20by/Moleculer/0e83cd)](https://moleculer.services)

# servers

## NPM scripts
- `yarn dev` - Start development mode (load all services locally with hot-reload & REPL)
- `yarn build`- Uses typescript to transpile service to javascript
- `npm start` - Start production mode (set `SERVICES` env variable to load certain services) (previous build needed)
- `yarn cli`: Start a CLI and connect to production. Don't forget to set production namespace with `--ns` argument in script
- `yarn ci` - Run continuous test mode with watching
- `npm test` - Run tests & generate coverage report
```

# servers/moleculer-server/Dockerfile

```
FROM node:14.17.3-alpine

# Copy package.json only to temp folder, install its dependencies,
# set workdir and copy the dependnecies there
# This way, dependnecies are cached without the need of cacheing all files.

COPY .npmrc /tmp/.npmrc 
ADD package.json /tmp/package.json
RUN set -ex \
	&& cd /tmp \
	&& yarn install \
	&& rm -f /tmp/.npmrc \
	&& mkdir -p /home/app \
	&& cp -a /tmp/node_modules /home/app/ \
	&& rm -Rf /tmp/*

WORKDIR /home/app

# Copy the rest of the files to the container workdir
ADD . /home/app

ENV PORT=3000
EXPOSE ${PORT}

CMD [ "yarn", "start" ]
```

# servers/moleculer-server/.npmrc

This is a binary file of the type: Binary

# servers/moleculer-server/.gitignore

```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Typescript v1 declaration files
typings/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# next.js build output
.next
```

# servers/moleculer-server/.draftignore

```
*.swp
*.tmp
*.temp
.git*

```

# servers/moleculer-server/.draft-tasks.toml

```toml

```

# servers/moleculer-server/.dockerignore

```
*
!dist/
!*.js
!*.json
!.npmrc
```

# servers/frontend-server/webpack.config.lint.js

```js
module.exports = require('zenjs').createWebpackConfig(__dirname, '.zenrc.js', 'web');
```

# servers/frontend-server/tsconfig.json

```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "declaration": false,
    "jsx": "react",
    "outDir": "./dist",
    "rootDir": "./src",
    "skipLibCheck": true
  },
  "include": ["../../typings/*.d.ts"],
  "exclude": ["node_modules", "lib", "dist", "webpack.config.js"]
}

```

# servers/frontend-server/package.json

```json
{
  "name": "sample-stack-frontend-server",
  "version": "0.0.1",
  "private": true,
  "description": "Sample Client server",
  "homepage": "https://github.com/cdmbase/fullstack-pro#readme",
  "bugs": {
    "url": "https://github.com/cdmbase/fullstack-pro/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/cdmbase/fullstack-pro.git"
  },
  "license": "MIT",
  "author": "CDMBase LLC",
  "main": "index.js",
  "scripts": {
    "prebuild": "yarn build:clean",
    "build": "cross-env NODE_ENV=production zen build",
    "build:clean": "rimraf dist .awcache",
    "build:debug": "cross-env DEBUGGING=true NODE_ENV=production zen build",
    "build:debug:verbose": "yarn build:debug -- -v",
    "build:dev": "cross-env NODE_ENV=development zen build",
    "docker:build": "cross-env NODE_OPTIONS='--max_old_space_size=4096' yarn build && docker build . -t $npm_package_name:$npm_package_version",
    "docker:build:debug": "yarn build:debug && docker build . -t $npm_package_name:$npm_package_version",
    "docker:run": "docker run  --env-file ../../config/staging/docker-staging.env  -p 3010:3010  -it $npm_package_name:$npm_package_version",
    "jest": "./node_modules/.bin/jest",
    "start": "cross-env NODE_ENV=production pm2-runtime  dist/index.js",
    "start:dev": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env node --harmony dist",
    "start:staging": "cross-env NODE_ENV=staging ENV_FILE=../../config/staging/staging.env node --harmony dist",
    "start:test": "cross-env NODE_ENV=test ENV_FILE=../../config/test/test.env node --harmony dist",
    "test": "jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env yarn zen:watch",
    "watch:debug": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env yarn zen:watch -- -v",
    "watch:ssr": "cross-env SSR=true && yarn watch",
    "watch:staging": "cross-env ENV_FILE=../../config/staging/staging.env yarn zen:watch",
    "watch:test": "cross-env ENV_FILE=../../config/test/test.env yarn zen:watch",
    "zen:watch": "zen watch -x"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js"
    ],
    "testRegex": "/__tests__/.*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "dependencies": {
    "@apollo/client": "~3.3.21",
    "@apollo/react-components": "^4.0.0",
    "@apollo/react-hoc": "^4.0.0",
    "@cdm-logger/client": "^7.0.8",
    "@cdm-logger/server": "^7.0.7",
    "@common-stack/client-core": "0.1.11",
    "@common-stack/client-react": "0.1.11",
    "@common-stack/core": "0.1.11",
    "@common-stack/server-core": "0.1.11",
    "@sample-stack/core": "link:../../packages/sample-core",
    "@sample-stack/counter-module-browser": "link:../../packages-modules/counter/browser",
    "@sample-stack/platform-browser": "link:../../packages/sample-platform/browser",
    "apollo-link-debounce": "^2.1.0",
    "apollo-link-logger": "^1.2.3",
    "apollo-logger": "^0.3.3",
    "browser-bunyan": "^1.6.3",
    "classnames": "^2.2.6",
    "connected-react-router": "^6.9.1",
    "cors": "^2.8.5",
    "dotenv": "^8.2.0",
    "envalid": "^7.2.2",
    "error-stack-parser": "^2.0.4",
    "esm": "^3.2.25",
    "express": "^4.17.1",
    "fela": "11.6.0",
    "fela-beautifier": "^11.6.0",
    "fela-dom": "11.6.0",
    "fela-font-renderer": "^5.0.25",
    "fela-perf": "^11.6.0",
    "fela-plugin-fallback-value": "^11.6.0",
    "fela-plugin-logger": "^11.6.0",
    "fela-plugin-lvha": "^5.0.16",
    "fela-plugin-prefixer": "^11.6.0",
    "fela-plugin-unit": "^11.6.0",
    "fela-plugin-validator": "^11.6.0",
    "fela-preset-web": "^11.6.0",
    "graphql": "^14.7.0",
    "graphql-tag": "^2.11.0",
    "history": "^4.10.1",
    "immutability-helper": "^3.0.1",
    "inversify": "^5.0.1",
    "isomorphic-fetch": "^2.2.1",
    "js-cookie": "^2.2.1",
    "lodash": "^4.17.15",
    "ramda": "^0.26.1",
    "react": "17.0.1",
    "react-dom": "17.0.1",
    "react-fela": "11.6.0",
    "react-helmet": "^6.1.0",
    "react-loadable": "^5.5.0",
    "react-redux": "^7.1.3",
    "react-router": "^5.2.1",
    "react-router-config": "^5.1.1",
    "react-router-dom": "^5.3.0",
    "react-transition-group": "^4.3.0",
    "redux": "^4.0.5",
    "redux-logger": "^3.0.6",
    "redux-observable": "^1.2.0",
    "redux-persist": "^6.0.0",
    "redux-thunk": "^2.3.0",
    "reflect-metadata": "^0.1.13",
    "reselect": "^4.0.0",
    "rxjs": "^6.5.3",
    "rxjs-compat": "^6.5.3",
    "rxjs-hooks": "^0.5.2",
    "serialize-javascript": "^4.0.0",
    "sourcemapped-stacktrace": "^1.1.11",
    "subscriptions-transport-ws": "0.9.18",
    "universal-cookie-express": "^4.0.1"
  },
  "devDependencies": {
    "@babel/polyfill": "7.7.0",
    "cross-env": "^6.0.3",
    "pm2": "^4.2.1",
    "raf": "3.4.1",
    "rimraf": "^3.0.0"
  },
  "peerDependencies": {
    "body-parser": "*"
  }
}
```

# servers/frontend-server/Dockerfile

```
# The official nodejs docker image
FROM node:14.17.3-alpine
ENV PYTHON /usr/bin/python

# Copy package.json only to temp folder, install its dependencies,
# set workdir and copy the dependnecies there
# This way, dependnecies are cached without the need of cacheing all files.

COPY .npmrc /tmp/.npmrc  
ADD package.json /tmp/package.json
RUN set -ex \
	&& cd /tmp \
	&& yarn install \
	&& rm -f /tmp/.npmrc \
	&& mkdir -p /home/app \
	&& cp -a /tmp/node_modules /home/app/ \
	&& rm -Rf /tmp/*

WORKDIR /home/app

# Copy the rest of the files to the container workdir
ADD . /home/app

ENV PORT=3000
EXPOSE ${PORT}

CMD ["yarn", "start"]

```

# servers/frontend-server/.zenrc.js

```js
const path = require('path');
var nodeExternals = require('webpack-node-externals');
const debug = process.env.DEBUGGING || false;
const { merge } = require('webpack-merge');
const webpack = require('webpack');
const Dotenv = require('dotenv-webpack');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const LodashModuleReplacementPlugin = require('lodash-webpack-plugin');

const config = {
    builders: {
        web: {
            webpackDLL: false,
            entry: './src/index.tsx',
            output: {
                chunkFilename: '[name].bundle.js',
                sourceMapFilename: '[file].map',
            },
            stack: ['web', 'react'],
            tsLoaderOptions: {
                // "configFile": "./tsconfig.json"
            },
            webpackDevPort: 3000,
            openBrowser: true,
            defines: {
                __CLIENT__: true,
            },
            test: {
                role: ['build', 'watch']
            },
            htmlTemplate: "../../tools/html-plugin-template.ejs",
            // Wait for backend to start prior to letting webpack load frontend page
            waitOn: ['tcp:localhost:8080'],
            enabled: true,
            webpackConfig: {
                plugins: [
                    new LodashModuleReplacementPlugin({
                        // Necessary as a workaround for https://github.com/apollographql/react-apollo/issues/1831
                        flattening: true
                      }),
                ],
                // for additional webpack configuration.
                resolve: process.env.NODE_ENV !== 'production'
                    ? {
                        alias: {
                            'react-dom': '@hot-loader/react-dom'
                        }
                    }
                    : {},
            }
        },
        server: {
            entry: './src/backend/app.ts',
            stack: ['server'],
            tsLoaderOptions: {
                // configFileName: "./tsconfig.json"
            },
            defines: {
                __SERVER__: true,
            },
            enabled: false,
            webpackConfig: {
                output: {
                    filename: 'main.js',
                    sourceMapFilename: '[file].map',
                },
                plugins: [
                    new CopyWebpackPlugin({
                        patterns: [{
                            from: '../../tools/esm-wrapper.js',
                            to: 'index.js',
                        }]
                    }),
                    new LodashModuleReplacementPlugin({
                        // Necessary as a workaround for https://github.com/apollographql/react-apollo/issues/1831
                        flattening: true
                      }),
                ],
                externals: [
                    nodeExternals(),
                    nodeExternals({ allowlist: [/webpack\/hot/i, /babel-polyfill/], modulesDir: "../../node_modules" })
                ],
            }
        },
        test: {
            stack: ['server'],
            roles: ['test'],
            defines: {
                __TEST__: true
            }
        }
    },
    options: {
        stack: [
            "apollo",
            "ts",
            "react",
            "webpack",
            "css"
        ],
        cache: '../../.cache',
        backendBuildDir: "dist",
        frontendBuildDir: "dist",
        dllBuildDir: "dist/.build/dll",
        ssr: false,
        backendUrl: "http://localhost:8080",
        webpackDll: true,
        reactHotLoader: true,
        useDefaultPostCss: true,
        persistGraphQL: false,
        frontendRefreshOnBackendChange: true,
        nodeDebugger: false,
        overridesConfig: "./tools/webpackAppConfig.js",
        plugins: [
            new Dotenv({
                path: process.env.ENV_FILE
            })
        ],
        defines: {
            __DEV__: process.env.NODE_ENV === 'development',
            __GRAPHQL_URL__: '"http://localhost:8080/graphql"',
        }
    }
};
if (process.env.NODE_ENV === 'development') {
    const dotEnvPlugin = {
        plugins: [
            new Dotenv({
                path: process.env.ENV_FILE
            })
        ],
    }
    config.builders.web.webpackConfig = merge(config.builders.web.webpackConfig, dotEnvPlugin);

}

if (process.env.SSR) {
    config.builders.server.enabled = true;
    config.options.defines.__BACKEND_URL__ = '"http://localhost:3010"';
    config.options.ssr = true;
    config.options.backendUrl = "http://localhost:3010";
}
if (process.env.NODE_ENV !== 'development') {
    config.builders.server.enabled = true;
    config.options.defines.__BACKEND_URL__ = '"http://localhost:3010"';
    config.options.ssr = true;
    config.options.backendUrl = "http://localhost:3010";
}

if (process.env.NODE_ENV === 'production') {
    // Generating source maps for production will slowdown compilation for roughly 25%
    config.options.sourceMap = false;
}


config.options.devProxy = config.options.ssr;

const extraDefines = {
    __SSR__: config.options.ssr,
    __PERSIST_GQL__: `'${config.options.persistGraphQL}'`,
    __FRONTEND_BUILD_DIR__: `'${config.options.frontendBuildDir}'`,
    __DLL_BUILD_DIR__: `'${config.options.dllBuildDir}'`,
    __DEBUGGING__: `'${debug}'`
};

if (process.env.NODE_ENV !== 'production') {

    if (!config.options.ssr) {
        console.log('Warning! exposing env variables in UI, only run in development.');
        var dotenv = require('dotenv-safe')
            .config(
                {
                    allowEmptyValues: true,
                    path: process.env.ENV_FILE,
                    example: '../../config/development/dev.env',
                });
        const envPlugin = {
            plugins: [
                new webpack.DefinePlugin({
                    "__ENV__": JSON.stringify(dotenv.parsed)
                }),
            ],
        }
        config.builders.web.webpackConfig = merge(config.builders.web.webpackConfig, envPlugin);
    }
}

config.options.defines = Object.assign(config.options.defines, extraDefines);
module.exports = config;
```

# servers/frontend-server/.npmrc

This is a binary file of the type: Binary

# servers/frontend-server/.npmignore

```
*
!dist/**

```

# servers/frontend-server/.dockerignore

```
*
!dist/
!*.js
!*.json
!.npmrc
```

# servers/frontend-server/.browserslistrc

```
defaults
not IE 11
not IE_Mob 11
```

# servers/backend-server/webpack.config.lint.js

```js
module.exports = require('zenjs').createWebpackConfig(__dirname, '.zenrc.js', 'server');
```

# servers/backend-server/tsconfig.json

```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "sourceMap": true,
    "declaration": false,
    "rootDirs": ["./src","../knexfile.ts"],
    "outDir": "./dist"
  },
  "include": [
    "../../typings/*.d.ts",
  ],
  "awesomeTypescriptLoaderOptions": {
    "reportFiles": [
      "../../typings/*.d.ts",
      "**/*.ts",
      "**/*.tsx"
    ]
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
```

# servers/backend-server/package.json

```json
{
  "name": "sample-stack-backend-server",
  "version": "0.0.1",
  "private": true,
  "description": "Starter kit for apollo server using webpack and typescript",
  "keywords": [
    "apollo",
    "apollo-server",
    "backend",
    "express",
    "graphiql",
    "graphql",
    "typescript",
    "webpack"
  ],
  "homepage": "https://github.com/cdmbase/fullstack-pro#readme",
  "bugs": {
    "url": "https://github.com/cdmbase/fullstack-pro/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/cdmbase/fullstack-pro.git"
  },
  "license": "MIT",
  "author": "CDMBase LLC",
  "main": "dist/index.js",
  "typings": "dist/main.d.ts",
  "scripts": {
    "build": "cross-env NODE_ENV=production zen build -x",
    "build:clean": "rimraf dist .awcache",
    "build:debug": "cross-env NODE_ENV=development zen build -x",
    "db:migrate": "knex -- migrate:latest --cwd . --knexfile ./knexfile.js",
    "db:migrate:rollback": "knex -- migrate:rollback  --cwd . --knexfile ./knexfile.js",
    "db:seed": "yarn db:migrate && knex -- seed:run  --cwd . --knexfile ./knexfile.js",
    "docker:build": "yarn build && docker build . -t $npm_package_name:$npm_package_version",
    "docker:build:debug": "yarn build:debug && docker build . -t $npm_package_name:$npm_package_version",
    "docker:run": "docker run  --env-file ../../config/staging/docker-staging.env -p 8080:8080 -it $npm_package_name:$npm_package_version",
    "docker:run:debug": "cross-env NODE_ENV=development docker run  --env-file ../../config/staging/docker-staging.env -p 8080:8080 -it $npm_package_name:$npm_package_version",
    "proddb:migrate": "NODE_ENV=production yarn db:migrate",
    "proddb:migrate:rollback": "NODE_ENV=production yarn db:migrate:rollback",
    "proddb:seed": "NODE_ENV=production yarn db:seed",
    "prepublish": "yarn build:clean",
    "stagedb:migrate": "cross-env ENV_FILE=../../config/test/test.env NODE_ENV=test yarn db:migrate",
    "stagedb:migrate:rollback": "cross-env ENV_FILE=../../config/test/test.env NODE_ENV=test yarn db:migrate:rollback",
    "stagedb:seed": "cross-env ENV_FILE=../../config/test/test.env NODE_ENV=test yarn db:seed",
    "start": "cross-env NODE_ENV=production pm2-runtime  dist/index.js",
    "start:staging": "cross-env NODE_ENV=staging ENV_FILE=../../config/staging/staging.env node --harmony dist",
    "start:test": "cross-env NODE_ENV=test ENV_FILE=../../config/test/test.env node --harmony dist",
    "test": "jest",
    "test:notify": "yarn test:watch -- --notify",
    "test:watch": "npm test -- --watch",
    "preupver": "npm test",
    "upver": "standard-version",
    "watch": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env yarn zen:watch",
    "watch:debug": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env yarn zen:watch -- -v",
    "watch:staging": "cross-env NODE_ENV=test ENV_FILE=../../config/staging/staging.env yarn zen:watch",
    "watch:test": "cross-env NODE_ENV=test ENV_FILE=../../config/test/test.env yarn zen:watch",
    "zen:watch": "zen watch -x"
  },
  "dependencies": {
    "@apollo/client": "~3.3.21",
    "@cdm-logger/server": "^7.0.7",
    "@common-stack/core": "0.1.11",
    "@common-stack/server-core": "0.1.11",
    "@graphql-tools/links": "^7.0.0",
    "@sample-stack/core": "link:../../packages/sample-core",
    "@sample-stack/counter-module-server": "link:../../packages-modules/counter/server",
    "@sample-stack/platform-server": "link:../../packages/sample-platform/server",
    "@sample-stack/store": "link:../../packages/sample-store",
    "apollo-datasource": "^0.7.0",
    "apollo-datasource-rest": "^0.8.0",
    "apollo-errors": "^1.9.0",
    "apollo-logger": "^0.3.3",
    "apollo-server-cache-memcached": "^0.6.7",
    "apollo-server-cache-redis": "^1.2.3",
    "apollo-server-caching": "^0.5.3",
    "apollo-server-core": "^2.21.1",
    "apollo-server-express": "^2.21.1",
    "apollo-server-plugin-response-cache": "^0.6.0",
    "app-root-path": "^3.0.0",
    "body-parser": "^1.19.0",
    "cors": "^2.8.5",
    "dataloader": "^2.0.0",
    "dotenv": "^8.2.0",
    "envalid": "^7.2.2",
    "esm": "^3.2.25",
    "express": "^4.17.1",
    "graphql": "^14.7.0",
    "graphql-bigint": "^1.0.0",
    "graphql-nats-subscriptions": "^1.5.0",
    "graphql-subscriptions": "^1.2.0",
    "graphql-tools": "^6.0.0",
    "graphql-type-json": "^0.3.1",
    "inversify": "^5.0.1",
    "ioredis": "^4.14.0",
    "isomorphic-fetch": "^2.2.1",
    "knex": "^0.20.4",
    "lodash": "^4.17.15",
    "moleculer": "^0.14.2",
    "moleculer-zipkin": "0.2.2",
    "mongoose": "^5.13.5",
    "morgan": "^1.9.1",
    "nats": "^1.3.2",
    "react": "17.0.1",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^6.5.3",
    "rxjs-compat": "^6.5.3",
    "subscriptions-transport-ws": "0.9.18",
    "universal-cookie-express": "^4.0.1",
    "ws": "^7.2.1"
  },
  "devDependencies": {
    "cross-env": "^6.0.3",
    "pm2": "^4.2.1",
    "rimraf": "^3.0.0"
  },
  "peerDependencies": {
    "@cdm-logger/core": "*",
    "apollo-server-errors": "*",
    "mongodb": "*"
  },
  "typescript": {
    "definition": "dist/main.d.ts"
  }
}
```

# servers/backend-server/knexfile.js

```js
// Update with your config settings.
var path = require('path');
require('dotenv').config({ path: process.env.ENV_FILE });

var connection = {
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  socketPath: process.env.DB_SOCKET_PATH,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
  multipleStatements: true,
  charset: 'utf8',
};
var DB_CLIENT = process.env.DB_TYPE || 'sqlite3';

var migrations_path = path.dirname(require.resolve('@sample-stack/store/lib/store/migrations/index'));
var seeds_path = path.dirname(require.resolve('@sample-stack/store/lib/store/seeds/index'));
module.exports = {

  development: {
    client: 'sqlite3',
    connection: {
      filename: './dev-db.sqlite3'
    },
    seeds: {
      directory: seeds_path,
    },
    migrations: {
      directory: migrations_path,
    },
    useNullAsDefault: true,
  },

  test: {
    client: DB_CLIENT,
    connection: connection,
    pool: {
      min: 2,
      max: 10
    },
    seeds: {
      directory: seeds_path,
    },
    migrations: {
      directory: migrations_path,
    },
    useNullAsDefault: true,
  },

  production: {
    client: DB_CLIENT,
    connection: connection,
    pool: {
      min: 2,
      max: 200
    },
    migrations: {
      directory: migrations_path,
    },
    useNullAsDefault: true,
  }

};

```

# servers/backend-server/generated-schema.graphql

```graphql

```

# servers/backend-server/README.md

```md
# webpack-apollo-server
Starter kit for apollo server using webpack and typescript

What does it include:
----
    1. exported schema as example for GraphQL Schema
    2. Working Apollo Server (webpack + tslint + tsloader)
    3. Typescript 2.0.0 => ES6
    4. Dockerfile to make the apollo-server a container.
    5. unit testing (mocha-webpack+chai) + coverage report (mocha-istanbul-spec+istanbul).
    6. working with graphql-tools
    7. standard-version for auto SemVer.

Notes
----
Please note that you will need to rename the library name in some files:

    1. package.json (ofcourse ;))

Useful commands:
----
    yarn build       - build the library files (Required for start:watch)
    yarn build:watch - build the library files in watchmode (Useful for development)
    npm test            - run tests once
    yarn test:watch  - run tests in watchmode (Useful for development)
    yarn test:growl  - run tests in watchmode with growl notification (even more useful for development)

How to run it:
----
\`\`\`bash
    npm start
\`\`\`

Files explained:
----
    1. src                         - directory is used for typescript code that is part of the project
        1a. main.ts                - Main server file. (Starting Apollo server)
        1b. main.spec.ts           - Tests file for main
        1c. schema                 - Module used to build schema
            - index.ts             - simple logic to merge all modules into a schema using graphql-tools
            - modules/             - directory for modules to be used with graphql-tools
        1c. schema.spec.ts         - Basic test for schema.
        1c. main.test.ts           - Main for tests runner.
    3. package.json                - file is used to describe the library
    4. tsconfig.json               - configuration file for the library compilation
    6. tslint.json                 - configuration file for the linter
    7. typings.json                - typings needed for the server
    8. webpack.config.js           - configuration file of the compilation automation process for the library
    9. webpack.config.test.js      - configuration file of the compilation when testing
    10. Dockerfile                 - Dockerfile used to describe how to make a container out of apollo server
    11. mocha-webpack.opts         - Options file for mocha-webpack

Output files explained:
----
    1. node_modules - directory npm creates with all the dependencies of the module (result of yarn install)
    2. dist         - directory contains the compiled server (javascript)
    3. html-report  - output of npm test, code coverage html report.


Database
----
Connects to memory database through Knex

Database configuration is set in `db-config.json`

Setup
----
Create a database and fill the data
\`\`\`
yarn db:seed         
\`\`\`
What files to be customized? 
----
Customizable files for a specific project would be the following
\`\`\`
src/container
src/middleware/graphql.ts
\`\`\`

The Person type - dynamic/parametrized query and drill down:
----
The person type was added to demonstrate a database like access, parametrized queries, resolvers and drill down.
The data is currently hard coded but simulates a storage. Each person has an id, name and sex. It also has a dynamic
field called matches. For demonstration purposes, this field will retrieve all members of the other sex by using a
resolver.

Since this is a computed field the query can be infinitely nested, for example, try in the graphiql editor this query:

    {
       getPerson(id: "1") {
         id,
         name
         sex
         matches {
           id
           name
           sex
           matches {
             id
             name
             sex
             matches {
               id
               name
               sex
             }
           }
         }
       }
     }

It will return a nested, alternating male/femal results.

To list all persons, use the `persons` query:

    {
      persons {
        id
        name
      }
    }

There is also an example of a mutation - `addPerson(name: String, sex: String)`, to use it:

    mutation {
        addPerson(name: "kuku", sex: "male"){
            id
            name
        }
    }

Note that the query generates a random id and that the added persons are transient,
i.e. not persisted and will be gone once you shut down the server.
```

# servers/backend-server/LICENSE

```
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<http://www.gnu.org/licenses/>.

```

# servers/backend-server/Dockerfile

```
# The official nodejs docker image
FROM node:14.17.3

ENV PYTHON /usr/bin/python

# Copy package.json only to temp folder, install its dependencies,
# set workdir and copy the dependnecies there
# This way, dependnecies are cached without the need of cacheing all files.

COPY .npmrc /tmp/.npmrc  
ADD package.json /tmp/package.json
RUN set -ex \
	&& cd /tmp \
	&& yarn install \
	&& rm -f /tmp/.npmrc \
	&& mkdir -p /home/app \
	&& cp -a /tmp/node_modules /home/app/ \
	&& rm -Rf /tmp/*

WORKDIR /home/app

# Copy the rest of the files to the container workdir
ADD . /home/app

ENV PORT=8080
EXPOSE ${PORT}

CMD ["yarn", "start"]

```

# servers/backend-server/CHANGELOG.md

```md
# Change Log

All notable changes to this project will be documented in this file. See [standard-version](https://github.com/conventional-changelog/standard-version) for commit guidelines.

<a name="0.2.0"></a>
# [0.2.0](https://github.com/DxCx/webpack-apollo-server/compare/v0.1.0...v0.2.0) (2017-01-25)


### Bug Fixes

* **schema:** Fixed connector test ([cfbe262](https://github.com/DxCx/webpack-apollo-server/commit/cfbe262))
* **tests:**  replace mocha/chai/istanbul with jest ([f8f9527](https://github.com/DxCx/webpack-apollo-server/commit/f8f9527))


### Features

* **compilers:** Removed babel ([39275e9](https://github.com/DxCx/webpack-apollo-server/commit/39275e9))
* **formatting:** Added editor config and applied style throughout the project. ([1aa8016](https://github.com/DxCx/webpack-apollo-server/commit/1aa8016))
* **schema:** Passing connectors through context ([1bd1ac7](https://github.com/DxCx/webpack-apollo-server/commit/1bd1ac7))



<a name="0.1.0"></a>
# 0.1.0 (2016-09-09)


### Features

* **graphql-tools:** changed vanilla graphql to graphql-tools ([#9](https://github.com/DxCx/webpack-apollo-server/issues/9)) ([b8435b1](https://github.com/DxCx/webpack-apollo-server/commit/b8435b1)), closes [graphql-tools/#121](https://github.com/DxCx/webpack-apollo-server/issues/121)
* **standard-version:** Added standard-version for auto SemVer ([e311e3e](https://github.com/DxCx/webpack-apollo-server/commit/e311e3e))
* **tests:** Added testing using mocha & istanbul ([#7](https://github.com/DxCx/webpack-apollo-server/issues/7)) ([0463daa](https://github.com/DxCx/webpack-apollo-server/commit/0463daa))

```

# servers/backend-server/.zenrc.js

```js
const url = require('url');
const path = require('path');
var nodeExternals = require('webpack-node-externals');
const CopyWebpackPlugin = require('copy-webpack-plugin');

const config = {
    builders: {
        server: {
            entry: './src/index.ts',
            stack: ['server'],
            tsLoaderOptions: {
                // "configFile": "./tsconfig.json"
            },
            defines: {
                __SERVER__: true
            },
            enabled: true,
            webpackConfig: {
                output: {
                    filename: 'main.js',
                    sourceMapFilename: '[file].map',
                },
                plugins: [
                    new CopyWebpackPlugin({
                        patterns: [{
                            from: '../../tools/esm-wrapper.js',
                            to: 'index.js',
                        }],
                    }),
                ],
                externals: [
                    nodeExternals({}),
                    nodeExternals({ allowlist: [/webpack\/hot/i], modulesDir: "../../node_modules" })
                ],
            }
        },
        test: {
            stack: ['server'],
            roles: ['test'],
            defines: {
                __TEST__: true
            }
        }
    },
    options: {
        stack: [
            'ts',
            "apollo",
            'webpack'
        ],
        cache: '../../.cache',
        ssr: false,
        backendBuildDir: "dist",
        frontendBuildDir: "dist",
        dllBuildDir: "dist/.build/dll",
        webpackDll: false,
        persistGraphQL: false,
        backendUrl: "http://{ip}:8080",
        frontendRefreshOnBackendChange: true,
        nodeDebugger: false,
        defines: {
            __DEV__: process.env.NODE_ENV !== 'production',
            __GRAPHQL_URL__: '"http://localhost:8080/graphql"',
        },

    }
};

config.options.devProxy = config.options.ssr;

if (process.env.NODE_ENV === 'test') {
}
if (process.env.NODE_ENV === 'production') {
    // Generating source maps for production will slowdown compilation for roughly 25%
    config.options.sourceMap = false;
}

const extraDefines = {
    __SSR__: config.options.ssr,
    __PERSIST_GQL__: config.options.persistGraphQL,
    __FRONTEND_BUILD_DIR__: `"../frontend-server/dist/web"`,
    __DLL_BUILD_DIR__: `"../frontend-server/dist/build/dll"`
};

config.options.defines = Object.assign(config.options.defines, extraDefines);

module.exports = config;

```

# servers/backend-server/.npmrc

This is a binary file of the type: Binary

# servers/backend-server/.npmignore

```
*
!lib/**

```

# servers/backend-server/.gitignore

```
node_modules/
coverage/
dist/
lib/
.tmp/
*.d.ts
*.log
*.tgz
*.yaml
yarn.lock
.idea/

```

# servers/backend-server/.dockerignore

```
*
!dist/
!*.js
!.zenrc.json
!package.json
!knexfile.ts
!.npmrc
```

# portable-devices/mobile/webpack.config.js

```js
const webpack = require('webpack');
const path = require('path');
const createExpoWebpackConfigAsync = require('@expo/webpack-config');

module.exports = async function (env, argv) {
    const config = await createExpoWebpackConfigAsync(env, argv);

    config.module.rules.push(
        {
            test: /\.js$/,
            loader: 'babel-loader',
            include: [path.join(__dirname, 'node_modules/react-router-native')],
        },
        {
            test: /\.js$/,
            loader: 'babel-loader',
            include: [path.join(__dirname, '../../node_modules/react-router-native')],
        },
    );
    config.plugins.push(
        new webpack.DefinePlugin({
            __CLIENT__: true,
            __DEBUGGING__: false,
        }),
    );
    return config;
};

```

# portable-devices/mobile/types.tsx

```tsx
export type RootStackParamList = {
  Root: undefined;
  NotFound: undefined;
};

export type BottomTabParamList = {
  TabOne: undefined;
  TabTwo: undefined;
};

export type TabOneParamList = {
  TabOneScreen: undefined;
};

export type TabTwoParamList = {
  TabTwoScreen: undefined;
};

```

# portable-devices/mobile/tsconfig.json

```json
{
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "jsx": "react-native",
    "lib": [
      "dom",
      "esnext"
    ],
    "moduleResolution": "node",
    "noEmit": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "strict": true
  },
  "extends": "expo/tsconfig.base"
}

```

# portable-devices/mobile/package.json

```json
{
  "name": "sample-stack-mobile-device",
  "version": "0.0.1",
  "private": true,
  "main": "index.js",
  "scripts": {
    "android": "expo run:android",
    "build": "yarn easBuild --profile development",
    "build:all": "yarn build -p all",
    "build:android": "yarn build -p android --clear-cache",
    "build:auto": "yarn build:all --non-interactive",
    "build:clean": "rimraf build .expo .tmp",
    "build:configure": "eas build:configure",
    "build:ios": "yarn build -p ios --clear-cache",
    "build:preview": "yarn easBuild --profile preview -p all --non-interactive",
    "cli": "node ../../tools/cli",
    "eas-build-post-install": "lerna exec --scope=@sample-stack/core --scope=@sample-stack/counter-module-mobile yarn build",
    "easBuild": "eas build",
    "eslint": "eslint --fix --ext js --ext jsx --ext json src",
    "exp-login": "cross-env NODE_ENV=production expo login -u $EXP_USERNAME -p $EXP_PASSWORD --non-interactive",
    "exp-publish": "yarn exp-login && yarn expo p --non-interactive",
    "ios": "expo run:ios",
    "lint": "yarn eslint && yarn tslint",
    "start": "expo start --dev-client",
    "submit": "eas submit",
    "test": "yarn tests && yarn lint",
    "tests": "jest",
    "tests:watch": "jest --watch",
    "tslint": "tslint --fix -p tsconfig.json -c ../../tslint.json",
    "watch": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env expo start --clear",
    "watch:android": "expo start --android",
    "watch:ios": "expo start --ios"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@apollo/client": "~3.3.21",
    "@cdm-logger/client": "^7.0.8",
    "@codler/react-native-keyboard-aware-scroll-view": "1.0.0",
    "@common-stack/client-core": "^0.1.11",
    "@common-stack/client-react": "^0.1.11",
    "@common-stack/core": "^0.1.11",
    "@expo/vector-icons": "^12.0.0",
    "@react-native-async-storage/async-storage": "~1.15.0",
    "@react-native-community/cameraroll": "^4.0.4",
    "@react-native-community/masked-view": "^0.1.10",
    "@react-native-community/netinfo": "6.0.2",
    "@react-native-community/picker": "^1.8.1",
    "@react-native-community/segmented-control": "^2.2.2",
    "@react-native-community/slider": "^4.1.7",
    "@react-native-community/viewpager": "^5.0.11",
    "@sample-stack/counter-module-mobile": "link:../../packages-modules/counter/mobile",
    "apollo-link-debounce": "^2.1.0",
    "apollo-link-logger": "^1.2.3",
    "apollo-logger": "^0.3.3",
    "browser-bunyan": "^1.6.3",
    "connected-react-router": "^6.9.1",
    "eas-cli": "^0.36.1",
    "expo": "~43.0.3",
    "expo-app-loading": "~1.2.1",
    "expo-asset": "~8.4.3",
    "expo-cli": "^4.13.0",
    "expo-constants": "~12.1.3",
    "expo-file-system": "~13.0.3",
    "expo-font": "~10.0.3",
    "expo-image-picker": "~11.0.3",
    "expo-keep-awake": "~10.0.0",
    "expo-linking": "~2.4.2",
    "expo-localization": "~11.0.0",
    "expo-notifications": "~0.13.3",
    "expo-permissions": "~13.0.3",
    "expo-random": "12.0.1",
    "expo-secure-store": "~11.0.3",
    "expo-splash-screen": "~0.13.5",
    "expo-status-bar": "~1.1.0",
    "expo-web-browser": "~10.0.3",
    "fela": "11.6.0",
    "fela-beautifier": "^11.6.0",
    "fela-dom": "11.6.0",
    "fela-font-renderer": "^5.0.25",
    "fela-native": "^11.6.1",
    "fela-perf": "^11.6.0",
    "fela-plugin-fallback-value": "^11.6.0",
    "fela-plugin-logger": "^11.6.0",
    "fela-plugin-lvha": "^5.0.16",
    "fela-plugin-prefixer": "^11.6.0",
    "fela-plugin-unit": "^11.6.0",
    "fela-plugin-validator": "^11.6.0",
    "fela-preset-web": "^11.6.0",
    "history": "^4.10.1",
    "immutability-helper": "^3.0.1",
    "inversify": "^5.0.1",
    "isomorphic-fetch": "^2.2.1",
    "lodash": "^4.17.4",
    "metro-minify-terser": "^0.56.0",
    "minilog": "^3.1.0",
    "native-base": "~3.2.2",
    "prop-types": "^15.6.0",
    "ramda": "^0.26.1",
    "react": "17.0.1",
    "react-dom": "17.0.1",
    "react-fela": "11.6.0",
    "react-helmet": "^6.1.0",
    "react-loadable": "^5.5.0",
    "react-native": "0.64.3",
    "react-native-dotenv": "^3.3.0",
    "react-native-gesture-handler": "~2.1.0",
    "react-native-keyboard-aware-scroll-view": "^0.9.3",
    "react-native-keyboard-spacer": "^0.4.1",
    "react-native-mime-types": "^2.3.0",
    "react-native-modal": "^11.6.1",
    "react-native-reanimated": "^2.2.0",
    "react-native-safe-area-context": "3.3.2",
    "react-native-screens": "~3.8.0",
    "react-native-simple-picker": "^3.1.2",
    "react-native-svg": "~12.1.1",
    "react-native-swipe-list-view": "^3.2.6",
    "react-native-web": "0.17.1",
    "react-redux": "^7.1.3",
    "react-router": "^5.2.1",
    "react-router-config": "^5.1.1",
    "react-router-dom": "^5.3.0",
    "react-router-native": "^5.2.1",
    "redux": "^4.0.5",
    "redux-logger": "^3.0.6",
    "redux-observable": "^1.2.0",
    "redux-persist": "^6.0.0",
    "redux-thunk": "^2.3.0",
    "reselect": "^4.0.0",
    "rxjs": "^6.5.3",
    "rxjs-compat": "^6.5.3",
    "rxjs-hooks": "^0.5.2",
    "sentry-expo": "~4.0.0",
    "subscriptions-transport-ws": "0.9.18"
  },
  "devDependencies": {
    "@babel/core": "^7.12.9",
    "@testing-library/react-native": "^5.0.3",
    "@types/expo": "^33.0.1",
    "@types/react": "^17.0.35",
    "@types/react-native": "~0.64.12",
    "@types/react-native-dotenv": "^0.2.0",
    "@types/react-native-keyboard-spacer": "^0.4.1",
    "@types/react-router-native": "^5.1.0",
    "babel-preset-expo": "8.5.1",
    "cross-env": "^6.0.3",
    "eslint-plugin-react-native": "^3.8.1",
    "expo-dev-client": "^0.6.3",
    "jest-expo": "^43.0.0",
    "lerna": "^4.0.0"
  },
  "peerDependencies": {
    "webpack": "*"
  }
}

```

# portable-devices/mobile/metro.config.js

```js
// Learn more https://docs.expo.io/guides/customizing-metro
const { getDefaultConfig } = require('expo/metro-config');
const path = require('path');

const projectRoot = __dirname;
const workspaceRoot = path.resolve(__dirname, '../..');

const config = getDefaultConfig(__dirname);

config.watchFolders = [workspaceRoot];
config.resolver.nodeModulesPath = [
    path.resolve(projectRoot, 'node_modules'),
    path.resolve(workspaceRoot, 'node_modules'),
];

module.exports = config;

```

# portable-devices/mobile/jest.config.js

```js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    preset: 'jest-expo',
    modulePathIgnorePatterns: [
        '<rootDir>/node_modules/react-native/Libraries/react-native/',
        '<rootDir>/node_modules/react-native/Libraries/vendor/core/whatwg-fetch.js',
        '<rootDir>/node_modules/react-native/jest/',
        '<rootDir>/node_modules/haul/',
        '<rootDir>/portable-devices/mobile/.expo/',
        '<rootDir>/portable-devices/mobile/node_modules/'
    ],
    name: packageJson.name,
    displayName: packageJson.name,
};
```

# portable-devices/mobile/index.js

```js
/* eslint-disable jest/require-hook */
/* eslint-disable import/no-unresolved */
/* eslint-disable import/no-extraneous-dependencies */
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in the Expo client or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

```

# portable-devices/mobile/eas.json

```json
{
  "cli": {
    "version": ">= 0.36.1"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "ios": {
        "simulator": true
      },
      "node": "14.17.3",
      "env": {
        "NODE_ENV": "development",
        "GRAPHQL_URL": "https://ideback-default-v1.cdebase.io/graphql",
        "GA_ID": "jjj",
        "LOG_LEVEL": "trace",
        "CLIENT_URL": "http://localhost:3000",
        "APP_NAME": "fullstack-pro"
      }
    },
    "preview": {
      "extends": "production",
      "node": "14.17.3",
      "distribution": "internal",
      "env": {
        "NODE_ENV": "development",
        "GRAPHQL_URL": "https://ideback-default-v1.cdebase.io/graphql",
        "GA_ID": "jjj",
        "LOG_LEVEL": "trace",
        "CLIENT_URL": "http://localhost:3000",
        "APP_NAME": "fullstack-pro"
      }
    },
    "production": {   
      "node": "14.17.3",
      "env": {
        "NODE_ENV": "development",
        "GRAPHQL_URL": "https://ideback-default-v1.cdebase.io/graphql",
        "GA_ID": "jjj",
        "LOG_LEVEL": "trace",
        "CLIENT_URL": "http://localhost:3000",
        "APP_NAME": "fullstack-pro"
      }
    }
  },
  "submit": {
    "production": {}
  }
}

```

# portable-devices/mobile/build.config.js

```js
const config = {
    __SERVER__: false,
    __CLIENT__: true,
    __SSR__: false,
    __DEBUGGING__: false,
    __TEST__: false,
    __API_URL__: process.env.API_URL || 'http://localhost:8080/graphql',
    __WEBSITE_URL__: process.env.WEBSITE_URL || 'http://localhost:8080'
}

module.exports = config;

```

# portable-devices/mobile/babel.config.js

```js
module.exports = function (api) {
    api.cache(true);
    return {
        presets: ['babel-preset-expo'],
        plugins: [
            [
                'module:react-native-dotenv',
                {
                    moduleName: '@env',
                    path: process.env.ENV_FILE,
                },
            ],
            'react-native-reanimated/plugin',
        ],
    };
};

```

# portable-devices/mobile/app.json

```json
{
  "expo": {
    "name": "FullStack Pro",
    "slug": "sample-stack",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/images/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "updates": {
      "fallbackToCacheTimeout": 0
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.cdmbase.samplestack"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#FFFFFF"
      },
      "package": "com.cdmbase.samplestack"
    },
    "web": {
      "favicon": "./assets/images/favicon.png"
    }
  }
}

```

# portable-devices/mobile/App.tsx

```tsx
import './src/config/public-config';
import App from './src/App';

export default App;

```

# portable-devices/mobile/.gitignore

```
node_modules/**/*
.expo/*
npm-debug.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*
web-build/

# macOS
.DS_Store

```

# portable-devices/mobile/.exprc

```
{ 
  "extraAdbReversePorts": [8080]
}
```

# portable-devices/desktop/webpack.renderer.additions.js

```js
/* eslint-disable import/no-extraneous-dependencies */
const Dotenv = require('dotenv-webpack');
const path = require('path');
const webpack = require('webpack');
const dotenv = require('dotenv-safe');
const { merge } = require('webpack-merge');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const utils = require('./tools/utils');
const buildConfig = require('./build.config');

const config = {
    target: 'electron-renderer',
    entry: {
        renderer: ['./src/renderer/main.tsx'],
        tray: ['./src/renderer/tray-main.tsx'],
        about: ['./src/renderer/about.tsx'],
    },
    output: {
        filename: '[name].js',
    },
    plugins: [
        new Dotenv({
            path: process.env.ENV_FILE,
        }),
        new webpack.DefinePlugin(
            Object.assign(
                ...Object.entries(buildConfig).map(([k, v]) => ({
                    [k]: typeof v !== 'string' ? v : `'${v.replace(/\\/g, '\\\\')}'`,
                })),
            ),
        ),
        new webpack.DefinePlugin({
            __ENV__: JSON.stringify(dotenv.parsed),
        }),
        new CopyWebpackPlugin({
            patterns: [
                {
                    from: 'assets/html/tray-page.html',
                    to: 'tray-page.html',
                },
                {
                    from: 'assets/html/about-page.html',
                    to: 'about-page.html',
                },
                {
                    from: 'assets/html/main-page.html',
                    to: 'main-page.html',
                },
            ],
        }),
    ],
    resolve: {
        symlinks: true,
    },
    externals: [
        '@apollo/client',
        'react',
        'react-redux',
        'react-fela',
        'react-helmet',
        'react-loadable',
        'react-router',
        'react-router-config',
        'react-router-dom',
        'react-transition-group',
        'connected-react-router',
        'history',
    ],
};

if (process.env.NODE_ENV === 'development') {
    const dotEnvPlugin = {
        plugins: [
            new Dotenv({
                path: process.env.ENV_FILE,
            }),
        ],
    };
    // config.builders.web.webpackConfig = merge(config.builders.web.webpackConfig, dotEnvPlugin);
}

const workspaceRoot = path.resolve(__dirname, '../..');
const dirsToWatch = utils.getWorkspacePackagePaths(workspaceRoot);
// inorder to make watch to work on workspace packages
module.exports = function (givenConfig) {
    const updatedConfig = merge(givenConfig, config, {
        devServer: {
            ...givenConfig.devServer,
            contentBase: dirsToWatch,
            watchContentBase: true,
        },
    });
    return updatedConfig;
};

```

# portable-devices/desktop/webpack.main.additions.js

```js
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable @typescript-eslint/no-unsafe-call */
const TerserPlugin = require('terser-webpack-plugin');
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const webpack = require('webpack');
const buildConfig = require('./build.config');

const config = {
    devtool: process.env.DEBUG_PROD === 'true' ? 'source-map' : 'none',
    target: 'electron-main',
    entry: './src/main/index.ts',
    mode: 'development',
    output: {
        filename: 'main-process.js',
    },
    resolve: {
        extensions: ['.ts', '.tsx', '.mjs', '.graphql', '.graphqls', '.gql', '.native.tsx', '.native.ts'],
    },
    optimization: {
        minimizer: process.env.E2E_BUILD
            ? []
            : [
                  new TerserPlugin({
                      parallel: true,
                      sourceMap: true,
                      cache: true,
                  }),
              ],
    },
    module: {
        rules: [
            {
                test: /\.mjs$/,
                include: /node_modules/,
                type: 'javascript/auto',
            },
        ],
    },
    plugins: [
        new CopyWebpackPlugin({
            patterns: [
                {
                    from: 'assets/preload.js',
                    to: 'preload.js',
                },
                {
                    from: 'tools/esm-wrapper.js',
                    to: 'main.js',
                },
                {
                    from: 'assets/icons',
                    to: 'icons',
                },
            ],
        }),
        // new Dotenv({
        //     path: process.env.ENV_FILE,
        // }),
        new webpack.DefinePlugin(
            Object.assign(
                ...Object.entries(buildConfig).map(([k, v]) => ({
                    [k]: typeof v !== 'string' ? v : `'${v.replace(/\\/g, '\\\\')}'`,
                })),
            ),
        ),
        // new webpack.DefinePlugin({
        //     __ENV__: JSON.stringify(dotenv.parsed),
        // }),
        new BundleAnalyzerPlugin({
            analyzerMode: process.env.OPEN_ANALYZER === 'true' ? 'server' : 'disabled',
            openAnalyzer: process.env.OPEN_ANALYZER === 'true',
        }),

        /**
         * Create global constants which can be configured at compile time.
         *
         * Useful for allowing different behaviour between development builds and
         * release builds.
         *
         * NODE_ENV should be production so that modules do not perform certain
         * development checks.
         */
        new webpack.EnvironmentPlugin({
            NODE_ENV: 'production',
            DEBUG_PROD: false,
            START_MINIMIZED: false,
            E2E_BUILD: false,
        }),
    ],

    /**
     * Disables webpack processing of __dirname and __filename.
     * If you run the bundle in node.js it falls back to these values of node.js.
     * https://github.com/webpack/webpack/issues/2010
     */
    node: {
        __dirname: false,
        __filename: false,
    },
};

module.exports = config;

```

# portable-devices/desktop/tsconfig.json

```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "declaration": false,
    "jsx": "react",
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["../../typings/*.d.ts"],
  "exclude": ["node_modules", "lib", "dist", "webpack.config.js"]
}

```

# portable-devices/desktop/package.json

```json
{
  "name": "sample-stack-desktop-device",
  "version": "0.0.1",
  "private": true,
  "description": "App is based on Electron, React, Redux and NodeJS as a back end",
  "homepage": "https://github.com/cdmbase/fullstack-pro#readme",
  "bugs": {
    "url": "https://github.com/cdmbase/fullstack-pro/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/cdmbase/fullstack-pro.git"
  },
  "license": "MIT",
  "author": {
    "name": "CDMBase LLC",
    "email": "jteidforyou@gmail.com"
  },
  "main": "index.js",
  "scripts": {
    "build": "cross-env NODE_OPTIONS='--max_old_space_size=4096' NODE_ENV=production electron-webpack",
    "build:clean": "rimraf dist",
    "electron": "electron dist/main/main.js",
    "package": "electron-builder",
    "release": "yarn build && electron-builder build --mac",
    "release:linux": "yarn build && electron-builder build --linux",
    "release:mac": "yarn build && electron-builder build --mac",
    "release:win": "electron-builder build --win",
    "start": "cross-env NODE_ENV=production electron dist/main/main.js",
    "start:dev": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env electron dist/main/main.js",
    "start:staging": "cross-env NODE_ENV=staging ENV_FILE=../../config/staging/staging.env electron dist/main/main.js",
    "start:prod": "cross-env NODE_ENV=production ENV_FILE=../../config/development/dev.env electron dist/main/main.js",
    "test": "echo Skipped.",
    "watch": "cross-env NODE_ENV=development ENV_FILE=../../config/development/dev.env electron-webpack dev",
    "watch:staging": "cross-env ENV_FILE=../../config/staging/staging.env electron-webpack dev"
  },
  "resolutions": {
    "webpack-sources": "^1.1.0"
  },
  "dependencies": {
    "@ant-design/compatible": "^1.0.5",
    "@ant-design/icons": "^4.2.2",
    "@cdm-logger/client": "^7.0.8",
    "@cdm-logger/server": "^7.0.7",
    "@cdm-logger/electron": "^7.0.7",
    "@common-stack/client-core": "0.1.11",
    "@common-stack/client-react": "0.1.11",
    "@common-stack/core": "0.1.11",
    "@common-stack/server-core": "0.1.11",
    "@sample-stack/core": "link:../../packages/sample-core",
    "@sample-stack/counter-module-browser": "link:../../packages-modules/counter/browser",
    "@sample-stack/counter-module-electron": "link:../../packages-modules/counter/electron",
    "@sample-stack/platform-browser": "link:../../packages/sample-platform/browser",
    "antd": "~4.15.3",
    "@apollo/client": "~3.3.21",
    "apollo-link-debounce": "^2.1.0",
    "apollo-link-logger": "^1.2.3",
    "apollo-logger": "^0.3.3",
    "aws-sdk": "^2.880.0",
    "browser-bunyan": "^1.6.3",
    "check-internet-connected": "^2.0.5",
    "classnames": "^2.2.6",
    "connected-react-router": "^6.9.1",
    "cors": "^2.8.5",
    "cross-env": "^6.0.3",
    "dotenv": "^8.2.0",
    "electron-json-storage": "^2.0.0",
    "electron-positioner": "^4.1.0",
    "electron-redux": "^1.5.4",
    "electron-updater": "^4.3.9",
    "envalid": "^7.2.2",
    "esm": "^3.2.25",
    "fela": "11.6.0",
    "fela-beautifier": "^11.6.0",
    "fela-dom": "11.6.0",
    "fela-font-renderer": "^5.0.25",
    "fela-perf": "^11.6.0",
    "fela-plugin-fallback-value": "^11.6.0",
    "fela-plugin-logger": "^11.6.0",
    "fela-plugin-lvha": "^5.0.16",
    "fela-plugin-prefixer": "^11.6.0",
    "fela-plugin-unit": "^11.6.0",
    "fela-plugin-validator": "^11.6.0",
    "fela-preset-web": "^11.6.0",
    "graphql": "^14.7.0",
    "graphql-tag": "^2.11.0",
    "history": "^4.10.1",
    "immutability-helper": "^3.0.1",
    "inversify": "^5.0.1",
    "inversify-binding-decorators": "^4.0.0",
    "isomorphic-fetch": "^2.2.1",
    "js-cookie": "^2.2.1",
    "lodash": "^4.17.15",
    "os-name": "^4.0.0",
    "pify": "^2.3.0",
    "ramda": "^0.26.1",
    "react": "17.0.1",
    "react-dom": "17.0.1",
    "react-fela": "11.6.0",
    "react-helmet": "^6.1.0",
    "react-loadable": "^5.5.0",
    "react-redux": "^7.1.3",
    "react-router": "^5.2.1",
    "react-router-config": "^5.1.1",
    "react-router-dom": "^5.3.0",
    "react-transition-group": "^4.3.0",
    "redux": "^4.0.5",
    "redux-logger": "^3.0.6",
    "redux-observable": "^1.2.0",
    "redux-persist": "^6.0.0",
    "redux-thunk": "^2.3.0",
    "reflect-metadata": "^0.1.13",
    "reselect": "^4.0.0",
    "rxjs": "^6.5.3",
    "rxjs-compat": "^6.5.3",
    "rxjs-hooks": "^0.5.2",
    "source-map-support": "^0.5.19",
    "sqlite3": "^5.0.2",
    "subscriptions-transport-ws": "0.9.18",
    "typeorm": "^0.2.32"
  },
  "devDependencies": {
    "@jest-runner/electron": "^3.0.1",
    "cross-env": "^6.0.3",
    "electron": "11.4.10",
    "electron-builder": "^22.11.7",
    "electron-debug": "^3.1.0",
    "electron-devtools-installer": "^3.2.0",
    "electron-is": "^3.0.0",
    "electron-log": "^4.3.5",
    "electron-webpack": "^2.8.2",
    "electron-webpack-ts": "^4.0.1",
    "pm2": "^4.2.1",
    "rimraf": "^3.0.0",
    "workspaces-utils": "^1.2.1"
  },
  "buildAbout": {
    "appName": "Fullstack-Pro",
    "apiApp": "https://time-tracker-api.herokuapp.com/"
  }
}
```

# portable-devices/desktop/jest.config.js

```js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    name: packageJson.name,
    displayName: packageJson.name,
};
```

# portable-devices/desktop/electron-webpack.json

```json
{
  "title": "SampleDesktop",
  "renderer": {
    "dll": [],
    "webpackConfig": "webpack.renderer.additions.js"
  },
  "main": {
    "webpackConfig": "webpack.main.additions.js"
  },
  "whiteListedModules": [
    "antd",
    "react-redux",
    "react-fela",
    "react-helmet",
    "react-loadable",
    "react-router",
    "react-router-config",
    "react-router-dom",
    "react-transition-group"
  ]
}
```

# portable-devices/desktop/electron-builder.json

```json
{
  "appId": "io.github.sample-stack",
  "productName": "Sample-Stack-Electron",
  "copyright": "Copyright © 2021 Sample-Stack",
  "mac": {
    "category": "public.app-category.productivity",
    "darkModeSupport": true,
    "hardenedRuntime": true,
    "gatekeeperAssess": false,
    "entitlements": "entitlements.mac.plist",
    "entitlementsInherit": "entitlements.mac.plist"
  },
  "win": {
    "target": ["nsis"]
  },
  "linux": {
    "executableName": "sample-stack-desktop",
    "category": "Application",
    "desktop": "sample-stack-desktop",
    "target": ["deb", "AppImage"]
  },
  "directories": {
    "output": "release"
  }
}

```

# portable-devices/desktop/build.config.js

```js
const config = {
    __DEV__: process.env.NODE_ENV === 'development',
    __SERVER__: false,
    __CLIENT__: true,
    __SSR__: false,
    __DEBUGGING__: true,
    __TEST__: false,
    __GRAPHQL_URL__: process.env.API_URL || 'http://localhost:8080/graphql',
    __BACKEND_URL__: process.env.WEBSITE_URL || 'http://localhost:8080',
};

module.exports = config;

```

# portable-devices/desktop/.gitignore

```
dll
main.prod.js
release
.erb
```

# packages/sample-store/webpack.config.js

```js
const nodeExternals = require('webpack-node-externals');
const webpack = require('webpack');
const path = require('path');
const glob = require('glob');

function globEntries1(globPath) {
    const files = glob.sync(globPath);
    const entries = {};

    for (let i = 0; i < files.length; i += 1) {
        const entry = files[i];
        const pathObj = path.parse(entry);
        entries[
            path.join(
                pathObj.dir.replace(
                    new RegExp('^./src/database-store', ''),
                    'store',
                ),
                pathObj.name,
            )
        ] = entry;
    }
    return entries;
}

const webpackOpts = {
    mode: 'development',
    entry: {
        index: './src/index.ts',
        ...globEntries1('./src/database-store/**/*.ts'),
    },
    target: 'node',
    output: {
        path: path.join(__dirname, 'lib'),
        filename: '[name].js',
        libraryTarget: 'commonjs2',
        library: '@sample-stack/store',
    },
    resolve: {
        extensions: ['.ts', '.js'],
    },
    plugins: [
        new webpack.LoaderOptionsPlugin({
            options: {
                test: /\.ts$/,
                ts: {
                    compiler: 'typescript',
                    configFile: 'tsconfig.json',
                },
                tslint: {
                    emitErrors: true,
                    failOnHint: true,
                },
            },
        }),
    ],
    devtool: 'source-map',
    module: {
        rules: [
            {
                test: /\.ts$/,
                loaders: 'ts-loader',
            },
        ],
    },
    externals: [
        nodeExternals({ modulesDir: '../../node_modules' }),
        nodeExternals(),
    ],
};

module.exports = webpackOpts;

```

# packages/sample-store/tsconfig.json

```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "rootDirs": ["./src", "../../database"],
    "outDir": "../lib",
    "declarationDir": "lib"
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
```

# packages/sample-store/package.json

```json
{
  "name": "@sample-stack/store",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "webpack",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "cross-env ENV_FILE=../../config/test/test.env jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "modulePaths": [
      "node_modules"
    ],
    "roots": [
      "src"
    ],
    "testEnvironment": "node",
    "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "dependencies": {
    "@sample-stack/core": "link:../sample-core",
    "sequelize": "^5.21.3"
  },
  "peerDependencies": {
    "inversify": "*"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}

```

# packages/sample-store/README.md

```md


## To run tests

    `npm link`
    `npm link @xtermstack/xterm-core`
    `yarn install`
    `tsc`
    `yarn test`

```

# packages/sample-store/.npmignore

```
*
!lib/**

```

# packages/sample-core/webpack.config.js

```js
const nodeExternals = require('webpack-node-externals');
const webpack = require('webpack');
const path = require('path');
const fs = require('fs');

const webpackOpts = {
    mode: 'development',
    entry: './src/index.ts',
    target: 'node',
    output: {
        path: path.join(__dirname, 'lib'),
        filename: 'index.js',
        libraryTarget: 'commonjs2',
    },
    resolve: {
        extensions: ['.ts', '.js'],
    },
    plugins: [
        new webpack.LoaderOptionsPlugin({
            options: {
                test: /\.ts$/,
                ts: {
                    compiler: 'typescript',
                    configFile: 'tsconfig.json',
                },
                tslint: {
                    emitErrors: true,
                    failOnHint: true,
                },
            },
        }),
    ],
    devtool: 'source-map',
    module: {
        rules: [
            {
                test: /\.ts$/,
                loaders: 'ts-loader',
            },
        ],
    },
    externals: [
        nodeExternals({ modulesDir: '../../node_modules' }),
        nodeExternals(),
    ],
};

module.exports = webpackOpts;

```

# packages/sample-core/tsconfig.json

```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "../lib",
    "declarationDir": "lib"
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
```

# packages/sample-core/package.json

```json
{
  "name": "@sample-stack/core",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "webpack",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "cross-env ENV_FILE=../../config/test/test.env jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}

```

# packages/sample-core/jest.config.js

```js
const base = require('../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    name: packageJson.name,
    displayName: packageJson.name,
};

```

# packages/sample-core/README.md

```md


## To run tests

    `npm link`
    `npm link @xtermstack/xterm-core`
    `yarn install`
    `tsc`
    `yarn test`

```

# packages/sample-core/.npmignore

```
*
!lib/**

```

# config/test/.gitignore

```
settings.json
env.sh
*.env
*.sh
*.json
dev.json
development-settings.json
dev*.json
```

# config/staging/.gitignore

```
settings.json
env.sh
*.env
*.sh
*.json
dev.json
development-settings.json
dev*.json
```

# config/production/.gitignore

```
*

```

# config/development/settings.json

```json
{
  "database": {
    "client": "sqlite3",
    "connection": {
      "filename": "dev-db.sqlite3"
    },
    "useNullAsDefault": true
  }
}
```

# config/development/.gitignore

```
env.sh
*.env
*.sh

```

# .github/ISSUE_TEMPLATE/feature_request.md

```md
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: ''
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.

```

# .github/ISSUE_TEMPLATE/custom.md

```md
---
name: Custom issue template
about: Describe this issue template's purpose here.
title: ''
labels: ''
assignees: ''

---



```

# .github/ISSUE_TEMPLATE/bug_report.md

```md
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: ''
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Smartphone (please complete the following information):**
 - Device: [e.g. iPhone6]
 - OS: [e.g. iOS8.1]
 - Browser [e.g. stock browser, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.

```

# tools/cli/helpers/util.js

```js
const shell = require('shelljs');
const fs = require('fs');
const { pascalize, decamelize } = require('humps');
const { startCase } = require('lodash');
const { BASE_PATH } = require('../config');

/**
 * Copies the templates to the destination directory.
 *
 * @param destinationPath - The destination path for a new module.
 * @param templatesPath - The path to the templates for a new module.
 * @param location - The location for a new module [client|server|both].
 */
function copyFiles(destinationPath, templatesPath, location) {
    shell.cp('-R', `${templatesPath}/${location}/*`, destinationPath);
}

/**
 * Renames the templates in the destination directory.
 *
 * @param destinationPath - The destination path of a new module.
 * @param moduleName - The name of a new module.
 */
function renameFiles(destinationPath, moduleName) {
    const Module = pascalize(moduleName);

    // change to destination directory
    shell.cd(destinationPath);

    // rename files
    shell.ls('-Rl', '.').forEach(entry => {
        if (entry.isFile()) {
            shell.mv(entry.name, entry.name.replace('Module', Module));
        }
    });

    // replace module names
    shell.ls('-Rl', '.').forEach(entry => {
        if (entry.isFile()) {
            shell.sed('-i', /\$module\$/g, moduleName, entry.name);
            shell.sed('-i', /\$_module\$/g, decamelize(moduleName), entry.name);
            shell.sed('-i', /\$Module\$/g, Module, entry.name);
            shell.sed('-i', /\$MoDuLe\$/g, startCase(moduleName), entry.name);
            shell.sed('-i', /\$MODULE\$/g, moduleName.toUpperCase(), entry.name);
        }
    });
}

/**
 * Gets the computed path of the module or modules dir path.
 *
 * @param location - The location for a new module [client|server|both].
 * @param moduleName - The name of a new module.
 * @returns {string} - Return the computed path
 */
function computeModulesPath(location, moduleName = '') {
    return `${BASE_PATH}/packages-modules/${moduleName}/${location}`;
}

/**
 * Run prettier on file that was changed.
 *
 * @param pathToFile
 */
function runPrettier(pathToFile) {
    if (fs.existsSync(pathToFile)) {
        shell.exec(`prettier --print-width 120 --single-quote --loglevel error --write ${pathToFile}`);
    }
}

module.exports = {
    renameFiles,
    copyFiles,
    computeModulesPath,
    runPrettier
};
```

# tools/cli/commands/delete-module.js

```js
const shell = require('shelljs');
const fs = require('fs');
const chalk = require('chalk');
const { computeModulesPath, runPrettier } = require('../helpers/util');

/**
 * Removes the module from browser, server or both locations and removes the module from the module list.
 *
 * @param logger - The Logger.
 * @param moduleName - The name of a new module.
 * @param location - The location for a new module [browser|server|both].
 */
function deleteModule(logger, moduleName, location) {
    logger.info(`Deleting ${location} files…`);
    const modulePath = computeModulesPath(location, moduleName);

    if (fs.existsSync(modulePath)) {
        // remove module directory
        shell.rm('-rf', modulePath);

        const modulesPath = computeModulesPath(location);

        // get index file path
        const indexFullFileName = fs.readdirSync(modulesPath).find(name => name.search(/index/) >= 0);
        const indexPath = modulesPath + indexFullFileName;
        let indexContent;

        try {
            indexContent = fs.readFileSync(indexPath);
        } catch (e) {
            logger.error(chalk.red(`Failed to read ${indexPath} file`));
            process.exit();
        }

        // extract application modules
        const appModuleRegExp = /Module\(([^()]+)\)/g;
        const [, appModules] = appModuleRegExp.exec(indexContent) || ['', ''];
        const appModulesWithoutDeleted = appModules.split(',').filter(appModule => appModule.trim() !== moduleName);

        const contentWithoutDeletedModule = indexContent
            .toString()
            // remove module from modules list
            .replace(appModuleRegExp, `Module(${appModulesWithoutDeleted.toString().trim()})`)
            // remove module import
            .replace(RegExp(`import ${moduleName} from './${moduleName}';\n`, 'g'), '');

        fs.writeFileSync(indexPath, contentWithoutDeletedModule);
        runPrettier(indexPath);

        logger.info(chalk.green(`✔ Module for ${location} successfully deleted!`));
    } else {
        logger.info(chalk.red(`✘ Module ${location} location for ${modulePath} not found!`));
    }
}

module.exports = deleteModule;
```

# tools/cli/commands/add-module.js

```js
const shell = require('shelljs');
const fs = require('fs');
const chalk = require('chalk');
const { copyFiles, renameFiles, computeModulesPath, runPrettier } = require('../helpers/util');

/**
 * Adds application module to browser or server code and adds it to the module list.
 *
 * @param logger - The Logger.
 * @param templatesPath - The path to the templates for a new module.
 * @param moduleName - The name of a new module.
 * @param location - The location for a new module [browser|server|both].
 * @param finished - The flag about the end of the generating process.
 */
function addModule(logger, templatesPath, moduleName, location, finished = true) {
    logger.info(`Copying ${location} files…`);

    // create new module directory
    const destinationPath = computeModulesPath(location, moduleName);
    const newModule = shell.mkdir(destinationPath);

    // continue only if directory does not jet exist
    if (newModule.code !== 0) {
        console.log(newModule)
        logger.error(`creating destination '${destinationPath} failed.`)
        logger.error(chalk.red(`The ${moduleName} directory is already exists.`));
        process.exit();
    }
    //copy and rename templates in destination directory
    copyFiles(destinationPath, templatesPath, location);
    renameFiles(destinationPath, moduleName);

    logger.info(chalk.green(`✔ The ${location} files have been copied!`));

    // get index file path
    const modulesPath = computeModulesPath(location);
    const indexFullFileName = fs.readdirSync(modulesPath).find(name => name.search(/index/) >= 0);
    const indexPath = modulesPath + indexFullFileName;
    let indexContent;

    try {
        // prepend import module
        indexContent = `import ${moduleName} from './${moduleName}';\n` + fs.readFileSync(indexPath);
    } catch (e) {
        logger.error(chalk.red(`Failed to read ${indexPath} file`));
        process.exit();
    }

    // extract application modules
    const appModuleRegExp = /Module\(([^()]+)\)/g;
    const [, appModules] = appModuleRegExp.exec(indexContent) || ['', ''];

    // add module to app module list
    shell
        .ShellString(indexContent.replace(RegExp(appModuleRegExp, 'g'), `Module(${moduleName}, ${appModules})`))
        .to(indexPath);
    runPrettier(indexPath);

    if (finished) {
        logger.info(chalk.green(`✔ Module for ${location} successfully created!`));
    }
}

module.exports = addModule;
```

# servers/moleculer-server/src/stack-server.ts

```ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable import/namespace */
import { logger as serverLogger } from '@cdm-logger/server';
import { Feature } from '@common-stack/server-core';
import { ContainerModule, interfaces, Container } from 'inversify';
import { ServiceBroker } from 'moleculer';
import { CommonType } from '@common-stack/core';
import { CdmLogger } from '@cdm-logger/core';
import * as brokerConfig from './config/moleculer.config';
import modules, { settings } from './modules';
import { config } from './config';
import { ConnectionBroker } from './connectors/connection-broker';

type ILogger = CdmLogger.ILogger;

const infraModule = ({ broker, pubsub, mongoClient, logger }) =>
    new ContainerModule((bind: interfaces.Bind) => {
        bind('Logger').toConstantValue(logger);
        bind(CommonType.LOGGER).toConstantValue(logger);
        bind('Environment').toConstantValue(config.NODE_ENV || 'development');
        bind(CommonType.ENVIRONMENT).toConstantValue(config.NODE_ENV || 'development');
        bind('PubSub').toConstantValue(pubsub);
        bind(CommonType.PUBSUB).toConstantValue(pubsub);
        bind(CommonType.MOLECULER_BROKER).toConstantValue(broker);
        bind('MoleculerBroker').toConstantValue(broker);
        bind('MongoDBConnection').toConstantValue(mongoClient);
    });

/**
 *  Controls the lifecycle of the Application Server
 *
 * @export
 * @class StackServer
 */
export class StackServer {
    private logger: ILogger;

    private connectionBroker: ConnectionBroker;

    private microserviceBroker: ServiceBroker;

    private serviceContainer: Container;

    private microserviceContainer: Container;

    constructor() {
        this.logger = serverLogger.child({ className: 'StackServer' });
    }

    public async initialize() {
        this.logger.info('StackServer initializing');

        this.connectionBroker = new ConnectionBroker(brokerConfig.transporter, this.logger);
        const redisClient = this.connectionBroker.redisDataloaderClient;

        const mongoClient = await this.connectionBroker.mongoConnection;

        this.microserviceBroker = new ServiceBroker({
            ...brokerConfig,
            started: async () => {
                await modules.microservicePreStart(this.microserviceContainer);
                await modules.microservicePostStart(this.microserviceContainer);
            },
        });

        const pubsub = await this.connectionBroker.graphqlPubsub;
        const InfraStructureFeature = new Feature({
            createHemeraContainerFunc: [
                () =>
                    infraModule({
                        broker: this.microserviceBroker,
                        pubsub,
                        mongoClient,
                        logger: serverLogger,
                    }),
            ],
        });
        const allModules = new Feature(InfraStructureFeature, modules);
        this.microserviceContainer = await allModules.createHemeraContainers({
            ...settings,
            mongoConnection: mongoClient,
        });
        const serviceBroker = {
            microserviceContainer: this.microserviceContainer,
            logger: this.logger,
        };
        // set the service container
        this.microserviceContainer = serviceBroker.microserviceContainer;
        allModules.loadClientMoleculerService({
            broker: this.microserviceBroker,
            container: this.microserviceContainer,
            settings,
        });
    }

    public async start() {
        await this.microserviceBroker.start();
    }

    public async cleanup() {
        if (this.connectionBroker) {
            await this.connectionBroker.stop();
        }
        if (this.microserviceBroker) {
            await this.microserviceBroker.stop();
        }
    }
}

```

# servers/moleculer-server/src/index.ts

```ts
///<reference types="webpack-env" />

import 'reflect-metadata';
import { StackServer } from './stack-server';
import { logger } from '@cdm-logger/server';


declare var module: __WebpackModuleApi.Module;


const service = new StackServer();
async function start() {
    await service.initialize();
    await service.start();
}

if (module.hot) {
    module.hot.status(event => {
        if (event === 'abort' || event === 'fail') {
            logger.error('HMR error status: ' + event);
            // Signal webpack.run.js to do full-reload of the back-end
            service.cleanup();
        }
        // adddintionally when event is idle due to external modules
        if (event === 'idle') {
            service.cleanup();
        }
    });
    module.hot.accept();
}

start();

```

# servers/frontend-server/tools/webpackAppConfig.js

```js
const dependencyPlatforms = {
    '@cdm-logger/server': 'server',
    '@sample-stack/core': 'noddl',
    '@sample-stack/platform-browser': 'noddl',
    '@sample-stack/counter': 'noddl',
    bunyan: 'server',
    'export-dir': 'server',
    express: 'server',
    'body-parser': 'server',
    'apollo-server-express': 'server',
    'graphql-subscriptions': 'server',
    'graphql-tag': ['server', 'web'],
    'immutability-helper': ['ios', 'android', 'web'],
    'isomorphic-fetch': 'server',
    knex: 'server',
    mysql2: 'server',
    persistgraphql: ['server', 'web'],
    'graphql-nats-subscriptions': 'server',
    'graphql-server-core': 'server',
    'graphql-tools': 'server',
    helmet: 'server',
    'hemera-joi': 'server',
    'hemera-plugin': 'server',
    'hemera-safe-promises': 'server',
    'hemera-sql-store': 'server',
    'hemera-zipkin': 'server',
    inversify: 'server',
    morgan: 'server',
    nats: 'server',
    'nats-hemera': 'server',
    nconf: 'server',
    'node-pre-gyp': 'server',
    'prop-types': 'web',
    ramda: ['web', 'server'],
    'reflect-metadata': 'server',
    sequelize: 'server',
    'react-native': ['ios', 'android'],
    'react-navigation': ['ios', 'android'],
    'serialize-javascript': 'server',
    'source-map-support': 'server',
    sqlite3: 'server',
    'styled-components': ['server', 'web'],
    'subscriptions-transport-ws': ['ios', 'android', 'web'],
    ws: ['server'],
};

module.exports = { dependencyPlatforms };

```

# servers/frontend-server/src/postcss.config.js

```js
module.exports = {
    plugins: [
    ],
};

```

# servers/frontend-server/src/index.tsx

```tsx
import 'reflect-metadata';
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-explicit-any */
import 'antd/dist/antd.css';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
// load environment config
import './config/public-config';
import Main from './app/Main';

// Virtual (module as any), generated in-memory by zenjs, contains count of backend rebuilds
// tslint:disable-next-line
import 'backend_reload';

const rootEl = document.getElementById('content');
let frontendReloadCount = 0;

const renderApp = ({ key }: { key: number }) => ReactDOM.render(<Main key={key} />, rootEl);
renderApp({ key: frontendReloadCount });
if (__DEV__) {
    if ((module as any).hot) {
        (module as any).hot.accept();
        (module as any).hot.accept('backend_reload', () => {
            // log.debug('Reloading front-end');
            // when the backend restarts wait for 5 seconds
            setTimeout(() => window.location.reload(), 5000);
            // window.location.reload();
        });
        (module as any).hot.accept((err) => {
            if (err) {
                console.error('Cannot apply HMR update.', err);
            }
        });
        //  React-hot-loader v4 doesn't require following code any more.
        //  but if RHL not working we can uncomment below code to make normal HMR to refresh the page
        (module as any).hot.accept('./app/Main', () => {
            try {
                console.log('Updating front-end');
                frontendReloadCount = (frontendReloadCount || 0) + 1;

                renderApp({ key: frontendReloadCount });
            } catch (err) {
                // log(err.stack);
            }
        });
    }
}

```

# servers/moleculer-server/.vscode/launch.json

```json
{
	// Use IntelliSense to learn about possible Node.js debug attributes.
	// Hover to view descriptions of existing attributes.
	// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
	"version": "0.2.0",
	"configurations": [
		
		{
			"type": "node",
			"request": "launch",
			"name": "Debug",
			"program": "${workspaceRoot}/node_modules/moleculer/bin/moleculer-runner.js",
			"sourceMaps": true,
			"runtimeArgs": [
				"--nolazy",
				"-r",
				"ts-node/register"
			],
			"cwd": "${workspaceRoot}",
			"args": [
				"--mask **/*.service.ts",
				"--config",
				"moleculer.config.ts",
				"services"
			]
		},
		{
			"type": "node",
			"request": "launch",
			"name": "Jest",
			"program": "${workspaceRoot}/node_modules/jest-cli/bin/jest.js",
			"args": [
				"--runInBand"
			],
			"cwd": "${workspaceRoot}",
			"runtimeArgs": [
				"--inspect-brk",
				"--nolazy"
			]
		}
	]
}

```

# servers/backend-server/src/stack-server.ts

```ts
/* eslint-disable import/namespace */
/* eslint-disable import/no-unresolved */
/* eslint-disable import/no-extraneous-dependencies */
// version 08/25/2021
import * as http from 'http';
import * as express from 'express';
import { logger as serverLogger } from '@cdm-logger/server';
import { Feature } from '@common-stack/server-core';
import { ContainerModule, interfaces, Container } from 'inversify';
import { ServiceBroker, ServiceSettingSchema } from 'moleculer';
import { CommonType } from '@common-stack/core';
import * as _ from 'lodash';
import { CdmLogger } from '@cdm-logger/core';
import { expressApp } from './express-app';
import { GraphqlServer } from './server-setup/graphql-server';
import { config } from './config';
import { ConnectionBroker } from './connectors/connection-broker';
import * as brokerConfig from './config/moleculer.config';
import modules, { settings } from './modules';
import { GatewaySchemaBuilder } from './api/schema-builder';
import { WebsocketMultiPathServer } from './server-setup/websocket-multipath-update';
import { IModuleService } from './interfaces';
import { migrate } from './utils/migrations';
import { InterNamespaceMiddleware } from './middleware/moleculer-inter-namespace';
// This is temp and will be replaced one we add support for rules in Feature

type ILogger = CdmLogger.ILogger;

function startListening(port) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const server = this;
    return new Promise((resolve) => {
        server.listen(port, resolve);
    });
}

const infraModule = ({ broker, pubsub, mongoClient, logger }) =>
    new ContainerModule((bind: interfaces.Bind) => {
        bind('Logger').toConstantValue(logger);
        bind(CommonType.LOGGER).toConstantValue(logger);
        bind('Environment').toConstantValue(config.NODE_ENV || 'development');
        bind(CommonType.ENVIRONMENT).toConstantValue(config.NODE_ENV || 'development');
        bind('PubSub').toConstantValue(pubsub);
        bind(CommonType.PUBSUB).toConstantValue(pubsub);
        bind(CommonType.MOLECULER_BROKER).toConstantValue(broker);
        bind('MoleculerBroker').toConstantValue(broker);
        bind('MongoDBConnection').toConstantValue(mongoClient);
    });

/**
 *  Controls the lifecycle of the Application Server
 *
 * @export
 * @class StackServer
 */
export class StackServer {
    public httpServer: http.Server & { startListening?: (port) => void };

    private app: express.Express;

    private logger: ILogger;

    private connectionBroker: ConnectionBroker;

    private mainserviceBroker: ServiceBroker;

    private microserviceBroker: ServiceBroker;

    private multiPathWebsocket: WebsocketMultiPathServer;

    private serviceContainer: Container;

    private microserviceContainer: Container;

    constructor() {
        this.logger = serverLogger.child({ className: 'StackServer' });
    }

    public async initialize() {
        this.logger.info('StackServer initializing');

        // eslint-disable-next-line import/namespace
        this.connectionBroker = new ConnectionBroker(brokerConfig.transporter, this.logger);
        const redisClient = this.connectionBroker.redisDataloaderClient;

        const mongoClient = await this.connectionBroker.mongoConnection;

        // Moleculer Broker Setup
        this.mainserviceBroker = new ServiceBroker({
            ...brokerConfig,
            middlewares: [
                InterNamespaceMiddleware([
                    {
                        namespace: 'api-admin',
                        transporter: brokerConfig.transporter,
                    },
                ]),
            ],
            started: async () => {
                await modules.preStart(this.serviceContainer);
                if (config.NODE_ENV === 'development') {
                    // await modules.microservicePreStart(this.micorserviceContainer);
                }

                try {
                    await migrate(mongoClient, this.serviceContainer);
                } catch (e) {
                    this.logger.error('Error while running migrations', e);
                    this.logger.error(e.stack);
                }

                try {
                    await modules.postStart(this.serviceContainer);
                } catch (e) {
                    this.logger.error('Error while running Post Start', e);
                    this.logger.error(e.stack);
                }
                // start DB migration

                if (config.NODE_ENV === 'development') {
                    // await modules.microservicePostStart(this.micorserviceContainer);
                }
            },

            // created,
            async created() {
                return Promise.resolve();
            },
        });

        if (config.NODE_ENV === 'development') {
            this.microserviceBroker = new ServiceBroker({
                ...brokerConfig,
                nodeID: 'node-broker-2',
                started: async () => {
                    await modules.microservicePreStart(this.microserviceContainer);
                    await modules.microservicePostStart(this.microserviceContainer);
                },
                // created,
                created: async () => Promise.resolve(),
            });
        }
        const pubsub = await this.connectionBroker.graphqlPubsub;
        const InfraStructureFeature = new Feature({
            createContainerFunc: [
                () =>
                    infraModule({
                        broker: this.mainserviceBroker,
                        pubsub,
                        mongoClient,
                        logger: serverLogger,
                    }),
            ],
            createServiceFunc: (container) => ({ moleculerBroker: container.get(CommonType.MOLECULER_BROKER) }),
            createHemeraContainerFunc: [
                () =>
                    infraModule({
                        broker: this.mainserviceBroker,
                        pubsub,
                        mongoClient,
                        logger: serverLogger,
                    }),
            ],
        });

        const allModules = new Feature(InfraStructureFeature, modules as Feature);
        const executableSchema = await new GatewaySchemaBuilder({
            schema: allModules.schemas,
            resolvers: allModules.createResolvers({
                pubsub,
                logger: serverLogger,
                subscriptionID: `${settings.subTopic}`,
            }),
            directives: allModules.createDirectives({ logger: this.logger }),
            logger: serverLogger,
        }).build();

        // set the service container
        this.serviceContainer = await allModules.createContainers({ ...settings, mongoConnection: mongoClient });
        const createServiceContext = allModules.createServiceContext({ ...settings, mongoConnection: mongoClient });
        const serviceBroker: IModuleService = {
            serviceContainer: this.serviceContainer,
            serviceContext: createServiceContext,
            dataSource: allModules.createDataSource(),
            defaultPreferences: allModules.createDefaultPreferences(),
            createContext: async (req, res) => allModules.createContext(req, res),
            logger: serverLogger,
            schema: executableSchema,
        };
        allModules.loadMainMoleculerService({
            broker: this.mainserviceBroker,
            container: this.serviceContainer,
            settings,
        });
        if (config.NODE_ENV === 'development') {
            this.microserviceContainer = await allModules.createHemeraContainers({
                ...settings,
                mongoConnection: mongoClient,
            });
            allModules.loadClientMoleculerService({
                broker: this.microserviceBroker,
                container: this.microserviceContainer,
                settings,
            });
        }

        // initialize Servers
        this.httpServer = http.createServer();
        this.app = await expressApp(serviceBroker, null, this.httpServer);

        this.httpServer.startListening = startListening.bind(this.httpServer);
        this.httpServer.on('request', this.app);
        this.httpServer.on('close', () => {
            this.httpServer = undefined;
        });

        const customWebsocket = allModules.getWebsocketConfig();
        const customWebsocketEnable = !_.isEmpty(customWebsocket);

        if (customWebsocketEnable) {
            this.multiPathWebsocket = new WebsocketMultiPathServer(serviceBroker, redisClient, customWebsocket);
            this.httpServer = this.multiPathWebsocket.httpServerUpgrade(this.httpServer);
        }
        const graphqlServer = new GraphqlServer(
            this.app,
            this.httpServer,
            redisClient,
            serviceBroker,
            !customWebsocketEnable,
        );

        await graphqlServer.initialize();
    }

    public async start() {
        if (config.NODE_ENV === 'development') {
            await Promise.all([this.mainserviceBroker.start(), this.microserviceBroker.start()]);
        } else {
            await this.mainserviceBroker.start();
        }
    }

    public async cleanup() {
        if (this.multiPathWebsocket) {
            this.multiPathWebsocket.close();
        }
        if (this.httpServer) {
            await this.httpServer.close();
        }
        if (this.connectionBroker) {
            await this.connectionBroker.stop();
        }
        if (this.mainserviceBroker) {
            await this.mainserviceBroker.stop();
        }
        if (this.microserviceBroker) {
            await this.microserviceBroker.stop();
        }
    }
}

```

# servers/backend-server/src/service.ts

```ts
import { StackServer } from './stack-server';
import { logger } from '@cdm-logger/server';
import * as url from 'url';
import { config } from './config';

const { port: serverPort, pathname, hostname } = url.parse(config.BACKEND_URL);

export class Service {

    private app: StackServer;

    public async initialize() {

        this.app = new StackServer();
        await this.app.initialize();
    }

    public async start() {
        await this.app.start();
        await this.app.httpServer.startListening(serverPort);
        logger.info(`API is now running on port ${serverPort}`);
    }

    public async gracefulShutdown(signal) {
        try {
            logger.info(`${signal} received. Closing connections, stopping server`);
            await this.app.cleanup();
            logger.info('Shutting down');
        } catch (err) {
            logger.error('Error during graceful shutdown');
            logger.error(err);
        } finally {
            process.exit(0);
        }
    }
}

```

# servers/backend-server/src/main.spec.ts

```ts
// import {GRAPHQL_ROUTE, GRAPHIQL_ROUTE, main} from './main';
// import {get as httpGet, Server} from 'http';
// import 'jest';

// const ERRNO_KEY = 'errno';
// const PORT: number = 8080;

// function getFromServer(uri) {
//   return new Promise((resolve, reject) => {
//     httpGet(`http://localhost:${PORT}${uri}`, (res) => {
//       resolve(res);
//     }).on('error', (err: Error) => {
//       reject(err);
//     });
//   });
// }

// describe('main', () => {
//   it('should be able to Initialize a server (production)', () => {
//     return main({
//       enableCors: false,
//       enableGraphiql: false,
//       env: 'production',
//       port: PORT,
//     })
//     .then(([server]) => {
//       return (<Server>server).close();
//     });
//   });

//   it('should be able to Initialize a server (development)', () => {
//     return main({
//       enableCors: true,
//       enableGraphiql: true,
//       env: 'dev',
//       port: PORT,
//     })
//     .then(([server]) => {
//       return (<Server>server).close();
//     });
//   });

//   it('should have a working GET graphql (developemnt)', () => {
//     return main({
//       enableCors: true,
//       enableGraphiql: true,
//       env: 'dev',
//       port: PORT,
//     })
//     .then(([server]) => {
//       return getFromServer(GRAPHQL_ROUTE).then((res: any) => {
//         (<Server>server).close();
//         // GET without query returns 400
//         expect(res.statusCode).toBe(400);
//       });
//     });
//   });

//   it('should have a working GET graphql (production)', () => {
//     return main({
//       enableCors: false,
//       enableGraphiql: false,
//       env: 'production',
//       port: PORT,
//     })
//     .then(([server]) => {
//       return getFromServer(GRAPHQL_ROUTE).then((res: any) => {
//         (<Server>server).close();
//         // GET without query returns 400
//         expect(res.statusCode).toBe(400);
//       });
//     });
//   });

//   it('should have a working graphiql (developemnt)', () => {
//     return main({
//       enableCors: true,
//       enableGraphiql: true,
//       env: 'dev',
//       port: PORT,
//     })
//     .then(([server]) => {
//       return getFromServer(GRAPHIQL_ROUTE).then((res: any) => {
//         (<Server>server).close();
//         expect(res.statusCode).toBe(200);
//       });
//     });
//   });

//   it('should have block graphiql (production)', () => {
//     return main({
//       enableCors: false,
//       enableGraphiql: false,
//       env: 'production',
//       port: PORT,
//     })
//     .then(([server]) => {
//       return getFromServer(GRAPHIQL_ROUTE).then((res: any) => {
//         (<Server>server).close();
//         expect(res.statusCode).toBe(404);
//       });
//     });
//   });

//   it('should reject twice on same port', () => {
//     return main({
//       enableCors: false,
//       enableGraphiql: false,
//       env: 'production',
//       port: PORT,
//     })
//     .then(([server]) => {
//       return main({
//         enableCors: false,
//         enableGraphiql: false,
//         env: 'production',
//         port: PORT,
//       })
//       .then(([secondServer]) => {
//         (<Server>server).close();
//         (<Server>secondServer).close();
//         throw new Error('Was able to listen twice!');
//       }, (err: Error) => {
//         (<Server>server).close();
//         expect(err[ERRNO_KEY]).toBe('EADDRINUSE');
//       });
//     });
//   });
// });

```

# servers/backend-server/src/index.ts

```ts
/* eslint-disable import/first */
/// <reference types="webpack-env" />
// eslint-disable-next-line global-require, import/first, no-unused-expressions, @typescript-eslint/no-var-requires
process.env.ENV_FILE !== null && require('dotenv').config({ path: process.env.ENV_FILE });

import 'reflect-metadata';
import { logger } from '@cdm-logger/server';
import { Service } from './service';

declare let module: __WebpackModuleApi.Module;

process.on('uncaughtException', (ex) => {
    logger.error(ex);
    process.exit(1);
});

process.on('unhandledRejection', (reason) => {
    logger.error(reason);
});
const service = new Service();

async function start() {
    await service.initialize();
    await service.start();
}
if (module.hot) {
    module.hot.status((event) => {
        if (event === 'abort' || event === 'fail') {
            logger.error(`HMR error status: ${event}`);
            // Signal webpack.run.js to do full-reload of the back-end
            service.gracefulShutdown(event);
        }
        // adddintionally when event is idle due to external modules
        if (event === 'idle') {
            service.gracefulShutdown(event);
        }
    });
    module.hot.accept();
}

start();

```

# servers/backend-server/src/express-app.ts

```ts
/* eslint-disable @typescript-eslint/no-var-requires */
import * as express from 'express';

import modules from './modules';
import { errorMiddleware } from './middleware/error';
import { contextServicesMiddleware } from './middleware/services';
import { IModuleService } from './interfaces';

const cookiesMiddleware = require('universal-cookie-express');

export function expressApp(options: IModuleService, middlewares, http?) {
    const app: express.Express = express();

    app.use(contextServicesMiddleware(options.createContext, options.serviceContext));

    for (const applyBeforeware of modules.beforewares) {
        applyBeforeware(app);
    }

    app.use(cookiesMiddleware());

    // Don't rate limit heroku
    app.enable('trust proxy');

    if (middlewares !== null) {
        app.use(middlewares);
    }

    // app.use(corsMiddleware);
    app.use((req, res, next) => {
        res.header('Access-Control-Allow-Credentials', JSON.stringify(true));
        res.header('Access-Control-Allow-Origin', req.headers.origin as string);
        res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');
        res.header('Access-Control-Allow-Headers', 'X-Requested-With, X-HTTP-Method-Override, Content-Type, Accept');
        next();
    });

    const corsOptions = {
        origin: true,
        credentials: true,
    };

    for (const applyMiddleware of modules.middlewares) {
        applyMiddleware(app);
    }

    if (__DEV__) {
        app.use(errorMiddleware);
    }

    return app;
}

```

# portable-devices/mobile/__generated__/AppEntry.js

```js
// @generated by expo-yarn-workspaces

import 'expo/build/Expo.fx';
import { activateKeepAwake } from 'expo-keep-awake';
import registerRootComponent from 'expo/build/launch/registerRootComponent';

import App from '../App';

if (__DEV__) {
  activateKeepAwake();
}

registerRootComponent(App);

```

# portable-devices/mobile/.expo-shared/assets.json

```json
{
  "e997a5256149a4b76e6bfd6cbf519c5e5a0f1d278a3d8fa1253022b03c90473b": true,
  "af683c96e0ffd2cf81287651c9433fa44debc1220ca7cb431fe482747f34a505": true,
  "12bb71342c6255bbf50437ec8f4441c083f47cdb74bd89160c15e4f43e52a1cb": true,
  "40b842e832070c58deac6aa9e08fa459302ee3f9da492c7e77d93d2fbf4a56fd": true
}

```

# portable-devices/desktop/tools/utils.js

```js
const path = require('path');
const getSymlinkedNodeModulesForDirectory = require('../../../tools/get-symlinked-modules');

function getWorkspacePackagePaths(root) {
    const symlinkedModules = getSymlinkedNodeModulesForDirectory(root);
    const symlinkedModulePaths = Object.values(symlinkedModules);
    return symlinkedModulePaths.map((f) => path.resolve(f, 'lib'));
}
module.exports = {
    getWorkspacePackagePaths,
};

```

# portable-devices/desktop/tools/esm-wrapper.js

```js
/* eslint-disable import/no-unresolved */
/* eslint-disable no-global-assign */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable @typescript-eslint/no-unsafe-call */
require = require('esm')(module, { cjs: true });
module.exports = require('./main-process.js');

```

# portable-devices/desktop/assets/preload.js

```js
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
const _require = require('esm')(module);

process.once('loaded', () => {
    global.require = _require;
});

```

# portable-devices/desktop/assets/icon.svg

This is a file of the type: SVG Image

# portable-devices/desktop/assets/icon.png

This is a binary file of the type: Image

# portable-devices/desktop/assets/icon.ico

This is a binary file of the type: Binary

# portable-devices/desktop/assets/icon.icns

This is a binary file of the type: Binary

# portable-devices/desktop/assets/entitlements.mac.plist

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
    <true/>
    <key>com.apple.security.cs.allow-jit</key>
    <true/>
  </dict>
</plist>

```

# packages-modules/counter/server/webpack.config.js

```js
var nodeExternals = require('webpack-node-externals');
var webpack = require('webpack');
var path = require('path');

var webpackOpts = {
  mode: 'development',
  entry: {
    index: './src/index.ts',
  },
  target: 'node',
  output: {
    path: path.join(__dirname, 'lib'),
    filename: '[name].js',
    libraryTarget: "commonjs2",
  },
  resolve: {
    extensions: ['.ts', '.tsx', '.graphql', '.graphqls', '.gql']
  },
  plugins: [
    new webpack.LoaderOptionsPlugin({
      options: {
        test: /\.tsx?$/,
        ts: {
          compiler: 'typescript',
          configFile: 'tsconfig.json'
        },
        tslint: {
          emitErrors: true,
          failOnHint: true
        }
      }
    })
  ],
  devtool: 'source-map',
  module: {
    rules: [{
      test: /\.tsx?$/,
      loaders: 'ts-loader'
    },
    {
      test: /\.(gql)$/,
      exclude: /node_modules/,
      use: ['graphql-tag/loader']
    },
    {
      test: /\.graphql?/,
      exclude: /node_modules/,
      use: 'raw-loader',
    }
    ]
  },
  externals: [
    nodeExternals({ modulesDir: "../../../node_modules" }),
    nodeExternals()
  ]
};

module.exports = webpackOpts;

```

# packages-modules/counter/server/tsconfig.json

```json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "../lib",
    "declarationDir": "lib"
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
```

# packages-modules/counter/server/package.json

```json
{
  "name": "@sample-stack/counter-module-server",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "webpack",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "cross-env ENV_FILE=../../config/test/test.env jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "modulePaths": [
      "node_modules"
    ],
    "roots": [
      "src"
    ],
    "testEnvironment": "node",
    "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "peerDependencies": {
    "@cdm-logger/server": "*",
    "@common-stack/core": "*",
    "@common-stack/server-core": "*",
    "apollo-server-caching": "*",
    "dataloader": "*",
    "inversify": "*",
    "moleculer": "*"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}

```

# packages-modules/counter/server/jest.config.js

```js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    name: packageJson.name,
    displayName: packageJson.name,
};
```

# packages-modules/counter/mobile/tsconfig.json

```json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "target": "esnext",
    "jsx": "react-native",
    "lib": ["es2017"],
    "esModuleInterop": true,
    "sourceMap": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "rootDir": "src",
    "outDir": "lib",
    "declaration": true,
    "declarationDir": "lib",
    "types": [
      "@types/node",
      "@types/jest",
      "../../../typings",
    ],
    "skipLibCheck": true
  },
  "include": ["src"],
  "exclude": [
    "node_modules",
    "lib",
    "jest.config.js",
    "webpack.config.js",
    "rollup.config.js"
  ]
}

```

# packages-modules/counter/mobile/package.json

```json
{
  "name": "@sample-stack/counter-module-mobile",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "tsc",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "cross-env ENV_FILE=../../config/test/test.env jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "modulePaths": [
      "node_modules"
    ],
    "roots": [
      "src"
    ],
    "testEnvironment": "node",
    "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "dependencies": {
    "@sample-stack/platform-browser": "link:../../../packages/sample-platform/browser",
    "antd": "~4.15.3"
  },
  "peerDependencies": {
    "@common-stack/client-react": "*",
    "native-base": "*",
    "react": "*",
    "react-native": "*",
    "react-redux": "*",
    "react-router": "*",
    "react-router-dom": "*",
    "redux": "*"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}
```

# packages-modules/counter/mobile/jest.config.js

```js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    testEnvironment: 'jsdom', // This is overriden, from the base testEnvironment
    name: packageJson.name,
    displayName: packageJson.name,
};

```

# portable-devices/mobile/src/App.tsx

```tsx
import { StatusBar } from 'expo-status-bar';
import React from 'react';
import { NativeRouter, Route } from 'react-router-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { StyleSheet } from 'react-native';
import { createRenderer } from 'fela-native';
import { ApolloProvider } from '@apollo/client';
import { Provider } from 'react-redux';
import { MainRoute } from './modules/modules';
import { persistStore, persistReducer } from 'redux-persist';
import { PersistGate } from 'redux-persist/integration/react';
// import { RendererProvider } from 'react-fela';
import { ConnectedRouter } from 'connected-react-router';
import {
  createReduxStore,
  history,
} from './config/redux-config';
import { NativeBaseProvider } from 'native-base';
import { createClientContainer } from './config/client.service';

const { apolloClient: client, container } = createClientContainer();

const store = createReduxStore();
const renderer = createRenderer();

export default function App() {

  let persistor = persistStore(store as any);
  return (
    <NativeBaseProvider>
      <SafeAreaProvider>
        <Provider store={store}>
          <ApolloProvider client={client}>
            <PersistGate persistor={persistor}>
              <NativeRouter>
                <ConnectedRouter history={history}>
                  <MainRoute />
                </ConnectedRouter>
              </NativeRouter>
            </PersistGate>
          </ApolloProvider>
        </Provider>
      </SafeAreaProvider>
    </NativeBaseProvider>
  );
}

const styles = StyleSheet.create({
        container: {
        marginTop: 25,
    padding: 10,
  },
  header: {
        fontSize: 20,
  },
  nav: {
        flexDirection: 'row',
    justifyContent: 'space-around',
  },
  navItem: {
        flex: 1,
    alignItems: 'center',
    padding: 10,
  },
  subNavItem: {
        padding: 5,
  },
  topic: {
        textAlign: 'center',
    fontSize: 15,
  },
});

```

# packages-modules/counter/electron/webpack.config.js

```js
const nodeExternals = require('webpack-node-externals');
const webpack = require('webpack');
const path = require('path');

const webpackOpts = {
    mode: 'development',
    entry: {
        index: './src/index.ts',
    },
    target: 'node',
    output: {
        path: path.join(__dirname, 'lib'),
        filename: '[name].js',
        libraryTarget: 'commonjs2',
    },
    resolve: {
        extensions: ['.ts', '.tsx', '.js', '.graphql', '.graphqls', '.gql', '.native.tsx', '.native.ts'],
    },
    plugins: [
        new webpack.LoaderOptionsPlugin({
            options: {
                test: /\.tsx?$/,
                ts: {
                    compiler: 'typescript',
                    configFile: 'tsconfig.json',
                },
                tslint: {
                    emitErrors: true,
                    failOnHint: true,
                },
            },
        }),
    ],
    devtool: 'source-map',
    module: {
        rules: [
            {
                test: /\.tsx?$/,
                loaders: 'ts-loader',
                options: {
                    compilerOptions: {
                        outDir: path.join(),
                    },
                },
            },
            {
                test: /\.mjs$/,
                include: /node_modules/,
                type: 'javascript/auto',
            },
            {
                test: /\.(gql)$/,
                exclude: /node_modules/,
                use: ['graphql-tag/loader'],
            },
            {
                test: /\.graphql?/,
                exclude: /node_modules/,
                use: 'raw-loader',
            },
        ],
    },
    externals: [
        nodeExternals({
            allowlist: [/^@sample-stack/],
            modulesDir: '../../../node_modules',
        }),
        nodeExternals({
            allowlist: [/^@sample-stack/],
        }),
    ],
};

module.exports = webpackOpts;

```

# packages-modules/counter/electron/tsconfig.json

```json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "rootDir": "./src",
    "outDir": "lib",
    "declarationDir": "lib",
    "declaration": true,
    "declarationMap": true
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js",
    "rollup.config.js"
  ],
  "include": [
    "src",
    "./typings/*.d.ts"
  ]
}
```

# packages-modules/counter/electron/rollup.config.js

```js
import graphql from '@rollup/plugin-graphql';
import image from '@rollup/plugin-image';
import typescript from '@rollup/plugin-typescript';

const bundle = (config) => ({
    ...config,
    input: 'src/index.ts',
    // marking all node modules as external
    external: (id) => !/^[./]/.test(id),
});
const globals = { react: 'React' };

export default [
    bundle({
        plugins: [typescript({ noEmitOnError: true }), image(), graphql()],
        output: [
            {
                dir: 'lib',
                format: 'es',
                name: 'Counter',
                compact: true,
                exports: 'named',
                sourcemap: true,
                preserveModules: true,
                chunkFileNames: '[name]-[hash].[format].js',
                globals,
            },
        ],
    }),
];

```

# packages-modules/counter/electron/package.json

```json
{
  "name": "@sample-stack/counter-module-electron",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "webpack",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "cross-env ENV_FILE=../../config/test/test.env jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "modulePaths": [
      "node_modules"
    ],
    "roots": [
      "src"
    ],
    "testEnvironment": "node",
    "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "dependencies": {
    "@sample-stack/counter-module-browser": "link:../browser"
  },
  "devDependencies": {
    "@open-wc/building-rollup": "^1.10.0",
    "@rollup/plugin-graphql": "1.0.0",
    "@rollup/plugin-image": "^2.0.6",
    "@rollup/plugin-typescript": "^6.1.0",
    "rollup": "latest"
  },
  "peerDependencies": {
    "@common-stack/client-react": "*",
    "native-base": "*",
    "react": "*",
    "react-native": "*",
    "react-redux": "*",
    "react-router": "*",
    "react-router-dom": "*",
    "redux": "*",
    "redux-observable": "*",
    "rxjs": "*"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}
```

# packages-modules/counter/electron/jest.config.js

```js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    testEnvironment: 'jsdom', // This is overriden, from the base testEnvironment
    name: packageJson.name,
    displayName: packageJson.name,
};
```

# packages-modules/counter/browser/webpack.config.js

```js
const nodeExternals = require('webpack-node-externals');
const webpack = require('webpack');
const path = require('path');

const webpackOpts = {
    mode: 'development',
    entry: {
        index: './src/index.ts',
    },
    target: 'node',
    output: {
        path: path.join(__dirname, 'lib'),
        filename: '[name].js',
        libraryTarget: 'commonjs2',
    },
    resolve: {
        extensions: ['.ts', '.tsx', '.graphql', '.graphqls', '.gql', '.native.tsx', '.native.ts'],
    },
    plugins: [
        new webpack.LoaderOptionsPlugin({
            options: {
                test: /\.tsx?$/,
                ts: {
                    compiler: 'typescript',
                    configFile: 'tsconfig.json',
                },
                tslint: {
                    emitErrors: true,
                    failOnHint: true,
                },
            },
        }),
    ],
    devtool: 'source-map',
    module: {
        rules: [
            {
                test: /\.tsx?$/,
                loaders: 'ts-loader',
                options: {
                    compilerOptions: {
                        outDir: path.join(),
                    },
                },
            },
            {
                test: /\.mjs$/,
                include: /node_modules/,
                type: 'javascript/auto',
            },
            {
                test: /\.(gql)$/,
                exclude: /node_modules/,
                use: ['graphql-tag/loader'],
            },
            {
                test: /\.graphql?/,
                exclude: /node_modules/,
                use: 'raw-loader',
            },
        ],
    },
    externals: [nodeExternals({ modulesDir: '../../../node_modules' }), nodeExternals()],
};

module.exports = webpackOpts;

```

# packages-modules/counter/browser/tsconfig.json

```json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "rootDir": "./src",
    "outDir": "lib",
    "declarationDir": "lib",
    "declaration": true,
    "declarationMap": true,
    "types": [
      "@types/node",
      "@types/jest",
      "../../../typings",
    ]
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js",
    "rollup.config.js"
  ],
  "include": [
    "src",
    "./typings/*.d.ts"
  ]
}
```

# packages-modules/counter/browser/rollup.config.js

```js
import graphql from '@rollup/plugin-graphql';
import image from '@rollup/plugin-image';
import typescript from '@rollup/plugin-typescript';
import { string } from 'rollup-plugin-string';

const bundle = (config) => ({
    ...config,
    input: 'src/index.ts',
    // marking all node modules as external
    external: (id) => !/^[./]/.test(id),
});
const globals = { react: 'React' };

export default [
    bundle({
        plugins: [
            image(),
            graphql({
                include: '**/*.gql',
            }),
            string({
                include: '**/*.graphql',
            }),
            typescript({ noEmitOnError: true }),
        ],
        output: [
            {
                dir: 'lib',
                format: 'es',
                name: 'Counter',
                compact: true,
                exports: 'named',
                sourcemap: true,
                preserveModules: true,
                chunkFileNames: '[name]-[hash].[format].js',
                globals,
            },
        ],
    }),
];

```

# packages-modules/counter/browser/package.json

```json
{
  "name": "@sample-stack/counter-module-browser",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "rollup -c rollup.config.js",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "cross-env ENV_FILE=../../config/test/test.env jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "modulePaths": [
      "node_modules"
    ],
    "roots": [
      "src"
    ],
    "testEnvironment": "node",
    "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "dependencies": {
    "@sample-stack/platform-browser": "link:../../../packages/sample-platform/browser",
    "antd": "~4.15.3"
  },
  "devDependencies": {},
  "peerDependencies": {
    "@common-stack/client-react": "*",
    "@rollup/plugin-graphql": "*",
    "@rollup/plugin-image": "*",
    "@rollup/plugin-typescript": "*",
    "react": "*",
    "react-native": "*",
    "react-redux": "*",
    "react-router": "*",
    "react-router-dom": "*",
    "redux": "*",
    "redux-observable": "*",
    "rollup-plugin-string": "*",
    "rxjs": "*"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}
```

# packages-modules/counter/browser/jest.config.js

```js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    testEnvironment: 'jsdom', // This is overriden, from the base testEnvironment
    name: packageJson.name,
    displayName: packageJson.name,
};
```

# packages/sample-store/src/index.ts

```ts
export * from './constants';
export * from './repository';
export * from './models';
export * from './container';
export * from './db-helpers';

```

# packages/sample-platform/server/webpack.config.js

```js
const nodeExternals = require('webpack-node-externals');
const webpack = require('webpack');
const path = require('path');
const glob = require('glob');
const fs = require('fs');

const webpackOpts = {
    mode: 'development',
    entry: {
        index: './src/index.ts',
    },
    target: 'node',
    output: {
        path: path.join(__dirname, 'lib'),
        filename: '[name].js',
        libraryTarget: 'commonjs2',
    },
    resolve: {
        extensions: ['.ejs', '.ts', '.tsx', '.graphql', '.gql'],
    },
    plugins: [
        new webpack.LoaderOptionsPlugin({
            options: {
                test: /\.ts$/,
                ts: {
                    compiler: 'typescript',
                    configFile: 'tsconfig.json',
                },
                tslint: {
                    emitErrors: true,
                    failOnHint: true,
                },
            },
        }),
    ],
    devtool: 'source-map',
    module: {
        rules: [
            {
                test: /\.ts$/,
                loaders: 'ts-loader',
            },
            {
                test: /\.graphql?/,
                exclude: /node_modules/,
                use: 'raw-loader',
            },
            {
                test: /\.(gql)$/,
                exclude: /node_modules/,
                use: ['graphql-tag/loader'],
            },
            {
                test: /\.ejs$/,
                exclude: /node_modules/,
                use: 'raw-loader',
            },
        ],
    },
    externals: [
        nodeExternals({ modulesDir: '../../../node_modules' }),
        nodeExternals(),
    ],
};

module.exports = webpackOpts;

```

# packages/sample-platform/server/tsconfig.json

```json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "experimentalDecorators": true,
    "preserveConstEnums": true,
    "rootDir": "./src",
    "outDir": "../lib",
    "declarationDir": "lib"
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js",
  ],
}
```

# packages/sample-platform/server/package.json

```json
{
  "name": "@sample-stack/platform-server",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "webpack",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "modulePaths": [
      "node_modules"
    ],
    "roots": [
      "src"
    ],
    "testEnvironment": "node",
    "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "dependencies": {
    "@sample-stack/core": "link:../../sample-core"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}

```

# packages/sample-platform/server/jest.config.js

```js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    name: packageJson.name,
    displayName: packageJson.name,
};

```

# packages/sample-platform/server/README.md

```md


## To run tests

    `npm link`
    `npm link @xtermstack/xterm-core`
    `yarn install`
    `tsc`
    `yarn test`

```

# packages/sample-platform/server/.npmignore

```
*
!lib/**

```

# packages/sample-platform/browser/webpack.config.js

```js
const nodeExternals = require('webpack-node-externals');
const webpack = require('webpack');
const path = require('path');
const fs = require('fs');

const webpackOpts = {
    mode: 'development',
    entry: './src/index.ts',
    target: 'node',
    output: {
        path: path.join(__dirname, 'lib'),
        filename: 'index.js',
        libraryTarget: 'commonjs2',
    },
    node: {
        __dirname: false,
    },
    resolve: {
        extensions: ['.ts', '.tsx', '.graphql', '.gql'],
    },
    plugins: [
        new webpack.LoaderOptionsPlugin({
            options: {
                test: /\.tsx?$/,
                ts: {
                    compiler: 'typescript',
                    configFile: 'tsconfig.json',
                },
                tslint: {
                    emitErrors: true,
                    failOnHint: true,
                },
            },
        }),
    ],
    devtool: 'source-map',
    module: {
        rules: [
            {
                test: /\.tsx?$/,
                loaders: 'ts-loader',
            },
            {
                test: /\.graphql?/,
                exclude: /node_modules/,
                use: 'raw-loader',
            },
            {
                test: /\.(gql)$/,
                exclude: /node_modules/,
                use: ['graphql-tag/loader'],
            },
        ],
    },
    externals: [nodeExternals({ modulesDir: '../../../node_modules' }), nodeExternals()],
};

module.exports = webpackOpts;

```

# packages/sample-platform/browser/tsconfig.json

```json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "esModuleInterop": true,
    "rootDir": "./src",
    "outDir": "../lib",
    "declarationDir": "lib"
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
```

# packages/sample-platform/browser/package.json

```json
{
  "name": "@sample-stack/platform-browser",
  "version": "0.0.1",
  "description": "Sample core for higher packages to depend on",
  "license": "ISC",
  "author": "CDMBase LLC",
  "main": "lib/index.js",
  "typings": "lib/index.d.ts",
  "scripts": {
    "build": "yarn build:clean && yarn build:lib",
    "build:clean": "rimraf lib",
    "build:lib": "webpack",
    "build:lib:watch": "yarn build:lib -- --watch",
    "jest": "./node_modules/.bin/jest",
    "prepublish": "yarn build",
    "test": "jest",
    "test:debug": "npm test -- --runInBand",
    "test:watch": "npm test -- --watch",
    "watch": "yarn build:lib:watch"
  },
  "jest": {
    "moduleFileExtensions": [
      "ts",
      "tsx",
      "js",
      "json"
    ],
    "modulePaths": [
      "node_modules"
    ],
    "roots": [
      "src"
    ],
    "testEnvironment": "node",
    "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$",
    "transform": {
      "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
    }
  },
  "dependencies": {
    "@sample-stack/core": "link:../../sample-core"
  },
  "publishConfig": {
    "access": "public"
  },
  "typescript": {
    "definition": "lib/index.d.ts"
  }
}

```

# packages/sample-platform/browser/jest.config.js

```js
const base = require('../../../jest.config.base');
const packageJson = require('./package');

module.exports = {
    ...base,
    name: packageJson.name,
    displayName: packageJson.name,
};

```

# packages/sample-core/src/index.ts

```ts
export interface PersonType {
    name: string;
    id: string;
    sex: string;
    matches: [PersonType];
}
export interface SomeType {
    testInt: number;
    testFloat: number;
    fixedString: string;
}

```

# docs/development/Mobile/Run_mobile.md

```md

### How to run mobile?

From the `<root>` of the project, once you finish installation and building all packages, run the following command.

\`\`\`
lerna exec --scope=*mobile yarn watch
\`\`\`


```

# docs/development/Mobile/React-Native-FAQ.md

```md

Q1. Uncaught TypeError: Cannot assign to read only property 'exports' of object '#<Object>'
A1. Because `import` and `module.exports` are not allowed to be mixed in webpack 2,
The solution is to change it to ES6.

```

# docs/development/Mobile/How_To_Make_Expo_Wrok_With_Monorepos.md

```md


https://medium.com/habilelabs/react-native-react-web-and-expo-together-in-one-monorepo-5b8f9a0fca00

As per the documentation, expo-yarn-workspaces work only on macOS and UNIX based systems, Windows is not supported.
If we want it to work on Windows as well, then we need to make slight modifications to it.
Firstly, remove the postinstallscript from package.json and move it to the main package.json-
"postinstall": "cd ./packages/ExpoApp && expo-yarn-workspaces postinstall"


```

# docs/development/Deployment/JenkinsDeployment.md

```md


# Jenkins Deployment

The branches used for Jenkins deployment will be `devpublish` for testing `develop` branch. This is used for pre production testing. 

`publish` branch is used for testing `master` branch. This is also used for production deployment.

- Modifying JenkinsFile

All modification in `Jenkinsfile` should be done in `develop` branch. As these changes need to be merged to `devpublish` for jenkins to use, you can run following command.

\`\`\`
yarn devpublish:push
\`\`\`


```

# docs/development/Deployment/How_To_Setup_Jenkins.md

```md
# Authorizing jenkins to access a repository
#### 1- execute to the jenkins running pod and get the publish ssh key
\`\`\`
kubectl exec -it <pod_name> bash
cat /var/jenkins_home/.ssh/id_rsa.pub
\`\`\`
#### 2- copy the key and go to the repository on github
- Go to Setting
- Deploy keys
- Add deploy key
#### 3- Go to jenkins
- Create a new item
- Choose pipeline
- Provide the repo name
- go to pipeline
- Choose pipeline script from SCM
- Choose git
- Give the repo URL and choose credential
- Choose the Username from credential list
#### If the credential (ssh public key) is used for the first time:
- choose Add Credentials
- Choose SSH Username with private key
- From the Jenkins master ~/.ssh
- Give the key a username and choose this user name later on on the list

# Authorizing jenkins to Google Container Registry
#### 1- in google cloud console
  - Go to APIs and services 
  - Credentials
  - create credential 
  - service account key 
  - New Service account
  - Add role Storage Admin
  - generate key of type JSON
> Copy the generated key to jenkins pod and user the 
> key path to login to gcr with docker login command

# Adding deploy key to jenkins and github repo
#### 1- execute to the jenkins running pod and get the public ssh key
\`\`\`
kubectl exec -it <pod_name> bash
mkdir repo-name
ssh-keygen 
\`\`\`
> generate the ssh key in the created directory
#### 2- Login to jenkins 
  - Go to Credentials 
  - System
  - Global credentials
  - Add Credentials
#### 3- Choose from the drop down list SSH Username with private key and edit the following 
- Add Username (that would be the credential name make it descriptive like the repo name)
- In the Private key section choose From a file on Jenkins master and add the path to the private key on jenkins (If you followed the above instruction it would be /repo-name/id_rsa)
- Ok to save the key in credentials 
#### 4- create a new pipeline in jenkins
#### 5- in the pipeline section choose Pipeline script from SCM
#### 6- Choose git as SCM 
#### 7- add the repo (ssh clone link)
#### 8- in credentials section choose the key you just created
    

```

# docs/development/Database/mongodb-test.md

```md


Writing Mongodb test
---

https://jestjs.io/docs/en/mongodb
```

# docs/development/CodeContribution/lerna-yarn-workspaces.md

```md
## Introduction

[Yarn Workspaces](https://classic.yarnpkg.com/en/docs/workspaces/) allow us to run `yarn install` only once, although we have several packages. Yarn uses a single lock file rather than a different one for each project, which means fewer conflicts. Once all the dependencies are installed together, Yarn can better optimize them. Its most important feature is that when we have one package depending on another package of our repository, yarn link them together, allowing us to use always the most up-to-date code available.


## Yarn & Yarn Workspaces

### Set up yarn

To configure Lerna to use yarn under the hood, we need to go to the **lerna.json** file and add the **npmClient** key with the value `yarn`. Its value is `npm` by default.

\`\`\`json[lerna.json]
{
  "packages": [
    "packages/*",
  ],
  "version": "0.0.0",
  "npmClient": "yarn"
}
\`\`\`

### Set up yarn workspaces

To configure Lerna to use Yarn Workspaces, first, we need to [Set up yarn](#set-up-yarn). Then we have to configure it in the **lerna.json** and **package.json** files.

To do so, let's use the following folder structure as an example:

\`\`\`bash
fullstack-pro
├── packages
│   ├── sample-core/
│   ├── sample-platform/
│   │   ├── browser
│   │   └── server/
│   ...
├── portable-devices
│   └── desktop
│   └── mobile
├── packages-modules
│   └── counter
│   │   ├── browser/
│   │   └── server/
├── servers
│   ├── backend-server/
│   ├── frontend-server/
│   ...
|── package.json
└── lerna.json
\`\`\`

In the **package.json** file, we add the **workspaces** key with a list of globs that indicates the folders where we want to store our packages.

\`\`\`json[package.json]
{
  "name": "root",
  "private": true,
  "workspaces": [
    "packages": [
      "portable-devices/*",
      "packages-modules/**",
      "packages/**",
      "servers/*"
    ]
  ],
  "devDependencies": {
    "lerna": "^3.22.1"
  }
}
\`\`\`

In the **lerna.json** file, we can remove the **packages** key because the  **workspaces** key in the **package.json** file overrides it. We also need to add the **useWorkspaces** key with the value `true`.

\`\`\`json[lerna.json]
{
  "version": "0.0.0",
  "npmClient": "yarn",
  "useWorkspaces": true
}
\`\`\`

### Lerna
- [Getting Started with lerna](./lerna-build-tools.md)
```

# docs/development/CodeContribution/lerna-build-tools.md

```md

What is lerna?
===
[Lerna](https://github.com/lerna/lerna) allows us to manage multiple packages inside the same repository instead of creating one repository per package. With Lerna, we can unify processes like linting, building, testing, and releasing, have a single place to report issues, and becomes easier to set up our development environment.


Things to know about current package structure
--
- We run `lerna` commands by wrapped into `npm/yarn` commands. 
- You will notice there are following commands which run's lerna comamnds.

\`\`\`json
{
    ...
    "lerna:prepublish": "git checkout publish && git merge -s recursive -X theirs master",
    "lerna:prepublish:develop": "git checkout publish-develop && git merge -s recursive -X theirs develop",
    "watch": "lerna exec --no-sort --ignore *server --stream --parallel -- webpack --watch",
    "publish": "yarn lerna:prepublish && lerna publish",
    "lerna": "lerna bootstrap --hoist",
    "postinstall": "yarn lerna",
    "clean": "lerna clean",
    "build": "yarn build:packages",
    "build:packages": "lerna run build --ignore *server",
    "build:packages:watch": "lerna run build:lib:watch --ignore *server --stream",
    "watch-packages": "lerna exec --no-sort  --scope @sample-stack/platform* --scope @sample-stack/react-shared-components --scope @sample-stack/core --stream --parallel 'webpack --watch'",
    ...
}
\`\`\`

Details on each command that wrapped for lerna
--
- `yarn install` - This command need to be run in the root of the package only to install all the dependencies. We have post step(`postinstall`) to run `yarn lerna` after install finishes so `lerna` will installs all of packages (seen under packages directory) dependencies and links any cross-dependencies.
Note: We do not need to run `yarn` under any packages with `package.json` files seen under `packages` and `servers` directories. 
- `yarn lerna` - This triggers `lerna bootstrap --hoist`. Normally this get triggered as post install step. You can run this command to install any packages' dependencies. More information about this command can be found [here](https://github.com/lerna/lerna/blob/master/doc/hoist.md). The bottom line, the `hoist` will try to install all common dependencies to the top-level node_modules, and omitted from individual package's `node_modules`.
The outlier packages with different versions will get a normal, local node_modules installation of the necessary dependencies.
- `yarn clean` - Removes the `node_modules` directory from all packages.
- `yarn clean:force` - Removes the `node_modules` directory from all packages as well as `package-lock.json` file.
- `yarn build` - It invokes `yarn build` in each packages parallely. 
- `yarn watch` - Automatically builds the packages that are changed. Recommended to run this when actively coding, so you would know anything (compilation errors) breaks instantly. You may also see `Error: ENOSPC: System limit for number of file watchers reached` if you OS is not configured with high open files. Check [Not Enough Watchers](#not-enough-watchers) section for futher information.
- `yarn watch-packages` - Abutomatically builds the dependent packages mostly under `packages` folder. 
- `yarn watch-packages -- --scope @sample-stack/counter-module-*` - By adding package module you like to watch along with the dependent packages. If you have more packages to watch keep adding with `-- --scope packageA* --scope packageB`



Not Enough Watchers
----
Based on the project, we may have multiple `packages` and `packages-modules` to watch for file changes in order to automatically apply the changes in the browser. 
When we have more modules to watch, we need laptop resource to support it. If the laptop OS is configured with default `open files`, we need to increase it. 
Follow notes from webpack to change OS configuration to increase file watchers https://webpack.js.org/configuration/watch/#not-enough-watchers

But, in case, if you are working in only one or two modules and need to watch them only then you can run below command on each packages, 
respectively. 

`lerna exec --scope=<package name> yarn watch`

example: run them in different command tabs for all (package1, package2, pacakge3) packages to watch.

\`\`\`
lerna exec --scope=@sample-stack/counter-module-browser yarn watch
lerna exec --scope=@sample-stack/counter-module-server yarn watch
\`\`\`

Adding packages as dependencies to sibling packages (not needed anymore)
--
When you add sibling package to one of the packages, you need to run `yarn lerna` symlink the packages that are dependencies of each other.


### List packages

Using the following folder structure, versions, and privacy as an example:

\`\`\`bash
fullstack-pro/
├── packages
│   ├── sample-core         # 1.1.1 - public
│   ├── sample-platform    
│   │   ├── browser         # 1.1.1 - public
│   │   └── server          # 1.1.1 - public
│   ...
├── packages-modules
│   └── counter 
│   │   ├── browser     
│   │   └── server
├── servers
│   ├── backend-server      # 1.0.0 - private
│   ├── frontend-server     # 1.0.0 - private
│   ...
|── package.json
└── lerna.json              # 1.1.1
\`\`\`

List all public packages

\`\`\`bash
lerna ls

# result
@sample-stack/counter-module-browser
@sample-stack/counter-module-server
@sample-stack/core
@sample-stack/platform-browser
@sample-stack/platform-server
@sample-stack/store
\`\`\`

List all packages (public and private)

\`\`\`bash
lerna ls --all

# result
@sample-stack/counter-module-browser
@sample-stack/counter-module-server
@sample-stack/core
@sample-stack/platform-browser
@sample-stack/platform-server
@sample-stack/store
sample-stack-desktop                 (PRIVATE)
sample-stack-mobile                  (PRIVATE)
sample-stack-backend-server          (PRIVATE)
sample-stack-frontend-server         (PRIVATE)
sample-stack-moleculer-server        (PRIVATE)
\`\`\`

List all public packages with more details

\`\`\`bash
lerna ll
# or
lerna ls -l

# result
@sample-stack/counter-module-browser v0.0.1 packages-modules/counter/browser
@sample-stack/counter-module-server  v0.0.1 packages-modules/counter/server
@sample-stack/core                   v0.0.1 packages/sample-core
@sample-stack/platform-browser       v0.0.1 packages/sample-platform/browser
@sample-stack/platform-server        v0.0.1 packages/sample-platform/server
@sample-stack/store                  v0.0.1 packages/sample-store
\`\`\`

List all public and private packages with details

\`\`\`bash
lerna la
# or
lerna ls -la

# result
@sample-stack/counter-module-browser v0.0.1 packages-modules/counter/browser
@sample-stack/counter-module-server  v0.0.1 packages-modules/counter/server
@sample-stack/core                   v0.0.1 packages/sample-core
@sample-stack/platform-browser       v0.0.1 packages/sample-platform/browser
@sample-stack/platform-server        v0.0.1 packages/sample-platform/server
@sample-stack/store                  v0.0.1 packages/sample-store
sample-stack-desktop                 v0.0.1 portable-devices/desktop         (PRIVATE)
sample-stack-mobile                  v0.0.1 portable-devices/mobile          (PRIVATE)
sample-stack-backend-server          v0.0.1 servers/backend-server           (PRIVATE)
sample-stack-frontend-server         v0.0.1 servers/frontend-server          (PRIVATE)
sample-stack-moleculer-server        v0.0.1 servers/moleculer-server         (PRIVATE)
\`\`\`

## Packages vs Scoped Packages

All npm packages have a name. Some also have a scope. Scopes are a way of grouping related packages together.

When we sign up for an npm user account or create an organization, we can use a scope that matches our user or organization name. The same happens for Github Packages Registry. In both registries, my username is **sample-stack**, so my scope is also **sample-stack**.

Using packages without a scope, we can easily have naming conflicts with other person packages. For example, we can not create a package named jquery on npm because it already exists.

When we use scoped packages, naming is not a problem because we are naming packages inside our scope.

If I were creating a new scoped package called **core**, its name in the **package.json** file would be **@sample-stack/core**.

## Dependencies
The dependencies of our projects are registered inside the **package.json** file. This file is usually in the project's root folder, but it is also inside each package in the Lerna projects. **Each package has its dependencies.**

\`\`\`bash
fullstack-pro/
├── packages
│   ├── sample-core
│   │   ├── package.json
│   │   └── ...
│   ├── sample-platform
│   │   ├── browser
│   │   │   ├── package.json
│   │   │   └── ...
│   │   └── server
│   │   │   ├── package.json
│   │   │   └── ...
│   ...
├── packages-modules
│   └── counter
│   │   ├── browser
│   │   │   ├── package.json
│   │   │   └── ...
│   │   └── server
│   │   │   ├── package.json
│   │   │   └── ...
├── servers
│   ├── backend-server
│   │   ├── package.json
│   │   └── ...
│   ├── frontend-server
│   │   ├── package.json
│   │   └── ...
│   ...
|── package.json
└── lerna.json
\`\`\`
To add dependencies to the packages, Lerna provides us the command `lerna add`. Note that only a single package can be added at a time compared to `yarn add` or `yarn install`.

### Add dependencies

The **dependencies** key must contain all the dependencies our project/application/package/library needs to work in production. **We know when we must declare it as a dependency when its absence has side effects on your production build.**

**Adding dependencies**

\`\`\`bash
# add a dependency to one package
lerna add lodash --scope=@sample-stack/counter-module-browser

# add a dependency to several packages
lerna add lodash packages-modules/counter-*

# add a dependency to all packages
lerna add lodash

# add a dependency on the root package.json
lerna add lodash -w
\`\`\`

### Add devDependencies

The **devDependencies** key must contain all the **dependencies we use during development or needed during the build of our production bundle**. To add a dependency as devDependency just add the flag `--dev`.

\`\`\`bash
# add a devDependency to one package
lerna add lodash --scope=@sample-stack/counter-module-browser --dev

# add a devDependency to several packages
lerna add lodash packages-modules/counter-* --dev

# add a devDependency to all packages
lerna add lodash  --dev

# add a devDependency on the root package.json
lerna add lodash -w  --dev
\`\`\`

### Add peerDependencies

The  **peerDependencies** key is **used when our package has a dependency that can also be a dependency of the project using it**. If our package has a dependency that can also be used by its dependent, we can specify the version required by us and the dependent will receive a warning when not matching that requirement.

\`\`\`bash
# add a peerDependency to one package
lerna add lodash --scope=@sample-stack/counter-module-browser --peer

# add a peerDependency to several packages
lerna add lodash packages-modules/counter-*  --peer

# add a peerDependency to all packages
lerna add lodash  --peer
\`\`\`

### Updating dependencies

Well, that is a problem. Lerna has no direct command to upgrade dependencies, which is ok when we want to update a dependency in the root package.json. We can use yarn as usually:

\`\`\`bash
# update a dependency on the root package.json
yarn upgrade lodash
\`\`\`

However, when we want to  upgrade a dependency inside a package, nothing seems to work. Using `lerna exec` as we use it to remove dependencies does not work.

For now, what we do is manually update the dependencies version in the `package.json` file of each package and then run `yarn install`.


### Updating all sub packages of a **scoped** packages to newest release
lerna exec "ncu -u --newest --timeout 60000 -f /@sample-stack*/"

***note** after updating packages you need to run `yarn` to install them. 

### Removing dependencies

Lerna also has no direct way to allow us to remove dependencies from the project or packages but we can use the `lerna exec` and `yarn remove` commands to go around it.

`lerna exec` allow us to run a specific command within a particular package, several packages (using a glob expression), or in all of them. Using it with `yarn remove` we can remove dependencies from the packages. Using `yarn remove` alone we can also remove dependencies from the root package.json.

\`\`\`bash
# remove a dependency to one package
lerna exec --scope @sample-stack/counter-module-browser -- yarn remove lodash

# remove a dependency to several packages
lerna exec --scope @sample-stack/counter-* -- yarn remove lodash

# remove a dependency to all packages
lerna exec -- yarn remove lodash

# remove a dependency from the root package.json
yarn remove lodash
\`\`\`

### List modified packages

Like the `git status` command that shows us the files that we modified, Lerna provides us the command `lerna changed` that shows us the packages (not the files) that we modified compared to the remote repository.

\`\`\`bash
lerna changed
\`\`\`

### Diffing

**All modifications**

Like the `git diff` command but ignoring the files outside the packages, Lerna provides us the command `lerna diff` that shows us all the code modifications we did. We can also provide a package name to see only the modifications to that package.

\`\`\`bash
# all modifications
lerna diff

# modifications in a specific package
lerna diff @sample-stack/counter-module-browser
\`\`\`
## Publish

To publish our packages using Lerna we use the command `lerna publish` but, first, let's configure Lerna only to allow us to create newer versions of our packages from our main branch (eg. master).

\`\`\`json[lerna.json]
{
  "version": "0.0.0",
  "command": {
    "version": {
      "allowBranch": "master"
    }
  }
}
\`\`\`

Now, if we try to run `lerna publish` inside another branch, it will fail. As highlighted in the [Lerna documentation](https://github.com/lerna/lerna/tree/main/commands/version#--allow-branch-glob), this is a best practice that can save us some problems.

To publish a **scoped package** we also need to set the `publishConfig.access` to `true` in its **package.json**:

\`\`\`json[packages/sample-core/package.json]
{
  "name": "@sample-stack/core",
  "version": "0.0.0",
  "publishConfig": {
    "access": "public"
  }
}
\`\`\`
Setting this configuration in a package without a scope fails to publish.

Imagine that we started developing the **sample-core** package, and although we merged some initial versions, we didn't finish yet, and **we don't want to release it to npm yet**. We can add to its **package.json** the **private** key with the value `true`, and Lerna will ignore it.

\`\`\`json[packages/sample-core/package.json]
{
  "name": "app-button",
  "version": "0.0.0",
  "private": true
}
\`\`\`

### npm

To publish to npm, first, we need to have an npm account.

We can see if we are logged in running:

\`\`\`bash
npm whoami
\`\`\`

In case we are not, we do it running:

\`\`\`bash
npm login
\`\`\`

Once we are logged in we can run:

\`\`\`bash
lerna publish
\`\`\`

Which prompts possible versions to update each package. It's up to us to select the right ones based on what we have done. Check the [Semantic Versioning Specification](https://semver.org/) for more information about versioning.

### Github Package Registry

To publish in the Github Packages Registry, we need some extra configurations.

First, in the **package.json** of each package, we must specify the repository where our code lives.

\`\`\`json[package.json]
{
  ...
  "repository" : {
    "type" : "git",
    "url": "ssh://git@github.com:cdmbase/fullstack-pro.git"
  }
}
\`\`\`

Then, in the **lerna.json** file, we must specify the registry to publish the packages. By default, it is the npm registry. We have to change it to the `https://npm.pkg.github.com`.

\`\`\`json[lerna.json]
{
  "packages": [
    "packages/*"
  ],
  "version": "0.0.0",
  "command": {
    "version": {
      "allowBranch": "master"
    },
    "publish": {
      "registry": "https://npm.pkg.github.com"
    }
  }
}
\`\`\`

We also have to create a personal token on GitHub with the permissions to read and write packages (`read:packages` and `write:packages`).

Using the generated token as a password, we authenticate on GitHub Package Registry:

\`\`\`bash
$ npm login --registry=https://npm.pkg.github.com
> Username: USERNAME
> Password: TOKEN
> Email: PUBLIC EMAIL ADDRESS
\`\`\`

And we are ready to publish packages:

\`\`\`bash
lerna publish
\`\`\`

## Conventional Commits

Lerna allows us to use the [Conventional Commits Specification](https://www.conventionalcommits.org/) to determine the bump version and generate the CHANGELOG.md files automatically.

Follow the specification, when we are creating a new release, Lerna checks all the commits since the last release and it increments:
- the PATCH number when the subject of the commit is prefixed with `fix:`;
- the MINOR number when the subject of the commit is prefixed with `feat:`. It has precedence over the PATCH;
- the MAJOR number when in the body of some commit it finds a string `BREAKING CHANGE:`. It can have any type provided in the subject and it has precedence over PATCH and MINOR. 

Considering that we are using fixed versions and our project is in the version `1.0.0`. If we try to create a new release with the following commit, our project version is updated to `1.0.1`.
\`\`\`bash
# commit 1
subject -> "fix: fix button font size"
\`\`\`

Then, if we do two more commits and publish again, the version is updated to `1.1.0`.
\`\`\`bash
# commit 1
subject -> "fix: fix button border-radius"
# commit 2
subject -> "feat: added loading status to the button"
\`\`\`

Finally, if we do three more commits, the version is updated to `2.0.0`.
\`\`\`bash
# commit 1
subject -> "fix: fix button text color"
# commit 2
subject -> "feat: added outlined style"
# commit 3
subject -> "feat: changed the loading property to isLoading"
body: "BREAKING CHANGE: loading prop must be updated to isLoading"
\`\`\`

### Configuration

To do that, we update our `lerna.json` file:

\`\`\`bash
{
  ...
  "command": {
    "publish": {
       "conventionalCommits": true, 
       "yes": true
    }
  }
}
\`\`\`

Now, when we run `lerna publish` instead of asking us what version we want to give to each package, it automatically determines and publishes those versions.
```

# docs/development/CodeContribution/installation_issues.md

```md



1. Error when `node-gyp rebuild`.
 Could be missing `python`. Install it and rerun the install again. 
 For more docs, check https://github.com/nodejs/node-gyp#installation

2. For Mac User to develop Desktop app need
`xcode-select --install`

```

# docs/development/CodeContribution/faq.md

```md
---
id: faq-build
title: Babel, JSX, and Build Steps
permalink: docs/faq-build.html
layout: docs
category: FAQ
---


### From where this `@sample-stack/platform-browser` comes  in `packages/sample-platform/browser/src/containers/Counter.tsx`?

We use [lerna](https://github.com/lerna/lerna) for monorepo. For example all packages starts with `@sample-stack` are either under `packages` or `pacakges-modules` directories.


### Why you have used [hot](https://github.com/cdmbase/fullstack-pro/blob/master/servers/frontend-server/src/app/Main.tsx#L3)?

It is used for `hot reloading`. Checkout out [React Hot Loader](https://github.com/gaearon/react-hot-loader)

### What is use of rehydrate?

It is used for SSR(server side rendering). Server generates initial browser page along with state(redux or apollo-client or css) and that state will be used in the browser to rehydated during browser rendering so the client state don't start from initial values.

```

# docs/development/CodeContribution/Tutorials.md

```md


Typescript Tutorials
---
https://basarat.gitbooks.io/typescript/
https://medium.com/@martin_hotell/react-children-composition-patterns-with-typescript-56dfc8923c64



Cors: 
---
https://www.blackhillsinfosec.com/cors-lite/
```

# docs/development/CodeContribution/Project_Setup.md

```md
## Getting Started

If you want to develop FullStack locally you must follow the following instructions:

1. Clone fullstack-pro locally
\`\`\`
git clone https://github.com/cdmbase/fullstack-pro
cd fullstack-pro
\`\`\`

2. Install dependencies and build packages.

    a. make sure `python` version `2.7.16` or higher in `^2` version installed.

    b. install `node-gyp` globally. For installation check [this document](https://github.com/nodejs/node-gyp#installation).

    c. install `watchman` for macOS users

    d. Node version supported is `>=12.18.4` and `yarn` version is `1.22`. You can Download Node from [here](https://nodejs.org/dist/v12.18.4/)

    e. Insall and build packages using following command. Run from the root folder of this project.
\`\`\`
    yarn bootstrap
\`\`\`
    
3. Setup environment file

You need to have environemnt file before you start the project. There is a sample file exist at `config/development/dev.env.sample` which you can copy as `config/development/dev.env`.

\`\`\`
cp ./config/development/dev.env.sample ./config/development/dev.env
\`\`\`

You may need to set personalized values in the `dev.env` file.

4. Start server MongoDB and Redis (look for Installation Section)

> redis-server

> mongod

5. Start both client and server together
\`\`\`
yarn start
\`\`\`
Alternatively, if you need to run `backend` and `frontend` on its respective terminal instead of one terminal then follow [How to Start Backend and Frontend seperately](./How_to_Run_Various_Options.md#how-to-start-backend-and-frontend-seperately)

### Server Enpoints: 
The graphql server endpoints are
>http://localhost:8080/graphql

The browser server endopoint is
>http://localhost:3000


## How to run with HotReload for live changes both in the server and browser?

To run build with watch for dependent packages, for auto reloading changes into the server to be productive during development.

\`\`\`
yarn watch-packages
\`\`\`

If you also need to watch along with it, you can use as many scopes as required like below. 

\`\`\`
yarn watch-packages -- --scope=@sample-stack/counter-module* --scope=@packageb
\`\`\`

To run build with watch for all the packages. Note: This will run watch on all packages under `packages-modules` and may saturate the resources in your laptop instead run above `watch-packages` command.

\`\`\`
yarn watch
\`\`\`

Sometimes if we have to run `build` or `watch` you can use the `lerna` [command](https://github.com/lerna/lerna/tree/master/commands/exec#usage) for the targeted packages

\`\`\`
lerna exec --scope=<package name> yarn watch
\`\`\`

- here `<package name>` will be the package you working on currently. If you have multiple packages, then you need to run it multiple times for each package in its respective terminal.

## How to take changes from the branch?

Most of the changes at code level can be taken using `git` command.

But in some cases when `lerna's packages` are added or versions in `packages.json` are updated, to avoid getting installed duplicate pacakges due to monrepo architecture you need to first clean existing `node_modules` and reinstall again. This can be done with following command.

\`\`\`
yarn clean:force && git pull <branch_name> && yarn install && yarn build
\`\`\`
- here <branch_name> should be replaced with the branch you getting updates.

## Installation of Prerequisties servers

Install redis and setup an instance with default settings on default port,

* Install Redis on a Linux, OS X, or a similar Posix operating system

## Advance Options
### To test Production build and run
You need to run Frontend and Backend in two seperate servers. 

to start frontend server
\`\`\`
lerna exec --scope=*frontend-server yarn build
lerna exec --scope=*frontend-server yarn start:dev
\`\`\`
to start backend server
\`\`\`
lerna exec --scope=*backend-server yarn build
lerna exec --scope=*backend-server yarn start:dev
\`\`\`

Note: you can pass `:<env>` next to `start` to use env config.
- dev: to use `/config/development/dev.env`
- stage: to use `/config/staging/staging.env`



### Docker build and run

Build three docker images by following the steps:
- Frontend Server
\`\`\`
lerna exec --scope=*frontend-server yarn docker:build
lerna exec --scope=*frontend-server yarn docker:run
\`\`\`
- Backend Server
\`\`\`
lerna exec --scope=*backend-server yarn docker:build
lerna exec --scope=*backend-server yarn docker:run
\`\`\`
- moleculer-server
\`\`\`
lerna exec --scope=*moleculer-server yarn docker:build
lerna exec --scope=*moleculer-server yarn docker:run
\`\`\`

Note: It uses `/config/staging/staging.env` for environment variables.

### Environment settings for non-development
\`\`\`
GRAPHQL_URL
CLIENT_URL
NATS_URL
NATS_USER
NATS_PW
\`\`\`
## Troubleshoot
To troubleshoot webpack configuration run
\`\`\`
yarn zen:watch:debug
\`\`\`

```

# docs/development/CodeContribution/Lint_And_Formatter.md

```md
### Lint and Formatter

`eslint` and `prettier` is used along each other. `eslint-config-airbnb-base` (not `eslint-config-airbnb`, which includes `jsx` rules) is used as well. [`eslint-plugin-jest`](https://github.com/jest-community/eslint-plugin-jest/issues) and [`eslint-plugin-markdown`](https://github.com/eslint/eslint-plugin-markdown) (not for markdown itself, but for code block snippet appeared in markdown) are also configured.

By configuring `overrides` in `.eslintrc.js`, both of typescript and javascript files are able to be linted by `eslint`. (e.g. So typescript rules are not applied to `.js` files.)

[`markdownlint`](https://github.com/DavidAnson/markdownlint) is configured by [`markdownlint-cli`](https://github.com/igorshubovych/markdownlint-cli#readme).

[`commitlint`](https://github.com/conventional-changelog/commitlint) is used as commit message linter. You can `yarn lint:md .`, for example. Refer to [conventional commits](https://www.conventionalcommits.org/en/) for more details.

```

# docs/development/CodeContribution/Known_Issues.md

```md


# Kown Issues


1. EACCES: permission denied, scandir .....

Follow the workaround https://github.com/cdmbase/fullstack-pro/issues/176

2. OS X: "Error: EMFILE: too many open files, watch"
Follow https://github.com/facebook/create-react-app/issues/4540

\`\`\`
brew install watchman
\`\`\`

3. Macbook Catalina: `Zsh` latest macos comes with `Zsh` as the default shell. We seeing some issues to start the project with it. Please use `bash` to run project.

https://www.howtogeek.com/444596/how-to-change-the-default-shell-to-bash-in-macos-catalina/
```

# docs/development/CodeContribution/How_to_Run_Various_Options.md

```md
## SETUP and INSTALL
### To Install the project and build all packages

`yarn bootstrap`

### To clean install the project of already installed.

If you need to do a clean the existing node_modules and take latest changes from the remote head

`yarn clean:install`

## LINTING
### To check linting

`yarn lint <relative folder>`

### To check and auto fix linting

`yarn format <relative folder>`

## PACKAGES COMMANDS
### To run build all packages

`yarn build`

### To run all packages in watch mode

`yarn watch`

Note: It only run `packages` and `packages-modules` only in watch mode. Servers should be run seperately.

Also check out `yarn watch-packages` to run watch on required packages. 

### To run build with watch for dependent packages

For auto reloading changes into the server to be productive during development.

\`\`\`
yarn watch-packages
\`\`\`

If you also need to watch along with it, you can as many scopes as required like below. 

\`\`\`
yarn watch-packages -- --scope=@sample-stack/counter-module* --scope=@packageb
\`\`\`

## TO START SERVERS
### To run a individual package in watch mode

`lerna exec --scope=<package name> yarn watch`

More details on how to use [lerna exec](https://github.com/lerna/lerna/tree/master/commands/exec#options)


To run any command on a package <package_name>

`lerna exec --scope=<package_name> <command>`


### How to Start Backend and Frontend seperately.

To start the frontend-server

`lerna exec --scope=*frontend-server yarn watch`

To just start the backend-server

`lerna exec --scope=*backend-server yarn watch`

### To run both Frontend and Backend Server

`yarn start`

### To run both Frontend and Backend Server but start frontend in SSR Mode

`yarn start:envSSR`


### To run Frontend with production build in development

build the package

`lerna exec --scope=*frontend-server yarn build`

start the server with `dev` environment file

`lerna exec --scope=*frontend-server yarn start:dev`

Make sure backend is also running in seperate terminal

`lerna exec --scope=*backend-server yarn watch`




```

# docs/development/CodeContribution/HowToContribute.md

```md

How to contribute as a developer?
--

1. Once you setup the project, switch to `develop` branch. 
2. Create a new branch using `develop` branch as source based on the issue you working. 
3. Update changes to that branch and create a PR agains `develop` branch. 
4. As soon as PR is created, we have a build process that runs in the background to check whether it is successful or failed.
5. If it successfull you will see a green check otherwise a red cross. When you notice it has red cross then run `yarn build` locally and fix any issues and submit the commit again to check it's updated status.



Note: `master` branch is read-only branch and we don't want to merge anything to it other than that from `develop` branch. So please avoid creating PRs agains master branch. 


```

# docs/development/CodeContribution/GitHooks.md

```md
### Git Hooks

`Husky` executes `lint-staged` and `commitlint` by git hooks. `lint-staged` makes sure staged files are to be formatted before committed. Refer to `package.json` for details.

```

# docs/development/CodeContribution/DoAndDont.md

```md



Don't do it...
---
1. `yarn <package>`

    Do not install dependencies as `yarn <package dependency>`.
    We use `lerna` and the way it works for the project is by installing `dependencies` to the `packages` or `servers` that requires it. In most cases,
    you can just add the package to frontend or backend by running following

    > to add to the frontend server so browser gets it

   `lerna add --scope=*fronted-server <package>`


    > to add to the backend server for nodejs to use it

   `lerna add --scope=*backend-server <package>`

    If a dependency is just needed by one package, you can add to that package's package.json file

   `lerna add --scope=<package name> <package>`

   Ideally, root `package.json` should have all the `devDependencies` of the project while `packages` & `servers` file references should be under `dependencies` section as shown [here](https://github.com/cdmbase/fullstack-pro/blob/master/package.json#L67-L78).

   Sometimes we may need to `pin` a package as other dependencies can bring some older versions of the package we want to add. In that case we can pin the required package version by adding to the `pacakge.json`. But make sure you don't have different version of the package in `servers` or `packages` otherwise a duplciate package will be added to its `nodemodules`.

Do
---
1. Each package version should be uniform across the repository

    Before adding a `<package dependency>`, see if the package of different version exist. If it exist then update that version to the required version.

2. You can edit one of the `packages` or `servers`'s `package.json` file directly to add a `dependencies` and then run `yarn lerna` to install them. This is a easy way to install a known version by adding to the target `pacakage.json` file.
```

# docs/development/CodeContribution/Desktop_Setup.md

```md

# Follow steps to [install project](./Project_Setup.md)

### Start Desktop application

Before to start desktop application, make sure to start the backend server of the web application first. 

`lerna exec --scope=*backend-server yarn watch`

And then start desktop application. 

`lerna exec --scope=*desktop yarn watch`

```

# docs/development/CodeContribution/Adding_New_Modules.md

```md
# Adding Modules with FullStack Pro Kit

In this guide, we explain how you can add new modules with FullStack-pro Kit.

## Table of Contents

* [Add New Modules](#installing-and-importing-dependencies)


## Add New Modules

Adding new modules, usually goes under `packages-modules` folder. For example to create counter module, you create

1. From root directory, create following folders by running the commands (in unix).
    \`\`\`
    mkdir -p packages-modules/counter/browser/src
    mkdir -p packages-modules/counter/servers/src

    touch packages-modules/counter/browser/src/package.json
    touch packages-modules/counter/servers/src/package.json
    \`\`\`

2. Copy following files from the existing modules,

    From one of the existing moudles, copy the following files into the new module. Make sure the browser's module are copied from another existing browsers location and similarly for server's module.

    - webpack.config.js
    - tsconfig.json


3. Copy the content of the package.json for both browser and server from the existing modules and change the `name` in the package.json to the specific name of the module you want to create. Please make sure to keep the namespace of the module uniform, if the existing module have `@sample-stack`, your new browser module's `package.json` name would be `@sample-stack/counter-browser`, similarly for server module will have `@sample-stack/counter-server`.

    \`\`\`json
    {
        "name": "@sample-stack/counter-module-browser",
        "version": "0.0.1",
        .....
        "publishConfig": {
            "access": "public"
        },
        .....

        "dependencies": {
            "@sample-stack/platform-browser": "link:../../../packages/sample-platform/browser",
        },
        "peerDependencies": {
            "@common-stack/client-react": ">=0.0.229",
            "@common-stack/core": ">=0.0.229",
            "antd": "^3.26.4"
        }
    }
    \`\`\`
    Add any additional dependencies that this module needed.

4. Then, to use the new module add to `servers` and main `package.json`

    a. In root `package.json` file add the new module where you have existing modules
    \`\`\`json
    "dependencies": {
        .....
        "@sample-stack/counter-module-browser": "link:packages-modules/counter/browser",
        "@sample-stack/counter-module-server": "link:packages-modules/counter/server",
        ....
    }
    \`\`\` 
    b. In frontend server `servers/frontend-server` add the browser module with relative path.
    \`\`\`json
    "dependencies": {
        .....
        "@sample-stack/counter-module-browser": "link:../../packages-modules/counter/browser",
    }
    \`\`\`
    c. In backend servers `servers/backend-server` add the server module with relative path.
    \`\`\`json
    "dependencies": {
        ....
        "@sample-stack/counter-module-server": "link:../../packages-modules/counter/server",
        ....
    }
    \`\`\`

Notes:

- You may have to rerun `yarn watch` to pickup new modules

```

# tools/templates/module/browser/webpack.config.js

```js
var nodeExternals = require('webpack-node-externals');
var webpack = require('webpack');
var path = require('path');
var fs = require('fs');

var webpackOpts = {
  mode: 'development',
  entry: './src/index.tsx',
  target: 'node',
  output: {
    path: path.join(__dirname, 'lib'),
    filename: 'index.js',
    libraryTarget: "commonjs2",
  },
  node: {
    __dirname: false
  },
  resolve: {
    extensions: ['.ts', '.tsx', '.graphql', '.gql'],
  },
  plugins: [
    new webpack.LoaderOptionsPlugin({
      options: {
        test: /\.tsx?$/,
        ts: {
          compiler: 'typescript',
          configFile: 'tsconfig.json'
        },
        tslint: {
          emitErrors: true,
          failOnHint: true
        }
      }
    })
  ],
  devtool: 'source-map',
  module: {
    rules: [{
      test: /\.tsx?$/,
      loaders: 'ts-loader'
    }, {
      test: /\.graphql?/,
      exclude: /node_modules/,
      use: 'raw-loader',
    }, {
      test: /\.(gql)$/,
      exclude: /node_modules/,
      use: ['graphql-tag/loader']
    }
    ]
  },
  externals: [
    nodeExternals({ modulesDir: "../../../node_modules" }),
    nodeExternals()
  ]
};

module.exports = webpackOpts;

```

# tools/templates/module/browser/tsconfig.json

```json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "rootDir": "./src",
    "outDir": "../lib",
    "declarationDir": "../lib",
    "typeRoots": [
      "../../../node_modules/@types"
    ],
    "skipLibCheck": true
  },
  "include": [
    "../../../typings/*.d.ts",
  ],
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
```

# tools/templates/module/browser/package.json

```json
{
    "name": "@adminide-stack/$module$-browser",
    "version": "0.0.1",
    "description": "Sample core for higher packages to depend on",
    "main": "lib/index.js",
    "scripts": {
        "jest": "./node_modules/.bin/jest",
        "test": "cross-env ENV_FILE=../../config/test/test.env jest",
        "test:debug": "npm test -- --runInBand",
        "test:watch": "npm test -- --watch",
        "prepublish": "yarn build",
        "watch": "yarn build:lib:watch",
        "build": "yarn build:clean && yarn build:lib",
        "build:clean": "rimraf lib",
        "build:lib": "webpack",
        "build:lib:watch": "yarn build:lib -- --watch",
        "schema:download": "./node_modules/.bin/apollo-codegen download-schema http://localhost:8080/graphql --output schema.json ",
        "schema:generate": "./node_modules/.bin/apollo-codegen generate src/browser/graphql/**/*.gql --schema schema.json --target typescript --output src/browser/graphql/schema.ts",
        "githubschema:download": "./node_modules/.bin/apollo-codegen download-schema https://api.github.com/graphql --output githubapi-schema.json  --header 'Authorization: Bearer 0ec1b5e245de6061066262daf4aac2135fddd683'",
        "githubschema:generate": "./node_modules/.bin/apollo-codegen generate src/browser/graphql/**/*.gql --schema githubapi-schema.json --target typescript --output src/browser/graphql/github-schema.ts"
    },
    "jest": {
        "testEnvironment": "node",
        "roots": [
            "src"
        ],
        "modulePaths": [
            "node_modules"
        ],
        "moduleFileExtensions": [
            "ts",
            "tsx",
            "js",
            "json"
        ],
        "transform": {
            "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$"
    },
    "author": "CDMBase LLC",
    "license": "ISC",
    "devDependencies": {
        "cross-env": "^5.2.0",
        "jest": "^22.4.2",
        "rimraf": "^2.6.1",
        "webpack": "4.46.0"
    },
    "dependencies": {
    },
    "typings": "lib/index.d.ts",
    "typescript": {
        "definition": "lib/index.d.ts"
    }
}

```

# tools/templates/module/server/webpack.config.js

```js
var nodeExternals = require('webpack-node-externals');
var webpack = require('webpack');
var path = require('path');
var fs = require('fs');

var webpackOpts = {
  mode: 'development',
  entry: {
    index: './src/index.ts',
    plugin: './src/plugin/index.ts',
  },
  target: 'node',
  output: {
    path: path.join(__dirname, 'lib'),
    filename: '[name].js',
    libraryTarget: "commonjs2",
  },
  node: {
    __dirname: false
  },
  resolve: {
    extensions: ['.ts', '.tsx', '.graphql', '.gql'],
  },
  plugins: [
    new webpack.LoaderOptionsPlugin({
      options: {
        test: /\.tsx?$/,
        ts: {
          compiler: 'typescript',
          configFile: 'tsconfig.json'
        },
        tslint: {
          emitErrors: true,
          failOnHint: true
        }
      }
    })
  ],
  devtool: 'source-map',
  module: {
    rules: [{
      test: /\.tsx?$/,
      loaders: 'ts-loader'
    }, {
      test: /\.graphql?/,
      exclude: /node_modules/,
      use: 'raw-loader',
    }, {
      test: /\.(gql)$/,
      exclude: /node_modules/,
      use: ['graphql-tag/loader']
    }
    ]
  },
  externals: [
    nodeExternals({ modulesDir: "../../../node_modules" }),
    nodeExternals()
  ]
};

module.exports = webpackOpts;

```

# tools/templates/module/server/tsconfig.json

```json
{
  "extends": "../../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "rootDir": "./src",
    "outDir": "../lib",
    "declarationDir": "../lib",
    "typeRoots": [
      "../../../node_modules/@types"
    ],
    "skipLibCheck": true
  },
  "exclude": [
    "node_modules",
    "lib",
    "dist",
    "webpack.config.js"
  ]
}
```

# tools/templates/module/server/package.json

```json
{
    "name": "@adminide-stack/$module$-server",
    "version": "0.0.1",
    "description": "Sample core for higher packages to depend on",
    "main": "lib/index.js",
    "scripts": {
        "jest": "./node_modules/.bin/jest",
        "test": "cross-env ENV_FILE=../../config/test/test.env jest",
        "test:debug": "npm test -- --runInBand",
        "test:watch": "npm test -- --watch",
        "prepublish": "yarn build",
        "watch": "yarn build:lib:watch",
        "build": "yarn build:clean && yarn build:lib",
        "build:clean": "rimraf lib",
        "build:lib": "webpack",
        "build:lib:watch": "yarn build:lib -- --watch"
    },
    "jest": {
        "testEnvironment": "node",
        "roots": [
            "src"
        ],
        "modulePaths": [
            "node_modules"
        ],
        "moduleFileExtensions": [
            "ts",
            "tsx",
            "js",
            "json"
        ],
        "transform": {
            "\\.(ts|tsx)$": "<rootDir>/../../node_modules/ts-jest/preprocessor.js"
        },
        "testRegex": "/__tests__/.*test*\\.(ts|tsx|js)$"
    },
    "author": "CDMBase LLC",
    "license": "ISC",
    "devDependencies": {
        "apollo": "^2.9.0",
        "cross-env": "^5.2.0",
        "jest": "^22.4.2",
        "rimraf": "^2.6.1",
        "webpack": "4.46.0"
    },
    "typings": "lib/index.d.ts",
    "typescript": {
        "definition": "lib/index.d.ts"
    },
    "dependencies": {
    }
}

```

# servers/moleculer-server/src/modules/module.ts

```ts
import { ContainerModule, interfaces } from 'inversify';
import CounterModule from '@sample-stack/counter-module-server';
import { config } from '../config';
import { NATS_MOLECULER_COUNTER_SERIVCE } from '@sample-stack/counter-module-server';
import { Feature } from '@common-stack/server-core';


const subTopic = config.CONNECTION_ID; // version.topic.action

export const settings: any & { name: string } = {
    name: NATS_MOLECULER_COUNTER_SERIVCE,
    connectionId: config.CONNECTION_ID,
    namespace: config.NAMESPACE,
    subTopic,
    logger: config.LOG_LEVEL,
    workspaceId: config.CONNECTION_ID || 'DEFAULT',
    configPath: process.env.CONFIG_PATH,
};


const defaultModule =
    () => new ContainerModule((bind: interfaces.Bind) => {
        bind('Settings').toConstantValue(settings).whenTargetTagged('default', true);
        bind('Settings').toConstantValue(settings).whenTargetTagged('microservice', true);
        bind('MongoOptions').toConstantValue({});
    });

const DefaultFeature = new Feature({
    createContainerFunc: [defaultModule],
    createHemeraContainerFunc: [defaultModule],
});

export default new Feature(
    DefaultFeature,
    CounterModule,
);

```

# servers/moleculer-server/src/modules/index.ts

```ts
import modules, { settings } from './module';

export default modules;
export { settings };

```

# servers/moleculer-server/src/connectors/redis-connector.ts

```ts


import * as _ from 'lodash';
import { RedisClusterCache, RedisCache } from 'apollo-server-cache-redis';
import * as IORedis from 'ioredis';
import { logger } from '@cdm-logger/server';
import { config } from '../config';
import { CdmLogger } from '@cdm-logger/core';
type ILogger = CdmLogger.ILogger;

export class RedisConnector {


    private client: RedisClusterCache | RedisCache;
    private opts: IORedis.ClusterOptions | IORedis.RedisOptions;
    private logger: ILogger;

    /**
     * Creats an instance of Redis.
     *
     * @param {object} opts
     */
    constructor(opts?: IORedis.ClusterOptions | IORedis.RedisOptions) {
        this.opts = _.defaultsDeep(opts, {
            prefix: null,
        });
        this.logger = logger.child({ className: 'RedisConnector' });
    }

    /**
     * Connect to the server
     *
     * @memberof RedisConnector
     */
    public connect() {
        return new Promise((resolve, reject) => {
            reject('this method not implemented');
        });
    }


    /**
     * Return redis or redis.cluster Dataloader Client
     *
     * @memberof RedisConnection
     */
    public getRedisDataloaderClient() {
        let client: RedisClusterCache | RedisCache;
        if (config.REDIS_CLUSTER_ENABLED) {
            if (!config.REDIS_CLUSTER_URL) {
                throw new Error(`No nodes defined for cluster, ${config.REDIS_CLUSTER_URL}`);
            }
            this.logger.info('Setting Redis.Cluster connection');
            client = new RedisClusterCache(config.REDIS_CLUSTER_URL as any, this.opts);
        } else {
            this.logger.info('Setting Redis connection');
            client = new RedisCache(config.REDIS_URL as any || this.opts);
        }
        return client;
    }

    /**
     * Close Redis client connection.
     *
     * @memberof RedisConnection
     */
    public disconnect() {
        if (!this.client) {
            return;
        }
        return this.client.close();
    }
}

```

# servers/moleculer-server/src/connectors/nats-connector.ts

```ts
import * as nats from 'nats';
import * as _ from 'lodash';
import { logger } from '@cdm-logger/server';
import { CdmLogger } from '@cdm-logger/core';

type ILogger = CdmLogger.ILogger;

export class NatsConnector {
    private opts: nats.ClientOpts;

    private client: nats.Client;

    private logger: ILogger;

    private connected: boolean;

    constructor(opts: nats.ClientOpts) {
        this.opts = _.defaultsDeep(opts, {});
        this.logger = logger.child({ className: 'NatsConnector' });
    }

    /**
     * Connect to a NATS server
     *
     * @memberof NatsConnector
     */
    public connect() {
        if (this.client) {
            return this.client;
        }
        return new Promise<nats.Client>((resolve, reject) => {
            const client = nats.connect(this.opts);

            client.on('connect', () => {
                this.client = client;
                this.connected = true;
                this.logger.info('NATS client is connected.');
                resolve(client);
            });

            client.on('reconnect', () => {
                this.logger.info('NATS client is reconnected.');
                this.connected = true;
            });

            client.on('reconnecting', () => {
                this.logger.warn('NATS client is reconnecting...');
            });

            client.on('disconnect', () => {
                if (this.connected) {
                    this.logger.warn('NATS client is disconnected.');
                    this.connected = false;
                }
            });

            client.on('error', (e) => {
                this.logger.error('NATS error.', e.message);
                this.logger.debug(e);
                reject(e);
            });

            client.on('close', () => {
                this.logger.fatal('NATS connection close.');
            });
        });
    }

    /**
     * Disconnect from a NATS server
     *
     * @memberof NatsTransporter
     */
    public disconnect() {
        if (this.client) {
            this.client.flush(() => {
                this.client.close();
                this.client = null;
            });
        }
    }
}

```

# servers/moleculer-server/src/connectors/mongo-connector.ts

```ts
import { createConnection, connection, ConnectionOptions, Connection } from 'mongoose';
import * as _ from 'lodash';
import { Db } from 'mongodb';
import { logger } from '@cdm-logger/server';
import { CdmLogger } from '@cdm-logger/core';

type ILogger = CdmLogger.ILogger;

export class MongoConnector {
    private client: Connection;

    private db: Db;

    private opts: ConnectionOptions;

    private uri: string;

    private logger: ILogger;

    constructor(uri: string, opts?: ConnectionOptions) {
        this.opts = _.defaultsDeep(opts, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
        });
        this.uri = uri;
        this.logger = logger.child({ className: 'MongoConnector' });
    }

    /**
     * Connect to database
     *
     * @memberof MongoConnector
     */
    public async connect(): Promise<Connection> {
        if (this.client) {
            return this.client;
        }
        const conn = createConnection(this.uri, this.opts);

        conn.then((result) => {
            this.client = conn;

            if ((result as any).connection) {
                this.db = (result as any).conection.db;
            } else {
                this.db = result.db;
            }

            this.logger.info(' MongoDB has connected successfully.');

            this.db.on('disconnected', () => this.logger.warn('Mongoose has disconnected.'));
            this.db.on('error', (err) => this.logger.error('MongoDB error.', err));
            this.db.on('reconnect', () => this.logger.info('Mongoose has reconnected.'));
        });
        return conn;
    }

    /**
     * Disconnect from database
     *
     * @memberof MongoConnector
     */
    public async disconnect() {
        if (!this.client) {
            return;
        }
        if (this.db && (this.db as any).close) {
            await (this.db as any).close();
        }
        await connection.close();
    }
}

```

# servers/moleculer-server/src/connectors/graphql-pubsub-connector.ts

```ts
import { PubSub, PubSubEngine } from 'graphql-subscriptions';
import { NatsPubSub } from 'graphql-nats-subscriptions';
import { logger } from '@cdm-logger/server';
import { ClientOpts } from 'nats';
import { Transporter, GenericObject } from 'moleculer';
import { CdmLogger } from '@cdm-logger/core';
type ILogger = CdmLogger.ILogger;



type PubSubOptions = {
    apolloLogging?: boolean;
    logger: ILogger;
} & GenericObject;


export class GraphqlPubSubConnector {


    private client: PubSubEngine | NatsPubSub;
    private opts: PubSubOptions;
    private logger: ILogger;

    /**
     * Creates an instance of GraphqlPubSubConnector.
     * @param {*} opts
     * @memberof GraphqlPubSubConnector
     */
    constructor(opts?: PubSubOptions) {
        if (opts === undefined || opts.type === undefined) {
            this.opts = { ...opts, apolloLogging: true, type: 'TCP' };
        }
        this.opts = opts;
        this.logger = opts.logger.child({className: 'GraphqlPubSubConnector'});
    }

    public async getClient() {
        if (this.opts.type === 'TCP') {
            return this.client = new PubSub();
        } else if (this.opts.type === 'NATS') {
            // console.log('--this.copts', this.opts.client)
            const natsClient = await this.opts.client.connect();
            return this.client = new NatsPubSub({ client: natsClient, logger });
        } else {
            this.logger.warn('Did not defined known transporter [%s], return default pubsub', this.opts.type);
            return this.client = new PubSub();
        }
    }
}

```

# servers/moleculer-server/src/connectors/connection-broker.ts

```ts

import { MongoConnector } from './mongo-connector';
import { NatsConnector } from './nats-connector';
import { RedisConnector } from './redis-connector';
import { config } from '../config';
import { GraphqlPubSubConnector } from './graphql-pubsub-connector';
import { Transporter, GenericObject } from 'moleculer';
import { CdmLogger } from '@cdm-logger/core';
type ILogger = CdmLogger.ILogger;

/**
 *  Connection broker class
 *
 * @class ConnectionBroker
 */
export class ConnectionBroker {


    private _mongoConnector: MongoConnector;

    private _redisConnector: RedisConnector;

    private _natsConnector: NatsConnector;

    private _graphqlPubsubConnector: GraphqlPubSubConnector;

    /**
     * Creates an instance of ConnectionBroker.
     * @param {*} options
     * @memberof ConnectionBroker
     */
    constructor(transporter: string | GenericObject, logger: ILogger) {

        if (typeof transporter === 'string') {
            if (transporter === 'TCP') {
                this._graphqlPubsubConnector = new GraphqlPubSubConnector({ logger, type: 'TCP' });
            } else if (transporter === 'NATS') {
                this._natsConnector = new NatsConnector({});
                this._graphqlPubsubConnector = new GraphqlPubSubConnector({ logger, type: 'NATS', client: this._natsConnector});
            }
        } else {
            if (transporter.type === 'NATS') {
                this._natsConnector = new NatsConnector(transporter.options);
                this._graphqlPubsubConnector = new GraphqlPubSubConnector({ logger, ...transporter, client: this._natsConnector});
            }
        }

        this._mongoConnector = new MongoConnector(config.MONGO_URL as any);
        this._redisConnector = new RedisConnector(); // TODO pass constructor options
    }


    public get mongoConnection() {
        return this._mongoConnector.connect();
    }

    public get redisDataloaderClient() {
        return this._redisConnector.getRedisDataloaderClient();
    }

    public get natsConnection() {
        return this._natsConnector.connect();
    }

    public get graphqlPubsub() {
        return this._graphqlPubsubConnector.getClient();
    }

    public async stop() {
        this._mongoConnector && await this._mongoConnector.disconnect();
        this._redisConnector && await this._redisConnector.disconnect();
        this._natsConnector &&  await this._natsConnector.disconnect();
    }
}

```

# servers/moleculer-server/src/config/moleculer.config.ts

```ts
'use strict';
import { BrokerOptions, Errors } from 'moleculer';
import { config } from './config';

/**
 * Moleculer ServiceBroker configuration file
 *
 * More info about options:
 *         https://moleculer.services/docs/0.14/configuration.html
 *
 *
 * Overwrite options in production:
 * ================================
 * 	You can overwrite any option with environment variables.
 * 	For example to overwrite the 'logLevel', use `LOGLEVEL=warn` env var.
 * 	To overwrite a nested parameter, e.g. retryPolicy.retries, use `RETRYPOLICY_RETRIES=10` env var.
 *
 * 	To overwrite broker’s deeply nested default options, which are not presented in 'moleculer.config.ts',
 * 	via environment variables, use the `MOL_` prefix and double underscore `__` for nested properties in .env file.
 * 	For example, to set the cacher prefix to `MYCACHE`, you should declare an env var as `MOL_CACHER__OPTIONS__PREFIX=MYCACHE`.
 */
const brokerConfig: BrokerOptions = {
    // Namespace of nodes to segment your nodes on the same network.
    namespace: config.NAMESPACE,
    // namespace: null,
    // Unique node identifier. Must be unique in a namespace.
    // nodeID: config.CONNECTION_ID,


    // Enable/disable logging or use custom logger. More info: https://moleculer.services/docs/0.14/logging.html
    // Available logger types: 'Console', 'File', 'Pino', 'Winston', 'Bunyan', 'debug', 'Log4js', 'Datadog'
    logger: {
        type: 'Console',
        options: {
            // Using colors on the output
            colors: true,
            // Print module names with different colors (like docker-compose for containers)
            moduleColors: false,
            // Line formatter. It can be 'json', 'short', 
            // 'simple', 'full', a `Function` or a template string like '{timestamp} {level} {nodeID}/{mod}: {msg}'
            formatter: 'full',
            // Custom object printer. If not defined, it uses the `util.inspect` method.
            objectPrinter: null,
            // Auto-padding the module name in order to messages begin at the same column.
            autoPadding: false,
        },
    },
    // Default log level for built-in console logger. It can be overwritten in logger options above.
    // Available values: trace, debug, info, warn, error, fatal
    logLevel: config.LOG_LEVEL as any,

    // Define transporter.
    // More info: https://moleculer.services/docs/0.14/networking.html
    // Note: During the development, you don't need to define it because all services will be loaded locally.
    // In production you can set it via `TRANSPORTER=nats://localhost:4222` environment variable.
    transporter: (config.NODE_ENV === 'development') ? 'TCP' : {
        type: 'NATS',
        options: {
            url: config.NATS_URL,
            user: config.NATS_USER,
            pass: config.NATS_PW,
            reconnectTimeWait: 1000,
        },
    },

    // Define a cacher.
    // More info: https://moleculer.services/docs/0.14/caching.html
    // cacher: {
    //     type: 'Redis',
    //     enabled: false,
    //     options: {

    //         // Redis settings
    //         redis: {

    //         }
    //     }
    // },

    // Define a serializer.
    // Available values: 'JSON', 'Avro', 'ProtoBuf', 'MsgPack', 'Notepack', 'Thrift'.
    // More info: https://moleculer.services/docs/0.13/networking.html
    serializer: 'JSON',

    // Number of milliseconds to wait before reject a request with a RequestTimeout error. Disabled: 0
    requestTimeout: 10 * 1000,

    // Retry policy settings. More info: https://moleculer.services/docs/0.13/fault-tolerance.html#Retry
    retryPolicy: {
        // Enable feature
        enabled: false,
        // Count of retries
        retries: 5,
        // First delay in milliseconds.
        delay: 100,
        // Maximum delay in milliseconds.
        maxDelay: 1000,
        // Backoff factor for delay. 2 means exponential backoff.
        factor: 2,
        // A function to check failed requests.
        check: (err: Errors.MoleculerRetryableError) => err && !!err.retryable,
    },

    // Limit of calling level. If it reaches the limit, broker will throw an MaxCallLevelError error. (Infinite loop protection)
    maxCallLevel: 100,

    // Number of seconds to send heartbeat packet to other nodes.
    heartbeatInterval: 5,
    // Number of seconds to wait before setting node to unavailable status.
    heartbeatTimeout: 15,

    // tslint:disable-next-line:max-line-length
    // Tracking requests and waiting for running requests before shutdowning. More info: https://moleculer.services/docs/0.13/fault-tolerance.html
    tracking: {
        // Enable feature
        enabled: false,
        // Number of milliseconds to wait before shutdowning the process
        shutdownTimeout: 5000,
    },

    // Disable built-in request & emit balancer. (Transporter must support it, as well.)
    disableBalancer: false,

    // Settings of Service Registry. More info: https://moleculer.services/docs/0.14/registry.html
    registry: {
        // Define balancing strategy. More info: https://moleculer.services/docs/0.14/balancing.html
        // Available values: 'RoundRobin', 'Random', 'CpuUsage', 'Latency'
        strategy: 'RoundRobin',
        // Enable local action call preferring.
        preferLocal: true,
    },

    // Settings of Circuit Breaker. More info: https://moleculer.services/docs/0.14/fault-tolerance.html#Circuit-Breaker
    circuitBreaker: {
        // Enable feature
        enabled: false,
        // Threshold value. 0.5 means that 50% should be failed for tripping.
        threshold: 0.5,
        // Minimum request count. Below it, CB does not trip.
        minRequestCount: 20,
        // Number of seconds for time window.
        windowTime: 60,
        // Number of milliseconds to switch from open to half-open state
        halfOpenTime: 10 * 1000,
        // A function to check failed requests.
        check: (err: Errors.MoleculerRetryableError) => err && err.code >= 500,
    },

    // Settings of bulkhead feature. More info: https://moleculer.services/docs/0.14/fault-tolerance.html#Bulkhead
    bulkhead: {
        // Enable feature.
        enabled: false,
        // Maximum concurrent executions.
        concurrency: 10,
        // Maximum size of queue
        maxQueueSize: 100,
    },

    // Enable action & event parameter validation. More info: https://moleculer.services/docs/0.14/validating.html
    validator: true,

    errorHandler: null,

    // Enable/disable built-in metrics function. More info: https://moleculer.services/docs/0.14/metrics.html
    metrics: {
        enabled: false,
        // Available built-in reporters: 'Console', 'CSV', 'Event', 'Prometheus', 'Datadog', 'StatsD'
        reporter: {
            type: 'Prometheus',
            options: {
                // HTTP port
                port: 3030,
                // HTTP URL path
                path: '/metrics',
                // Default labels which are appended to all metrics labels
                defaultLabels: registry => ({
                    namespace: registry.broker.namespace,
                    nodeID: registry.broker.nodeID,
                }),
            },
        },
    },

    // Enable built-in tracing function. More info: https://moleculer.services/docs/0.14/tracing.html
    tracing: {
        enabled: true,
        // Available built-in exporters: 'Console', 'Datadog', 'Event', 'EventLegacy', 'Jaeger', 'Zipkin'
        exporter: {
            type: 'Console', // Console exporter is only for development!
            options: {
                // Custom logger
                logger: null,
                // Using colors
                colors: true,
                // Width of row
                width: 100,
                // Gauge width in the row
                gaugeWidth: 40,
            },
        },
    },

    // Register internal services ('$node'). More info: https://moleculer.services/docs/0.13/services.html#Internal-services
    internalServices: true,
    // Register internal middlewares. More info: https://moleculer.services/docs/0.13/middlewares.html#Internal-middlewares
    internalMiddlewares: true,

    // Watch the loaded services and hot reload if they changed. 
    // You can also enable it in Moleculer Runner with `--hot` argument
    hotReload: false,

    // Register custom middlewares
    middlewares: [],

    // Called after broker created.
    created(broker) {

    },

    // Called after broker starte.
    started(broker) {

    },

    // Called after broker stopped.
    stopped(broker) {

    },

    // Register custom REPL commands.
    replCommands: null,
};

export = brokerConfig;

```

# servers/moleculer-server/src/config/index.ts

```ts
export * from './config';

```

# servers/moleculer-server/src/config/config.ts

```ts
import * as envalid from 'envalid';
process.env.ENV_FILE !== null && (require('dotenv')).config({ path: process.env.ENV_FILE });


const { str, bool, json } = envalid;

export const config = envalid.cleanEnv(process.env, {
    NODE_ENV: str({ default: 'production', choices: ['production', 'staging', 'development', 'test'] }),
    NATS_URL: str(),
    NATS_USER: str(),
    NATS_PW: str(),
    MONGO_URL: str(),
    REDIS_CLUSTER_URL: json({devDefault: '[{"port":6379,"host":"localhost"}]',  example: '[{"port":6379,"host":"localhost"}]'}),
    REDIS_URL: str({ devDefault: 'localhost' }),
    REDIS_CLUSTER_ENABLED: bool({ devDefault: false }),
    REDIS_SENTINEL_ENABLED: bool({ devDefault: true }),
    CONNECTION_ID: str({devDefault: 'CONNECTION_ID'}),
    NAMESPACE: str({default: 'default'}),
    LOG_LEVEL: str({ default: 'info', choices: ['info', 'debug', 'trace'] }),
});


```

# servers/moleculer-server/charts/chart/values.yaml

```yaml
# Default values for node.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
replicaCount: 1
image:
  pullPolicy: IfNotPresent
service:
  name: node
  type: ClusterIP
  externalPort: 8080
  internalPort: 8080
resources:
  limits:
    cpu: 100m
    memory: 128Mi
  requests:
    cpu: 100m
    memory: 128Mi
ingress:
  enabled: false
env:
  CONNECTION_ID: v1
  BRIGADE_PROJECT_ID: "brigade-fc500e5f406ddcff3c0cc1e1e39ecfe605e4c1e34d45b36ce15d6c"
  LOG_LEVEL: info
  HEMERA_LOG_LEVEL: info
external:
  name: idestack
  service: 
    mongodb:
      generateEnv: true
      enabled: false
      serviceName: mongo-ha-mongodb-replicaset.main-system.svc.cluster.local
      port: 27017
      dbname: idestack
    nats:
      generateEnv: true
      enabled: false
      serviceName: microstack-nats-stable-client.main-system.svc.cluster.local
      user: ruser
      password: "T0pS3cr3t"
      port: 4222
    zipkin:
      generateEnv: true
      enabled: false
      serviceName: microstack-zipkin.main-system.svc.cluster.local
      port: 9411
    redis:
      generateEnv: true
      enabled: false
      serviceName: microstack-redis-ha-haproxy.main-system.svc.cluster.local
      port: 6379

```

# servers/moleculer-server/charts/chart/values-stage.yaml

This is a binary file of the type: Binary

# servers/moleculer-server/charts/chart/values-prod.yaml

This is a binary file of the type: Binary

# servers/moleculer-server/charts/chart/values-dev.yaml

This is a binary file of the type: Binary

# servers/moleculer-server/charts/chart/Chart.yaml

```yaml
apiVersion: v1
description: A Helm chart for Kubernetes
name: moleculer-server
version: v0.1.2

```

# servers/moleculer-server/charts/chart/.helmignore

```
# Patterns to ignore when building packages.
# This supports shell glob matching, relative path matching, and
# negation (prefixed with !). Only one pattern per line.
.DS_Store
# Common VCS dirs
.git/
.gitignore
.bzr/
.bzrignore
.hg/
.hgignore
.svn/
# Common backup files
*.swp
*.bak
*.tmp
*~
# Various IDEs
.project
.idea/
*.tmproj

```

# servers/frontend-server/src/modules/module.tsx

```tsx
import * as React from 'react';
import { Layout } from 'antd';
import counterModules from '@sample-stack/counter-module-browser';
import { Feature, FeatureWithRouterFactory } from '@common-stack/client-react';

import { SiderMenu } from './layout';

const features = new Feature(FeatureWithRouterFactory, counterModules);

console.log(features.getMenus());

export const MainRoute = props => (
    <Layout hasSider={true} style={{ minHeight: '100vh', display: 'flex' }}>
        <SiderMenu
            collapsed={false}
            menuData={features.getMenus()}
            location={window.location as any}
            segments={features.sidebarSegments}
        />
        <Layout>
            <Layout.Content style={{height: '100%'}}>
                <section className="flex-grow" style={{height: '100%'}}>
                    {features.getRoutes()}
                </section>
            </Layout.Content>
        </Layout>
    </Layout>
);

export default features;

```

# servers/frontend-server/src/modules/index.ts

```ts
import '../config/public-config';
import { ClientLogger } from '@cdm-logger/client';
import { ClientTypes } from '@common-stack/client-react';
import modules, { MainRoute } from './module';

class UtilityClass {
    // tslint:disable-next-line:no-shadowed-variable
    constructor(private modules) {}

    public getCacheKey(storeObj) {
        return this.modules.getDataIdFromObject(storeObj);
    }
}

const utility = new UtilityClass(modules);

const logger = ClientLogger.create(process.env.APP_NAME || 'Fullstack-Pro', {
    level: (process.env.LOG_LEVEL as any) || 'info',
});
// additional bindings to container
const container = modules.createContainers({}) as any;
container.bind(ClientTypes.Logger).toConstantValue(logger);
container.bind(ClientTypes.UtilityClass).toConstantValue(utility);

export default modules;
export { MainRoute, container, logger };

```

# servers/frontend-server/src/config/router-history.ts

```ts
import { createBrowserHistory, createMemoryHistory } from 'history';

if (__CLIENT__) {
    module.exports = createBrowserHistory();
} else {
    module.exports = (url) =>
        createMemoryHistory({
            initialEntries: [url],
        });
}

```

# servers/frontend-server/src/config/redux-config.ts

```ts
/* eslint-disable no-param-reassign */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable global-require */
import storage from 'redux-persist/lib/storage';
import { combineReducers } from 'redux';
import autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2';
import { createEpicMiddleware } from 'redux-observable';
import { connectRouter, routerMiddleware } from 'connected-react-router';
import { persistReducer } from 'redux-persist';
import thunkMiddleware from 'redux-thunk';
import { createReduxStore as createBaseReduxStore } from './base-redux-config';
import modules, { logger } from '../modules';
import { createClientContainer } from './client.service';
import { rootEpic, epic$ } from './epic-config';

const history = require('./router-history');

const { apolloClient, container, services } = createClientContainer();

export const epicMiddleware = createEpicMiddleware({
    dependencies: {
        apolloClient,
        routes: modules.getConfiguredRoutes(),
        services,
        container,
        logger,
    },
});

export const persistConfig = {
    key: 'root',
    storage,
    stateReconciler: autoMergeLevel2,
    transforms: modules.reduxPersistStateTransformers,
};

export const storeReducer = (hist) =>
    combineReducers({
        router: connectRouter(hist),
        ...modules.reducers,
    });

/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = (url = '/') => {
    // only in server side, url will be passed.
    const newHistory = __CLIENT__ ? history : history(url);
    // middleware
    const router = connectRouter(newHistory);

    let store;
    if ((module as any).hot && (module as any).hot.data && (module as any).hot.data.store) {
        // console.log('Restoring Redux store:', JSON.stringify((module as any).hot.data.store.getState()));
        store = (module as any).hot.data.store;
        // replace the reducers always as we don't have ablity to find
        // new reducer added through our `modules`
        store.replaceReducer(
            persistReducer(persistConfig, storeReducer((module as any).hot.data.history || newHistory)),
        );
        // store.replaceReducer(storeReducer((module as any).hot.data.history || history));
    } else {
        // If we have preloaded state, save it.
        const initialState = __CLIENT__
            ? { ...window.__PRELOADED_STATE__ } // #952 TODO we need cookie to have id_token for SSR to work properly
            : {};
        // Delete it once we have it stored in a variable
        if (__CLIENT__) {
            delete window.__PRELOADED_STATE__;
        }
        store = createBaseReduxStore({
            scope: __CLIENT__ ? 'browser' : 'server',
            isDebug: true,
            isDev: process.env.NODE_ENV === 'development',
            initialState,
            persistConfig,
            middleware: [thunkMiddleware, routerMiddleware(newHistory)],
            epicMiddleware,
            rootEpic: rootEpic as any,
            reducers: { router, ...modules.reducers },
        });
    }
    if ((module as any).hot) {
        (module as any).hot.dispose((data) => {
            // console.log("Saving Redux store:", JSON.stringify(store.getState()));
            data.store = store;
            data.history = history;
        });
        (module as any).hot.accept('../config/epic-config', () => {
            // we may need to reload epic always as we don't
            // know whether it is updated using our `modules`
            const nextRootEpic = require('./epic-config').rootEpic;
            // First kill any running epics
            store.dispatch({ type: 'EPIC_END' });
            // Now setup the new one
            epic$.next(nextRootEpic);
        });
    }
    container.bind('ReduxStore').toConstantValue(store);
    return { store, history };
};

```

# servers/frontend-server/src/config/public-config.ts

```ts
/// <reference path='../../../../typings/index.d.ts' />
import { logger } from '@cdm-logger/client';
import { lowerCase } from 'lodash';

/**
 * This file opens up in public site, so make sure it is
 * not dependent on any other file that compromises the security.
 */
const publicEnv = [
    'NODE_ENV',
    'GRAPHQL_URL',
    'FACEBOOK_APP_ID',
    'GA_ID',
    'LOG_LEVEL',
];

const isBrowser = typeof window !== 'undefined';
const base = (isBrowser ? ( window.__ENV__ || __ENV__) : process.env) || {};

const env: any = {};
for (const v of publicEnv) {
    env[v] = base[v];
}

export default env;

if (isBrowser) {
    process[lowerCase('env')] = env; // to avoid webpack to replace `process` with actual value.
    process.APP_ENV = env;
}

try {
    global.process = process;
    logger.info('Process Update Success!');
} catch (e) {
    logger.warn(e);
    logger.info('Encountered above issue while running "global.process = process", will automatically try again in next render');

}
export const PUBLIC_SETTINGS: __PUBLIC_SETTINGS__ = {
    apolloLogging: false,
    GRAPHQL_URL: process.env.GRAPHQL_URL || env.GRAPHQL_URL || __GRAPHQL_URL__,
    LOCAL_GRAPHQL_URL: process.env.LOCAL_GRAPHQL_URL || __GRAPHQL_URL__,
    LOG_LEVEL: process.env.LOG_LEVEL || 'trace',
};

```

# servers/frontend-server/src/config/index.ts

```ts
export * from './config';

```

# servers/frontend-server/src/config/fela-renderer.ts

```ts
import { createRenderer, IRenderer } from 'fela';
import webPreset from 'fela-preset-web';

export default () => {
  const renderer = createRenderer({
    plugins: [
      ...webPreset,
    ],
    devMode: process.env.NODE_ENV ? process.env.NODE_ENV !== 'production' : false,
  });
  renderer.renderStatic(
    `
        html, body, #demo, .content{
            height: 100%;
          }
          body {
            background-color: #fff;
            color: #ccc;
            padding: 0;
            margin: 0;
            font-family: sans-serif;
            font-size: 13px;
          }
          div, a {
            outline: none !important;
          }
          a {
            text-decoration: none;
            cursor: pointer;
          }
          footer {
            position:fixed;
            bottom: 0;
            left: 0;
            right:0;
            height: 20px;
            background: #007acc;
          }
          footer > .container {
            padding: 2px;
          }
          #content {
            height: calc(100vh - 20px);
          }
          #container {
            height: 100%;
          }
          .editor-container {
            height: 100%;
            overflow: hidden;
          }
          .error {
            color: orangered;
          }
        `,
  );

  return renderer;
};


```

# servers/frontend-server/src/config/epic-config.ts

```ts
import { combineEpics, ofType } from 'redux-observable';
import { BehaviorSubject } from 'rxjs';
import { mergeMap, takeUntil } from 'rxjs/operators';
import modules from '../modules';

export const epic$ = new BehaviorSubject(combineEpics(...modules.epics));

// Since we're using mergeMap, by default any new
// epic that comes in will be merged into the previous
// one, unless an EPIC_END action is dispatched first,
// which would cause the old one(s) to be unsubscribed
export const rootEpic = (action$, ...rest) =>
    epic$.pipe(mergeMap((epic) => epic(action$, ...rest).pipe(takeUntil(action$.pipe(ofType('EPIC_END'))))));

```

# servers/frontend-server/src/config/config.ts

```ts
import * as envalid from 'envalid';

const { str, bool, num } = envalid;

export const config = envalid.cleanEnv(process.env, {
    NODE_ENV: str({ default: 'production', choices: ['production', 'staging', 'development', 'test'] }),
    BACKEND_URL: str({ devDefault: __BACKEND_URL__ }),
    LOCAL_BACKEND_URL: str({ devDefault: __BACKEND_URL__ }),
    LOCAL_GRAPHQL_URL: str({ default: __GRAPHQL_URL__ }),
    GRAPHQL_URL: str({ devDefault: __GRAPHQL_URL__ }),
    LOG_LEVEL: str({ devDefault: 'trace' }),
    APP_NAME: str({ devDefault: 'FullStack' }),
    CLIENT_URL: str({ devDefault: __BACKEND_URL__ }),
    CONNECTION_ID: str({ devDefault: 'CONNECTION_ID' }),
    NAMESPACE: str({ default: 'default' }),
});

```

# servers/frontend-server/src/config/client.service.ts

```ts
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable import/no-extraneous-dependencies */
import { ClientTypes } from '@common-stack/client-core';
import { Container } from 'inversify';
import { ApolloClient } from '@apollo/client';
import { CdmLogger } from '@cdm-logger/core';
import modules, { container, logger } from '../modules';
import { createApolloClient } from './base-apollo-client';
import { PUBLIC_SETTINGS } from './public-config';

let __CLIENT_SERVICE__: {
    apolloClient: ApolloClient<any>;
    container: Container;
    services: any;
    logger: CdmLogger.ILogger;
};
export const createClientContainer = () => {
    if (__CLIENT_SERVICE__) {
        return __CLIENT_SERVICE__;
    }
    const clientState = modules.getStateParams({ resolverContex: () => modules.createService({}, {}) });
    const { cache, apolloClient } = createApolloClient({
        httpGraphqlURL: PUBLIC_SETTINGS.GRAPHQL_URL,
        httpLocalGraphqlURL: PUBLIC_SETTINGS.LOCAL_GRAPHQL_URL,
        isDev: process.env.NODE_ENV === 'development',
        isDebug: __DEBUGGING__,
        isSSR: __SSR__,
        scope: __CLIENT__ ? 'browser' : 'server',
        clientState,
        getDataIdFromObject: (result) => modules.getDataIdFromObject(result),
        initialState: null,
        logger,
    });
    // attaching the context to client as a workaround.
    container.bind(ClientTypes.ApolloClient).toConstantValue(apolloClient);
    container.bind(ClientTypes.InMemoryCache).toConstantValue(cache);
    const services = modules.createService({}, {});
    (apolloClient as any).container = services;

    __CLIENT_SERVICE__ = {
        container,
        apolloClient,
        services,
        logger,
    };
    if ((module as any).hot) {
        (module as any).hot.dispose(() => {
            // Force Apollo to fetch the latest data from the server
            delete window.__APOLLO_STATE__;
        });
    }
    return __CLIENT_SERVICE__;
};

```

# servers/frontend-server/src/config/base-redux-config.ts

```ts
// version 11/12/2021
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable global-require */
/* eslint-disable no-underscore-dangle */
import {
    createStore,
    combineReducers,
    applyMiddleware,
    StoreEnhancer,
    Middleware,
    compose,
    Action,
    ReducersMapObject,
    PreloadedState,
} from 'redux';
import { EpicMiddleware, Epic } from 'redux-observable';
import { persistReducer, PersistConfig } from 'redux-persist';

interface IReduxStore<S = any> {
    scope: 'browser' | 'server' | 'native' | 'ElectronMain';
    isDebug: boolean;
    isDev: boolean;
    reducers: ReducersMapObject<S>;
    rootEpic?: Epic<Action<S>, Action<any>, void, any>;
    epicMiddleware?: EpicMiddleware<Action<S>, Action<any>>;
    preMiddleware?: Middleware[];
    postMiddleware?: Middleware[];
    middleware?: Middleware[];
    initialState: PreloadedState<S>;
    persistConfig?: PersistConfig<S, any>;
}
/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = ({
    scope,
    isDebug,
    isDev,
    reducers,
    rootEpic,
    epicMiddleware,
    preMiddleware,
    postMiddleware,
    middleware,
    initialState = {},
    persistConfig,
}: IReduxStore<any>) => {
    const isBrowser = scope === 'browser';
    const isElectronMain = scope === 'ElectronMain';
    /**
     * Add middleware that required for this app.
     */

    const middlewares: Middleware[] = [];
    // add epicMiddleware
    if (epicMiddleware) {
        middlewares.push(epicMiddleware);
    }
    if (preMiddleware) {
        middlewares.unshift(...preMiddleware);
    }
    // Add redux logger during development only
    if ((isDev || isDebug) && isBrowser) {
        const { createLogger } = require('redux-logger');

        middlewares.push(
            createLogger({
                level: 'info',
                collapsed: true,
            }),
        );
    }

    if (middleware) {
        middlewares.push(...middleware);
    }

    if (postMiddleware) {
        middlewares.push(...postMiddleware);
    }

    const enhancers: () => StoreEnhancer<any>[] = () => [applyMiddleware(...middlewares)];

    const composeEnhancers: any =
        ((isDev || isDebug) && isBrowser && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) || compose;

    const rootReducer = combineReducers(reducers);
    const persistedReducer = persistConfig ? persistReducer(persistConfig, rootReducer) : rootReducer;

    const store = createStore(persistedReducer, initialState, composeEnhancers(...enhancers()));
    if (isBrowser || isElectronMain) {
        // no SSR for now
        if (epicMiddleware) {
            epicMiddleware.run(rootEpic);
        }
    }

    return store;
};

```

# servers/frontend-server/src/config/base-apollo-client.ts

```ts
// version 09/18/2021
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
import { ApolloClient, ApolloClientOptions, ApolloLink } from '@apollo/client';
import { InMemoryCache } from '@apollo/client/cache';
import { HttpLink, createHttpLink } from '@apollo/client/link/http';
import { BatchHttpLink } from '@apollo/client/link/batch-http';
import { onError } from '@apollo/client/link/error';
import { WebSocketLink } from '@apollo/client/link/ws';
import { getOperationAST } from 'graphql';
import { invariant } from 'ts-invariant';
import { IClientState } from '@common-stack/client-core';
import fetch from 'node-fetch';
import { ConnectionParams } from 'subscriptions-transport-ws';
import { isBoolean, merge } from 'lodash';
import { CdmLogger } from '@cdm-logger/core';
import { RetryLink } from '@apollo/client/link/retry';

const schema = `

`;

interface IApolloClientParams {
    initialState?: any;
    scope: 'browser' | 'server' | 'native';
    getDataIdFromObject: (x?: any) => string;
    clientState: IClientState;
    isDebug: boolean;
    isDev: boolean;
    isSSR: boolean;
    httpGraphqlURL: string;
    httpLocalGraphqlURL: string;
    logger: CdmLogger.ILogger;
}

const errorLink = onError(({ graphQLErrors, networkError }) => {
    if (graphQLErrors) {
        graphQLErrors.map(({ message, locations, path }) =>
            // tslint:disable-next-line
            invariant.warn(`[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`),
        );
    }
    if (networkError) {
        // tslint:disable-next-line
        invariant.warn(`[Network error]: ${networkError}`);
    }
});

let _apolloClient: ApolloClient<any>;
let _memoryCache: InMemoryCache;
export const createApolloClient = ({
    scope,
    isDev,
    isDebug,
    isSSR,
    getDataIdFromObject,
    clientState,
    httpGraphqlURL,
    httpLocalGraphqlURL,
    initialState,
    logger,
}: IApolloClientParams) => {
    const isBrowser = scope === 'browser';
    const isServer = scope === 'server';
    let link;

    const cache = new InMemoryCache({
        dataIdFromObject: getDataIdFromObject,
        possibleTypes: clientState.possibleTypes,
    });

    const attemptConditions = async (count: number, operation: any, error: Error) => {
        const promises = (clientState.retryLinkAttemptFuncs || []).map((func) => func(count, operation, error));

        try {
            const result = await promises;
            return !!result.find((item) => item && isBoolean(item));
        } catch (e) {
            logger.trace('Error occured in retryLink Attempt condition', e);
            throw e;
        }
    };

    const retrylink = new RetryLink({
        attempts: attemptConditions,
    });

    if (_apolloClient && _memoryCache) {
        // return quickly if client is already created.
        return {
            apolloClient: _apolloClient,
            cache: _memoryCache,
        };
    }
    _memoryCache = cache;
    if (isBrowser) {
        const connectionParams = async () => {
            const param: ConnectionParams = {};
            for (const connectionParam of clientState.connectionParams) {
                merge(param, await connectionParam);
            }
            return param;
        };

        const wsLink = new WebSocketLink({
            uri: httpGraphqlURL.replace(/^http/, 'ws'),
            options: {
                reconnect: true,
                timeout: 20000,
                reconnectionAttempts: 10,
                lazy: true,
                connectionParams,
                connectionCallback: async (error, result) => {
                    if (error) {
                        logger.error(error, '[WS connectionCallback error] %j');
                    }
                    const promises = (clientState.connectionCallbackFuncs || []).map((func) =>
                        func(wsLink, error, result),
                    );
                    try {
                        await promises;
                    } catch (e) {
                        logger.trace('Error occured in connectionCallback condition', e);
                        throw e;
                    }
                },
            },
            inactivityTimeout: 10000,
        });

        link = ApolloLink.split(
            ({ query, operationName }) => {
                if (operationName.endsWith('_WS')) {
                    return true;
                }
                const operationAST = getOperationAST(query as any, operationName);
                return !!operationAST && operationAST.operation === 'subscription';
            },
            wsLink,
            new HttpLink({
                uri: httpGraphqlURL,
            }),
        );
    } else if (isServer) {
        link = new BatchHttpLink({ uri: httpLocalGraphqlURL, fetch: fetch as any });
    } else {
        link = createHttpLink({ uri: httpLocalGraphqlURL, fetch: fetch as any });
    }

    const links = [errorLink, retrylink, ...(clientState.preLinks || []), link];

    // Add apollo logger during development only
    if (isBrowser && (isDev || isDebug)) {
        const apolloLogger = require('apollo-link-logger');
        links.unshift(apolloLogger.default);
    }

    const params: ApolloClientOptions<any> = {
        queryDeduplication: true,
        typeDefs: schema.concat(<string>clientState.typeDefs),
        resolvers: clientState.resolvers as any,
        link: ApolloLink.from(links),
        cache,
        connectToDevTools: isBrowser && (isDev || isDebug),
    };
    if (isSSR) {
        if (isBrowser) {
            if (initialState) {
                cache.restore(initialState);
            }
            params.ssrForceFetchDelay = 100;
        } else if (isServer) {
            params.ssrMode = true;
        }
    }
    _apolloClient = new ApolloClient<any>(params);

    clientState?.defaults?.forEach((x) => {
        if (x.type === 'query') {
            cache.writeQuery(x);
        } else if (x.type === 'fragment') {
            cache.writeFragment(x);
        }
    });

    return { apolloClient: _apolloClient, cache };
};

```

# servers/frontend-server/src/backend/website.tsx

```tsx
import * as React from 'react';
import * as ReactDOMServer from 'react-dom/server';
import { ApolloProvider } from '@apollo/client';
import { getDataFromTree } from '@apollo/client/react/ssr';
import { Html } from './ssr/html';
import Helmet from 'react-helmet';
import path from 'path';
import fs from 'fs';
import { renderToMarkup, renderToSheetList } from 'fela-dom';
import { Provider as ReduxProvider } from 'react-redux';
import { StaticRouter } from 'react-router';
import { logger } from '@cdm-logger/server';
import { createClientContainer } from '../config/client.service';
import * as ReactFela from 'react-fela';
import createRenderer from '../config/fela-renderer';
import { createReduxStore } from '../config/redux-config';
import publicEnv from '../config/public-config';
import clientModules from '../modules';

let assetMap;
async function renderServerSide(req, res) {
    try {

        const { apolloClient: client } = createClientContainer();

        let context: { pageNotFound?: boolean, url?: string } = { pageNotFound: false };
        const { store } = createReduxStore();
        const renderer = createRenderer();
        const App = () =>
            clientModules.getWrappedRoot(
                // tslint:disable-next-line:jsx-wrap-multiline
                <ReduxProvider store={store} >
                    <ApolloProvider client={client}>
                        <ReactFela.Provider renderer={renderer} >
                            <StaticRouter location={req.url} context={context}>
                                {clientModules.getRouter()}
                            </StaticRouter>
                        </ReactFela.Provider>
                    </ApolloProvider>
                </ReduxProvider>,
                req,
            );

        await getDataFromTree(App);
        if (context.pageNotFound === true) {
            res.status(404);
        } else {
            res.status(200);
        }

        const html = ReactDOMServer.renderToString(App as any);

        // this comes after Html render otherwise we don't see fela rules generated
        const appStyles = renderToSheetList(renderer);

        // We need to tell Helmet to compute the right meta tags, title, and such.
        const helmet = Helmet.renderStatic(); // Avoid memory leak while tracking mounted instances

        if (context.url) {
            res.writeHead(301, { Location: context.url });
            res.end();
        } else {
            if (__DEV__ || !assetMap) {
                assetMap = JSON.parse(fs.readFileSync(path.join(__FRONTEND_BUILD_DIR__, 'web', 'assets.json')).toString());
            }
            const apolloState = Object.assign({}, client.extract());
            const reduxState = Object.assign({}, store.getState());
            const env = {
                ...publicEnv,
            };
            const page = (
                <Html
                    content={html}
                    state={apolloState}
                    assetMap={assetMap}
                    helmet={helmet}
                    styleSheet={appStyles}
                    env={env}
                    reduxState={reduxState}
                />
            );
            res.send(`<!doctype html>\n${ReactDOMServer.renderToStaticMarkup(page)}`);
            res.end();
        }
    } catch (err) {
        logger.error('SERVER SIDE RENDER failed due to (%j) ', err.message);
        logger.debug(err);
    }
}
export const websiteMiddleware = async (req, res, next) => {
    try {
        if (req.path.indexOf('.') < 0 && __SSR__) {
            return await renderServerSide(req, res);
        } else if (req.path.indexOf('.') < 0 && !__SSR__ && req.method === 'GET' && !__DEV__) {
            logger.debug('FRONEND_BUILD_DIR with index.html')
            res.sendFile(path.resolve(__FRONTEND_BUILD_DIR__, 'index.html'));
        } else {
            next();
        }
    } catch (e) {
        logger.error('RENDERING ERROR:', e);
        return next(e);
    }
};

```

# servers/frontend-server/src/backend/server.ts

```ts
import 'reflect-metadata';
import express from 'express';
import * as bodyParser from 'body-parser';
import * as http from 'http';
import * as path from 'path';
import * as url from 'url';
import 'isomorphic-fetch';
import { logger } from '@cdm-logger/server';
import { websiteMiddleware } from './website';
import { corsMiddleware } from './middlewares/cors';
import { errorMiddleware } from './middlewares/error';
import { config } from '../config';
const cookiesMiddleware = require('universal-cookie-express');
import modules from './modules';

let server;

const app = express();


app.use(corsMiddleware);
app.options('*', corsMiddleware);

for (const applyBeforeware of modules.beforewares) {
    applyBeforeware(app);
}

app.use(cookiesMiddleware());


// By default it uses backend_url port, which may conflict with graphql server.
const { port: serverPort } = url.parse(config.LOCAL_BACKEND_URL);

// Don't rate limit heroku
app.enable('trust proxy');

app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());

app.use(
    '/',
    express.static(path.join(__FRONTEND_BUILD_DIR__, 'web'), {
        maxAge: '180 days',
    }),
);


if (__DEV__) {
    app.use('/', express.static(__DLL_BUILD_DIR__, { maxAge: '180 days' }));
}

app.use(websiteMiddleware);

if (__DEV__) {
    app.use(errorMiddleware);
}

server = http.createServer(app);

server.listen(serverPort, () => {
    logger.info(`Client Server is now running on port ${serverPort}`);
});

server.on('close', () => {
    server = undefined;
});

if ((module as any).hot) {
    (module as any).hot.dispose(() => {
        try {
            if (server) {
                server.close();
            }
        } catch (error) {
            logger.error(error.stack);
        }
    });
    (module as any).hot.accept(['./website'], () => {
        logger.debug('...reloading middleware');
    });

    (module as any).hot.accept();
}


export default server;

```

# servers/frontend-server/src/backend/app.ts

```ts
// tslint:disable-next-line:no-unused-expression
process.env.ENV_FILE !== null && (require('dotenv')).config({ path: process.env.ENV_FILE });

import { logger } from '@cdm-logger/server';
import './server';

process.on('uncaughtException', ex => {
    logger.error(ex);
    process.exit(1);
});

process.on('unhandledRejection', reason => {
    logger.error(reason);
});

if ((module as any).hot) {
    (module as any).hot.status(event => {
        if (event === 'abort' || event === 'fail') {
            logger.error('HMR error status: ' + event);
            // Signal webpack.run.js to do full-reload of the back-end
            process.exit(250);
        }
    });

    (module as any).hot.accept();
}

```

# servers/frontend-server/src/app/ServerError.tsx

```tsx

class ServerError extends Error {
    constructor(error: any) {
        super();
        for (const key of Object.getOwnPropertyNames(error)) {
            this[key] = error[key];
        }
        this.name = 'ServerError';
    }
}

export { ServerError };
```

# servers/frontend-server/src/app/Main.tsx

```tsx
/// <reference path='../../../../typings/index.d.ts' />
import { hot } from 'react-hot-loader/root';
import * as React from 'react';
import { RendererProvider } from 'react-fela';
import { ApolloProvider } from '@apollo/client';
import { Provider } from 'react-redux';
import { rehydrate } from 'fela-dom';
import { ConnectedRouter } from 'connected-react-router';
import { PersistGate } from 'redux-persist/integration/react';
import { persistStore } from 'redux-persist';
import createRenderer from '../config/fela-renderer';
import { createReduxStore } from '../config/redux-config';
import { createClientContainer } from '../config/client.service';
import modules, { MainRoute } from '../modules';
import { ErrorBoundary } from './ErrorBoundary';

const { apolloClient: client } = createClientContainer();

const { store, history } = createReduxStore();

export class Main extends React.Component<{}, {}> {
  public render() {
    const renderer = createRenderer();
    let persistor = persistStore(store);
    rehydrate(renderer);
    return (
      <ErrorBoundary>
        <Provider store={store}>
          <ApolloProvider client={client}>
            <RendererProvider renderer={renderer}>
              <PersistGate persistor={persistor}>
                {modules.getWrappedRoot(
                  (
                    <ConnectedRouter history={history}>
                      <MainRoute />
                    </ConnectedRouter>
                  ),
                )}
              </PersistGate>
            </RendererProvider>
          </ApolloProvider>
        </Provider>
      </ErrorBoundary>
    );
  }
}

export default hot(Main);

```

# servers/frontend-server/src/app/ErrorBoundary.tsx

```tsx
import * as React from 'react';
import { Error500 } from './500';
import { ServerError } from './ServerError';

type IErrorBoundryState = { error: any, type: string }


export class ErrorBoundary extends React.Component<any, IErrorBoundryState> {
    constructor(props) {
        super(props);
        const serverError: any = __CLIENT__ ? window.__SERVER_ERROR__ : null;
        if (serverError) {
            this.state = { error: new ServerError(serverError), type: 'serverError' };
        } else {
            this.state = { error: undefined, type: undefined };
        }
    }

    componentDidCatch(error) {
        let type = undefined;

        if (process.env.NODE_ENV === 'production') {
            type = '404'
        } else {
            type = '500'
        }
        // Update state so the next render will show the fallback UI.
        this.setState({ error, type });
    }


    render() {
        const { error, type } = this.state;
        if (error) {
            return <Error500 error={error} />
        }
        return this.props.children;
    }
}
```

# servers/frontend-server/src/app/500.tsx

```tsx
import * as React from 'react';
import { Result, Button } from 'antd';

export const Error500 = ({ error }: any) => {
    React.useEffect(() => {
        console.trace(error);
    }, [error]);

    return (
        <Result
            title="500"
            status="500"
            subTitle={`Sorry, the server is wrong. Error: ${error}`}
            extra={<Button href={process.env.CLIENT_URL} type="primary">Back Home</Button>}
        />
    );
}

```

# servers/backend-server/src/utils/migrations.ts

```ts
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable consistent-return */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/restrict-template-expressions */
import { Schema, Connection } from 'mongoose';
import { Container } from 'inversify';

export const MigrationSchema = new Schema({
    migrated_at: Date,
    name: { required: true, type: String },
});

export async function migrate(db: Connection, container: Container) {
    try {
        const migrations = container.getAll<{ up: any; id: any }>('MongodbMigration');
        const model = db.model<any, any>('Migration', MigrationSchema);
        return await Promise.all(
            migrations.map(async (migration) => {
                const exists = await model.findOne({ name: migration.id });
                if (!exists) {
                    try {
                        await migration.up();
                        await model.create({ name: migration.id, migrated_at: new Date() });
                    } catch (e) {
                        console.log(`Can not process migration ${migration.id}: `, e);
                    }
                }

                return migration.id;
            }),
        );
    } catch (err) {
        console.warn('ignoring migrate database due to ', err.message);
    }
}

```

# servers/backend-server/src/server-setup/websocket-multipath-update.ts

```ts



import * as url from 'url';
import { GRAPHQL_ROUTE } from '../constants';
import { GraphqlSubscriptionServer } from './graphql-subscription-server';
import * as WebSocket from 'ws';
import { IModuleService } from '../interfaces';
import { Server } from 'http';
import { RedisClusterCache, RedisCache } from 'apollo-server-cache-redis';

interface WebSocketsCache {
    [key: string]: WebSocket.Server;
}

interface MultiWebsocketConfig {
    [key: string]: any;
}
export class WebsocketMultiPathServer {

    private webSockets: WebSocketsCache = {};
    private graphqlSubscriptionServer: GraphqlSubscriptionServer;
    constructor(
        moduleService: IModuleService,
        cache: RedisCache | RedisClusterCache,
        multiplePathConfig?: MultiWebsocketConfig,
    ) {
        this.graphqlSubscriptionServer = new GraphqlSubscriptionServer(moduleService, cache);
        this.webSockets[GRAPHQL_ROUTE] = this.graphqlSubscriptionServer.create().server;
        for (let key in multiplePathConfig) {
            if (!multiplePathConfig.hasOwnProperty(key)) { continue; }

            if (!this.webSockets[key]) {
                this.webSockets[key] = new WebSocket.Server({ noServer: true });
                this.webSockets[key].on('connection', (ws, request) => {
                    Promise.all([
                        moduleService.createContext(request, null),
                        moduleService.serviceContext(request, null),
                    ])
                    .then(multiplePathConfig[key](ws));
                });
            }
        }
    }


    public httpServerUpgrade(httpServer: Server) {
        httpServer.on('upgrade', (request, socket, head) => {
            const pathname = url.parse(request.url).pathname;

            if (!this.webSockets[pathname]) {
                // need to destroy
                socket.destroy();
            }

            // code to run when a new connection is made
            this.webSockets[pathname].handleUpgrade(request, socket, head, (ws) => {
                this.webSockets[pathname].emit('connection', ws, request);
            });
        });
        return httpServer;
    }

    public close() {
        // tslint:disable-next-line:forin
        for (let key in this.webSockets) {
            this.webSockets[key].close();
        }
    }
}

```

# servers/backend-server/src/server-setup/graphql-subscription-server.ts

```ts
import { SubscriptionServer, ConnectionContext, ExecutionParams } from 'subscriptions-transport-ws';
import { execute, subscribe, ExecutionResult } from 'graphql';
// import { GraphQLServerOptions } from 'apollo-server-core';
import { formatApolloErrors } from 'apollo-server-errors';
import { GraphQLServerOptions } from 'apollo-server-core/dist/graphqlOptions';
import { Context } from 'apollo-server-core';
import { RedisClusterCache, RedisCache } from 'apollo-server-cache-redis';
import { CdmLogger } from '@cdm-logger/core';
import { IModuleService } from '../interfaces';

type ILogger = CdmLogger.ILogger;

// @workaround as the `dataSources` not available in Subscription (websocket) Context.
// https://github.com/apollographql/apollo-server/issues/1526 need to revisit in Apollo-Server v3.
const constructDataSourcesForSubscriptions = (context, cache, dataSources) => {
    const intializeDataSource = (instance) => {
        instance.initialize({ context, cache });
    };
    // tslint:disable-next-line:forin
    for (const prop in dataSources) {
        // tslint:disable-next-line:no-console
        intializeDataSource(dataSources[prop]);
    }
    return dataSources;
};

export class GraphqlSubscriptionServer {
    private subscriptionServer: SubscriptionServer;

    private context: Context;

    private logger: ILogger;

    constructor(
        private moduleService: IModuleService,
        private cache: RedisCache | RedisClusterCache,
        private requestOptions: Partial<GraphQLServerOptions<any>> = Object.create(null),
    ) {
        this.logger = this.moduleService.logger.child({ className: 'GraphqlSubscriptionServer' });
    }

    public create() {
        this.subscriptionServer = SubscriptionServer.create(
            {
                schema: this.moduleService.schema as any,
                execute,
                subscribe,
                onConnect: async (connectionParams: any, webSocket: any, ctx: ConnectionContext) => {
                    try {
                        this.logger.debug(`Subscription client connected using built-in SubscriptionServer.`);
                        const pureContext = await this.moduleService.createContext(connectionParams, webSocket);
                        const contextServices = await this.moduleService.serviceContext(connectionParams, webSocket);
                        const context = {
                            ...contextServices,
                            ...pureContext,
                            preferences: this.moduleService.defaultPreferences,
                            // update: updateContainers,
                            wsCtx: ctx,
                        };
                        const addons = {
                            dataSources: constructDataSourcesForSubscriptions(
                                context,
                                this.cache,
                                this.moduleService.dataSource,
                            ),
                        };
                        return {
                            ...context,
                            ...addons,
                        };
                    } catch (e) {
                        this.logger.error(e);
                    }
                },
                onOperation: async (message: { payload: any }, connection: ExecutionParams) => {
                    connection.formatResponse = (value: ExecutionResult) => ({
                        ...value,
                        errors:
                            value.errors &&
                            formatApolloErrors([...value.errors], {
                                formatter: this.requestOptions.formatError,
                                debug: this.requestOptions.debug,
                            }),
                    });
                    let context: Context = this.context ? this.context : { connection };
                    try {
                        context =
                            typeof this.context === 'function'
                                ? await this.context({ connection, payload: message.payload })
                                : context;
                    } catch (e) {
                        throw formatApolloErrors([e], {
                            formatter: this.requestOptions.formatError,
                            debug: this.requestOptions.debug,
                        })[0];
                    }

                    return { ...connection }; // TODO: we didn't add `context`
                },
            },
            {
                noServer: true,
            },
        );
        return this.subscriptionServer;
    }

    public disconnect() {
        if (this.subscriptionServer) {
            this.subscriptionServer.close();
        }
    }
}

```

# servers/backend-server/src/server-setup/graphql-server.ts

```ts
import { ApolloServer, ApolloServerExpressConfig } from 'apollo-server-express';
import 'isomorphic-fetch';
import { Express } from 'express';
import * as http from 'http';
import { RedisClusterCache, RedisCache } from 'apollo-server-cache-redis';
import { CdmLogger } from '@cdm-logger/core';
import { GRAPHQL_ROUTE } from '../constants';
import { IModuleService } from '../interfaces';

type ILogger = CdmLogger.ILogger;

let debug = false;
if ((process.env.LOG_LEVEL && process.env.LOG_LEVEL === 'trace') || process.env.LOG_LEVEL === 'debug') {
    debug = true;
}

// @workaround as the `dataSources` not available in Subscription (websocket) Context.
// https://github.com/apollographql/apollo-server/issues/1526 need to revisit in Apollo-Server v3.
const constructDataSourcesForSubscriptions = (context, cache, dataSources) => {
    const intializeDataSource = (instance) => {
        instance.initialize({ context, cache });
    };
    // tslint:disable-next-line:forin
    // eslint-disable-next-line guard-for-in
    for (const prop in dataSources) {
        // tslint:disable-next-line:no-console
        intializeDataSource(dataSources[prop]);
    }
    return dataSources;
};

export class GraphqlServer {
    private logger: ILogger;

    constructor(
        private app: Express,
        private httpServer: http.Server,
        private cache: RedisCache | RedisClusterCache,
        private moduleService: IModuleService,
        private enableSubscription = true,
    ) {
        this.logger = this.moduleService.logger.child({ className: 'GraphqlServer' });
    }

    public async initialize() {
        this.logger.info('GraphqlServer initializing...');
        const apolloServer = this.configureApolloServer();
        apolloServer.applyMiddleware({ app: this.app, disableHealthCheck: false, path: GRAPHQL_ROUTE });
        if (this.enableSubscription) {
            apolloServer.installSubscriptionHandlers(this.httpServer);
        }
        this.logger.info('GraphqlServer initialized');
    }

    private configureApolloServer(): ApolloServer {
        const serverConfig: ApolloServerExpressConfig = {
            debug,
            schema: this.moduleService.schema as any,
            dataSources: () => this.moduleService.dataSource,
            cache: this.cache,
            context: async ({
                req,
                res,
                connection,
            }: {
                req: Express.Request;
                res: Express.Response;
                connection: any;
            }) => {
                let context;
                let addons = {};
                try {
                    if (connection) {
                        context = connection.context;
                        if (!context.dataSources) {
                            addons = {
                                // @workaround for apollo server issue #1526
                                dataSources: constructDataSourcesForSubscriptions(
                                    connection.context,
                                    this.cache,
                                    this.moduleService.dataSource,
                                ),
                            };
                        } else {
                            addons = {
                                // @workaround for apollo server issue #1526
                                dataSources: context.dataSources,
                            };
                        }
                    } else {
                        const pureContext = await this.moduleService.createContext(req, res);
                        const contextServices = await this.moduleService.serviceContext(req, res);
                        context = {
                            ...pureContext,
                            ...contextServices,
                            preferences: this.moduleService.defaultPreferences,
                            // update: updateContainers,
                        };
                    }
                } catch (err) {
                    this.logger.error('adding context to graphql failed due to [%o]', err);
                    throw err;
                }
                return {
                    ...context,
                    ...addons,
                };
            },
        };
        if (this.enableSubscription) {
            serverConfig.subscriptions = {
                onConnect: async (connectionParams, webSocket) => {
                    this.logger.debug(`Subscription client connected using built-in SubscriptionServer.`);
                    const pureContext = await this.moduleService.createContext(connectionParams, webSocket);
                    const contextServices = await this.moduleService.serviceContext(connectionParams, webSocket);
                    return {
                        ...contextServices,
                        ...pureContext,
                        preferences: this.moduleService.defaultPreferences,
                        // update: updateContainers,
                    };
                },
                // onDisconnect: () => {},
            };
        }
        return new ApolloServer(serverConfig);
    }
}

```

# servers/backend-server/src/modules/module.ts

```ts
import { ContainerModule, interfaces } from 'inversify';
import { Feature } from '@common-stack/server-core';
import CounterModule from '@sample-stack/counter-module-server';
import { TaggedType } from '@common-stack/core';
import { config } from '../config';

export const settings = {
    // mongoConnection: generateMongo(config.MONGO_URL),
    subTopic: config.CONNECTION_ID, // usually versioning
    adminApiNamespace: config.ADMIN_API_NAMESPACE,
    apiNamespace: config.API_NAMESPACE,
};

const defaultModule = () =>
    new ContainerModule((bind: interfaces.Bind) => {
        bind('Settings').toConstantValue(settings).whenTargetTagged('default', true);
        bind('Settings').toConstantValue(settings).whenTargetTagged(TaggedType.MICROSERVICE, true);
        bind('MongoOptions').toConstantValue({});
    });

const DefaultFeature = new Feature({
    createContainerFunc: [defaultModule],
    createHemeraContainerFunc: [defaultModule],
});

export const ExternalModules = new Feature<any>({});

export default new Feature(DefaultFeature, ExternalModules, CounterModule);

```

# servers/backend-server/src/modules/index.ts

```ts
import modules, { settings } from './module';

export default modules;
export { settings };

// export const updateContainers = (options) => {
//     if (process.env.NODE_ENV !== 'development') {
//         options.forEach(el => {
//             hemera.act({
//                 topic: `UPDATE_CONTAINER_${el.toUpperCase()}`,
//                 cmd: `UPDATE_CONTAINER_${el.toUpperCase()}`,
//             });
//         });'
//     } else {
//         modules.createServiceContext(settings, options);
//     }
// };

```

# servers/backend-server/src/middleware/services.ts

```ts
import 'isomorphic-fetch';


export const contextServicesMiddleware = (createContext, serviceContext) =>  (req, res, next) => {
    Promise.all([
        createContext(req, res),
        serviceContext(req, res),
    ])
        .then(([ context, services ]) => {
            req.context = context;
            req.services = services;

            next();
        })
        .catch((err) => next());
};

```

# servers/backend-server/src/middleware/persistedQuery.ts

```ts
import { invert, isArray } from 'lodash';
import { GRAPHIQL_ROUTE } from '../ENDPOINTS';
import { logger } from '@cdm-logger/server';

let reqlib: any = require('app-root-path');

let persistCache = true;
let queryMap;
try {
    queryMap = reqlib.require('@sample-stack/platform-browser/extracted_queries.json');

} catch (err) {
    logger.warn('extracted_queries.json file is unavailable, disabling persist queries');
}
export const persistedQueryMiddleware = (req, res, next) => {

    if (queryMap) {
        const invertedMap = invert(queryMap);

        if (isArray(req.body)) {
            req.body = req.body.map(body => {
                const id = body['id'];
                return {
                    query: invertedMap[id],
                    ...body,
                };
            });
            next();
        } else {
            if (!__DEV__ || (req.get('Referer') || '').indexOf(GRAPHIQL_ROUTE) < 0) {
                res.status(500).send('Unknown GraphQL query has been received, rejecting...');
            } else {
                next();
            }
        }
    } else {
        next();
    }
};


```

# servers/backend-server/src/middleware/moleculer-inter-namespace.ts

```ts
/* eslint-disable no-param-reassign */
import { ServiceBroker, Middleware } from 'moleculer';
import * as _ from 'lodash';

export const InterNamespaceMiddleware = function (options): Middleware {
    if (!Array.isArray(options)) {
        throw new Error('Must be an Array');
    }

    let thisBroker: ServiceBroker;
    const brokers: { [key: string]: ServiceBroker } = {};

    return {
        created(broker: ServiceBroker) {
            thisBroker = broker;
            options.forEach((nsOpts) => {
                if (_.isString(nsOpts)) {
                    nsOpts = {
                        namespace: nsOpts,
                    };
                }
                const ns = nsOpts.namespace;

                const brokerOpts = _.defaultsDeep(
                    {},
                    nsOpts,
                    { nodeID: null, middlewares: null, created: null, started: null },
                    broker.options,
                );
                brokers[ns] = new ServiceBroker(brokerOpts);
            });
        },

        started() {
            return Promise.all(Object.values(brokers).map((b) => b.start()));
        },

        stopped() {
            return Promise.all(Object.values(brokers).map((b) => b.stop()));
        },

        call(next) {
            return function (actionName, params, opts = {}) {
                if (_.isString(actionName) && actionName.includes('@')) {
                    const [action, namespace] = actionName.split('@');

                    if (brokers[namespace]) {
                        return brokers[namespace].call(action, params, opts);
                    }
                    if (namespace === thisBroker.namespace) {
                        return next(action, params, opts);
                    }
                    throw new Error(`Unknown namespace: ${namespace}`);
                }

                return next(actionName, params, opts);
            };
        },
    };
};

```

# servers/backend-server/src/middleware/error.ts

```ts
/// <reference path='../../../../typings/index.d.ts' />

import * as path from 'path';
import * as fs from 'fs';
import * as url from 'url';
import { logger } from '@cdm-logger/server';


let assetMap;

const stripCircular = (from, seen?: any) => {
    const to = Array.isArray(from) ? [] : {};
    seen = seen || [];
    seen.push(from);
    Object.getOwnPropertyNames(from).forEach(key => {
        if (!from[key] || (typeof from[key] !== 'object' && !Array.isArray(from[key]))) {
            to[key] = from[key];
        } else if (seen.indexOf(from[key]) < 0) {
            to[key] = stripCircular(from[key], seen.slice(0));
        } else { to[key] = '[Circular]'; }
    });
    return to;
};

const { pathname } = url.parse(__BACKEND_URL__);

export const errorMiddleware =
    (e, req, res, next) => {
        if (req.path === pathname) {
            const stack = e.stack.toString().replace(/[\n]/g, '\\n');
            res.status(200).send(`[{"data": {}, "errors":[{"message": "${stack}"}]}]`);
        } else {
            logger.error(e);

            if (__DEV__ || !assetMap) {
                assetMap = JSON.parse(fs.readFileSync(path.join(__FRONTEND_BUILD_DIR__, 'assets.json')).toString());
            }

            const serverErrorScript = `<script charset="UTF-8">window.__SERVER_ERROR__=${JSON.stringify(
                stripCircular(e),
            )};</script>`;
            const vendorScript = assetMap['vendor.js']
                ? `<script src="/${assetMap['vendor.js']}" charSet="utf-8"></script>`
                : '';

            res.status(200).send(
                `<html>${serverErrorScript}<body><div id="content"></div>
        ${vendorScript}
            <script src="/${assetMap['index.js']}" charSet="utf-8"></script>
            </body></html>`,
            );
        }
    };



```

# servers/backend-server/src/middleware/cors.ts

```ts
import * as cors from 'cors';
import * as express from 'express';
import { config } from '../config';
import { logger } from '@cdm-logger/server';

const CLIENT_URL = config.CLIENT_URL;
const BACKEND_URL = config.BACKEND_URL;

const corsWhitelist = [
    BACKEND_URL,
    CLIENT_URL,
    config.GRAPHQL_URL,
];
logger.info('Cors whitelist: %j', corsWhitelist);
const corsOptions = {
    origin: (origin, callback) => {
        if (corsWhitelist.indexOf(origin) !== -1) {
            callback(null, true);
        } else {
            // TODO: only throw when in debug mode
            logger.error('url (%s) is not in the whitelist', origin);
            // callback(new Error('Not allowed by CORS'))
            logger.warn('allowing all origins temporarily, you need to disable it.');
            callback(null, true);
        }
    },
    credentails: false,
};

export const corsMiddleware = cors(corsOptions);

```

# servers/backend-server/src/interfaces/module-interface.ts

```ts
import { GraphQLSchema } from 'graphql';
import { CdmLogger } from '@cdm-logger/core';
type ILogger = CdmLogger.ILogger;


export interface IModuleService {
    serviceContainer: any;
    serviceContext: any;
    dataSource: any;
    defaultPreferences: any;
    createContext: any;
    schema: GraphQLSchema;
    logger: ILogger;
}



```

# servers/backend-server/src/interfaces/index.ts

```ts
export * from './module-interface';

```

# servers/backend-server/src/constants/index.ts

```ts
export * from './ENDPOINTS';

```

# servers/backend-server/src/constants/ENDPOINTS.ts

```ts
// Default port or given one.
export const GRAPHQL_ROUTE = '/graphql';
export const GRAPHIQL_ROUTE = '/graphiql';

```

# servers/backend-server/src/connectors/redis-connector.ts

```ts


import * as _ from 'lodash';
import { RedisClusterCache, RedisCache } from 'apollo-server-cache-redis';
import * as IORedis from 'ioredis';
import { logger } from '@cdm-logger/server';
import { config } from '../config';
import { CdmLogger } from '@cdm-logger/core';
type ILogger = CdmLogger.ILogger;

export class RedisConnector {


    private client: RedisClusterCache | RedisCache;
    private opts: IORedis.ClusterOptions | IORedis.RedisOptions;
    private logger: ILogger;

    /**
     * Creats an instance of Redis.
     *
     * @param {object} opts
     */
    constructor(opts?: IORedis.ClusterOptions | IORedis.RedisOptions) {
        this.opts = _.defaultsDeep(opts, {
            prefix: null,
        });
        this.logger = logger.child({ className: 'RedisConnector' });
    }

    /**
     * Connect to the server
     *
     * @memberof RedisConnector
     */
    public connect() {
        return new Promise((resolve, reject) => {
            reject('this method not implemented');
        });
    }


    /**
     * Return redis or redis.cluster Dataloader Client
     *
     * @memberof RedisConnection
     */
    public getRedisDataloaderClient() {
        let client: RedisClusterCache | RedisCache;
        if (config.REDIS_CLUSTER_ENABLED) {
            if (!config.REDIS_CLUSTER_URL) {
                throw new Error(`No nodes defined for cluster, ${config.REDIS_CLUSTER_URL}`);
            }
            this.logger.info('Setting Redis.Cluster connection');
            client = new RedisClusterCache(config.REDIS_CLUSTER_URL as any, this.opts);
        } else {
            this.logger.info('Setting Redis connection');
            client = new RedisCache(config.REDIS_URL as any || this.opts);
        }
        return client;
    }

    /**
     * Close Redis client connection.
     *
     * @memberof RedisConnection
     */
    public disconnect() {
        if (!this.client) {
            return;
        }
        return this.client.close();
    }
}

```

# servers/backend-server/src/connectors/nats-connector.ts

```ts
import * as nats from 'nats';
import * as _ from 'lodash';
import { logger } from '@cdm-logger/server';
import { CdmLogger } from '@cdm-logger/core';
type ILogger = CdmLogger.ILogger;


export class NatsConnector {


    private opts: nats.ClientOpts;
    private client: nats.Client;
    private logger: ILogger;
    private connected: boolean;

    constructor(opts: nats.ClientOpts) {
        this.opts = _.defaultsDeep(opts, {});
        this.logger = logger.child({ className: 'NatsConnector' });
    }
    /**
     * Connect to a NATS server
     *
     * @memberof NatsConnector
     */
    public connect() {
        if (this.client) {
            return this.client;
        }
        return new Promise<nats.Client>((resolve, reject) => {
            const client = nats.connect(this.opts);

            client.on('connect', () => {
                this.client = client;
                this.connected = true;
                this.logger.info('NATS client is connected.');
                resolve(client);
            });

            client.on('reconnect', () => {
                this.logger.info('NATS client is reconnected.');
                this.connected = true;
            });

            client.on('reconnecting', () => {
                this.logger.warn('NATS client is reconnecting...');
            });

            client.on('disconnect', () => {
                if (this.connected) {
                    this.logger.warn('NATS client is disconnected.');
                    this.connected = false;
                }
            });

            client.on('error', e => {
                this.logger.error('NATS error.', e.message);
                this.logger.debug(e);
                reject(e);

            });

            client.on('close', () => {
                this.logger.fatal('NATS connection close.');
            });
        });

    }

    /**
     * Disconnect from a NATS server
     *
     * @memberof NatsTransporter
     */
    public disconnect() {
        if (this.client) {
            this.client.flush(() => {
                this.client.close();
                this.client = null;
            });
        }
    }
}

```

# servers/backend-server/src/connectors/mongo-connector.ts

```ts
import { createConnection, connection, ConnectionOptions, Connection } from 'mongoose';
import * as _ from 'lodash';
import { Db } from 'mongodb';
import { logger } from '@cdm-logger/server';
import { CdmLogger } from '@cdm-logger/core';

type ILogger = CdmLogger.ILogger;

export class MongoConnector {
    private client: Connection;

    private db: Db;

    private opts: ConnectionOptions;

    private uri: string;

    private logger: ILogger;

    constructor(uri: string, opts?: ConnectionOptions) {
        this.opts = _.defaultsDeep(opts, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
        });
        this.uri = uri;
        this.logger = logger.child({ className: 'MongoConnector' });
    }

    /**
     * Connect to database
     *
     * @memberof MongoConnector
     */
    public async connect(): Promise<Connection> {
        if (this.client) {
            return this.client;
        }
        const conn = createConnection(this.uri, this.opts);

        conn.then((result) => {
            this.client = conn;

            if ((result as any).connection) {
                this.db = (result as any).conection.db;
            } else {
                this.db = result.db;
            }

            this.logger.info(' MongoDB has connected successfully.');

            this.db.on('disconnected', () => this.logger.warn('Mongoose has disconnected.'));
            this.db.on('error', (err) => this.logger.error('MongoDB error.', err));
            this.db.on('reconnect', () => this.logger.info('Mongoose has reconnected.'));
        });
        return conn;
    }

    /**
     * Disconnect from database
     *
     * @memberof MongoConnector
     */
    public async disconnect() {
        if (!this.client) {
            return;
        }
        if (this.db && (this.db as any).close) {
            await (this.db as any).close();
        }
        await connection.close();
    }
}

```

# servers/backend-server/src/connectors/graphql-pubsub-connector.ts

```ts
/* eslint-disable no-return-assign */
import { PubSub, PubSubEngine } from 'graphql-subscriptions';
import { NatsPubSub } from 'graphql-nats-subscriptions';
import { wrapPubSub } from 'apollo-logger';
import { logger } from '@cdm-logger/server';
import { GenericObject } from 'moleculer';
import { CdmLogger } from '@cdm-logger/core';

type ILogger = CdmLogger.ILogger;

type PubSubOptions = {
    apolloLogging?: boolean;
    logger: ILogger;
} & GenericObject;

export class GraphqlPubSubConnector {
    private client: PubSubEngine | NatsPubSub;

    private opts: PubSubOptions;

    private logger: ILogger;

    /**
     * Creates an instance of GraphqlPubSubConnector.
     * @param {*} opts
     * @memberof GraphqlPubSubConnector
     */
    constructor(opts?: PubSubOptions) {
        if (opts === undefined || opts.type === undefined) {
            this.opts = { ...opts, apolloLogging: true, type: 'TCP' };
        }
        this.opts = opts;
        this.logger = opts.logger.child({ className: 'GraphqlPubSubConnector' });
    }

    public async getClient() {
        if (this.opts.type === 'TCP') {
            if (this.opts.apolloLogging) {
                return (this.client = wrapPubSub(new PubSub(), { logger: this.logger.trace.bind(this.logger) }));
            }
            return (this.client = new PubSub());
        }
        if (this.opts.type === 'NATS') {
            // console.log('--this.copts', this.opts.client)
            const natsClient = await this.opts.client.connect();
            return (this.client = new NatsPubSub({ client: natsClient, logger }));
        }
        this.logger.warn('Did not defined known transporter [%s], return default pubsub', this.opts.type);
        return (this.client = new PubSub());
    }
}

```

# servers/backend-server/src/connectors/connection-broker.ts

```ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-unused-expressions */
/* eslint-disable no-underscore-dangle */

import { Transporter, GenericObject } from 'moleculer';
import { CdmLogger } from '@cdm-logger/core';
import { MongoConnector } from './mongo-connector';
import { NatsConnector } from './nats-connector';
import { RedisConnector } from './redis-connector';
import { config } from '../config';
import { GraphqlPubSubConnector } from './graphql-pubsub-connector';

type ILogger = CdmLogger.ILogger;

/**
 *  Connection broker class
 *
 * @class ConnectionBroker
 */
export class ConnectionBroker {
    private _mongoConnector: MongoConnector;

    private _redisConnector: RedisConnector;

    private _natsConnector: NatsConnector;

    private _graphqlPubsubConnector: GraphqlPubSubConnector;

    /**
     * Creates an instance of ConnectionBroker.
     * @param {*} options
     * @memberof ConnectionBroker
     */
    constructor(transporter: string | GenericObject, logger: ILogger) {
        if (typeof transporter === 'string') {
            if (transporter === 'TCP') {
                this._graphqlPubsubConnector = new GraphqlPubSubConnector({ logger, type: 'TCP' });
            } else if (transporter === 'NATS') {
                this._natsConnector = new NatsConnector({});
                this._graphqlPubsubConnector = new GraphqlPubSubConnector({
                    logger,
                    type: 'NATS',
                    client: this._natsConnector,
                });
            }
        } else if (transporter.type === 'NATS') {
            this._natsConnector = new NatsConnector(transporter.options);
            this._graphqlPubsubConnector = new GraphqlPubSubConnector({
                logger,
                ...transporter,
                client: this._natsConnector,
            });
        }

        this._mongoConnector = new MongoConnector(config.MONGO_URL);
        this._redisConnector = new RedisConnector(); // TODO pass constructor options
    }

    public get mongoConnection() {
        return this._mongoConnector.connect();
    }

    public get redisDataloaderClient() {
        return this._redisConnector.getRedisDataloaderClient();
    }

    public get natsConnection() {
        return this._natsConnector.connect();
    }

    public get graphqlPubsub() {
        return this._graphqlPubsubConnector.getClient();
    }

    public async stop() {
        this._mongoConnector && (await this._mongoConnector.disconnect());
        this._redisConnector && (await this._redisConnector.disconnect());
        this._natsConnector && (await this._natsConnector.disconnect());
    }
}

```

# servers/backend-server/src/config/moleculer.config.ts

```ts
/* eslint-disable @typescript-eslint/no-empty-function */
import { BrokerOptions, Errors } from 'moleculer';
import { config } from './config';

/**
 * Moleculer ServiceBroker configuration file
 *
 * More info about options:
 *         https://moleculer.services/docs/0.14/configuration.html
 *
 *
 * Overwrite options in production:
 * ================================
 * 	You can overwrite any option with environment variables.
 * 	For example to overwrite the 'logLevel', use `LOGLEVEL=warn` env var.
 * 	To overwrite a nested parameter, e.g. retryPolicy.retries, use `RETRYPOLICY_RETRIES=10` env var.
 *
 * 	To overwrite broker’s deeply nested default options, which are not presented in 'moleculer.config.ts',
 * 	via environment variables, use the `MOL_` prefix and double underscore `__` for nested properties in .env file.
 * 	For example, to set the cacher prefix to `MYCACHE`, you should declare an env var as `MOL_CACHER__OPTIONS__PREFIX=MYCACHE`.
 */
const brokerConfig: BrokerOptions = {
    // Namespace of nodes to segment your nodes on the same network.
    namespace: config.NAMESPACE,
    // namespace: null,
    // Unique node identifier. Must be unique in a namespace.
    // nodeID: config.CONNECTION_ID,

    // Enable/disable logging or use custom logger. More info: https://moleculer.services/docs/0.14/logging.html
    // Available logger types: 'Console', 'File', 'Pino', 'Winston', 'Bunyan', 'debug', 'Log4js', 'Datadog'
    logger: {
        type: 'Console',
        options: {
            // Using colors on the output
            colors: true,
            // Print module names with different colors (like docker-compose for containers)
            moduleColors: false,
            // Line formatter. It can be 'json', 'short',
            // 'simple', 'full', a `Function` or a template string like '{timestamp} {level} {nodeID}/{mod}: {msg}'
            formatter: 'full',
            // Custom object printer. If not defined, it uses the `util.inspect` method.
            objectPrinter: null,
            // Auto-padding the module name in order to messages begin at the same column.
            autoPadding: false,
        },
    },
    // Default log level for built-in console logger. It can be overwritten in logger options above.
    // Available values: trace, debug, info, warn, error, fatal
    logLevel: config.LOG_LEVEL as any,

    // Define transporter.
    // More info: https://moleculer.services/docs/0.14/networking.html
    // Note: During the development, you don't need to define it because all services will be loaded locally.
    // In production you can set it via `TRANSPORTER=nats://localhost:4222` environment variable.
    transporter:
        config.NODE_ENV === 'development'
            ? 'TCP'
            : {
                  type: 'NATS',
                  options: {
                      url: config.NATS_URL,
                      user: config.NATS_USER,
                      pass: config.NATS_PW,
                      reconnectTimeWait: 1000,
                  },
              },

    // Define a cacher.
    // More info: https://moleculer.services/docs/0.14/caching.html
    // cacher: {
    //     type: 'Redis',
    //     enabled: false,
    //     options: {

    //         // Redis settings
    //         redis: {

    //         }
    //     }
    // },

    // Define a serializer.
    // Available values: 'JSON', 'Avro', 'ProtoBuf', 'MsgPack', 'Notepack', 'Thrift'.
    // More info: https://moleculer.services/docs/0.13/networking.html
    serializer: 'JSON',

    // Number of milliseconds to wait before reject a request with a RequestTimeout error. Disabled: 0
    requestTimeout: 10 * 1000,

    // Retry policy settings. More info: https://moleculer.services/docs/0.13/fault-tolerance.html#Retry
    retryPolicy: {
        // Enable feature
        enabled: false,
        // Count of retries
        retries: 5,
        // First delay in milliseconds.
        delay: 100,
        // Maximum delay in milliseconds.
        maxDelay: 1000,
        // Backoff factor for delay. 2 means exponential backoff.
        factor: 2,
        // A function to check failed requests.
        check: (err: Errors.MoleculerRetryableError) => err && !!err.retryable,
    },

    // Limit of calling level. If it reaches the limit, broker will throw an MaxCallLevelError error. (Infinite loop protection)
    maxCallLevel: 100,

    // Number of seconds to send heartbeat packet to other nodes.
    heartbeatInterval: 5,
    // Number of seconds to wait before setting node to unavailable status.
    heartbeatTimeout: 15,

    // tslint:disable-next-line:max-line-length
    // Tracking requests and waiting for running requests before shutdowning. More info: https://moleculer.services/docs/0.13/fault-tolerance.html
    tracking: {
        // Enable feature
        enabled: false,
        // Number of milliseconds to wait before shutdowning the process
        shutdownTimeout: 5000,
    },

    // Disable built-in request & emit balancer. (Transporter must support it, as well.)
    disableBalancer: false,

    // Settings of Service Registry. More info: https://moleculer.services/docs/0.14/registry.html
    registry: {
        // Define balancing strategy. More info: https://moleculer.services/docs/0.14/balancing.html
        // Available values: 'RoundRobin', 'Random', 'CpuUsage', 'Latency'
        strategy: 'RoundRobin',
        // Enable local action call preferring.
        preferLocal: true,
    },

    // Settings of Circuit Breaker. More info: https://moleculer.services/docs/0.14/fault-tolerance.html#Circuit-Breaker
    circuitBreaker: {
        // Enable feature
        enabled: false,
        // Threshold value. 0.5 means that 50% should be failed for tripping.
        threshold: 0.5,
        // Minimum request count. Below it, CB does not trip.
        minRequestCount: 20,
        // Number of seconds for time window.
        windowTime: 60,
        // Number of milliseconds to switch from open to half-open state
        halfOpenTime: 10 * 1000,
        // A function to check failed requests.
        check: (err: Errors.MoleculerRetryableError) => err && err.code >= 500,
    },

    // Settings of bulkhead feature. More info: https://moleculer.services/docs/0.14/fault-tolerance.html#Bulkhead
    bulkhead: {
        // Enable feature.
        enabled: false,
        // Maximum concurrent executions.
        concurrency: 10,
        // Maximum size of queue
        maxQueueSize: 100,
    },

    // Enable action & event parameter validation. More info: https://moleculer.services/docs/0.14/validating.html
    validator: true,

    errorHandler: null,

    // Enable/disable built-in metrics function. More info: https://moleculer.services/docs/0.14/metrics.html
    metrics: {
        enabled: false,
        // Available built-in reporters: 'Console', 'CSV', 'Event', 'Prometheus', 'Datadog', 'StatsD'
        reporter: {
            type: 'Prometheus',
            options: {
                // HTTP port
                port: 3030,
                // HTTP URL path
                path: '/metrics',
                // Default labels which are appended to all metrics labels
                defaultLabels: (registry) => ({
                    namespace: registry.broker.namespace,
                    nodeID: registry.broker.nodeID,
                }),
            },
        },
    },

    // Enable built-in tracing function. More info: https://moleculer.services/docs/0.14/tracing.html
    tracing: {
        enabled: true,
        // Available built-in exporters: 'Console', 'Datadog', 'Event', 'EventLegacy', 'Jaeger', 'Zipkin'
        exporter: {
            type: 'Console', // Console exporter is only for development!
            options: {
                // Custom logger
                logger: null,
                // Using colors
                colors: true,
                // Width of row
                width: 100,
                // Gauge width in the row
                gaugeWidth: 40,
            },
        },
    },

    // Register internal services ('$node'). More info: https://moleculer.services/docs/0.13/services.html#Internal-services
    internalServices: true,
    // Register internal middlewares. More info: https://moleculer.services/docs/0.13/middlewares.html#Internal-middlewares
    internalMiddlewares: true,

    // Watch the loaded services and hot reload if they changed.
    // You can also enable it in Moleculer Runner with `--hot` argument
    hotReload: false,

    // Register custom middlewares
    middlewares: [],

    // Called after broker created.
    created(broker) {},

    // Called after broker starte.
    started(broker) {},

    // Called after broker stopped.
    stopped(broker) {},

    // Register custom REPL commands.
    replCommands: null,
};

export = brokerConfig;

```

# servers/backend-server/src/config/index.ts

```ts
export * from './config';

```

# servers/backend-server/src/config/config.ts

```ts
/// <reference path='../../../../typings/index.d.ts' />
import * as envalid from 'envalid';

const { str, bool, json } = envalid;

export const config = envalid.cleanEnv(process.env, {
    NODE_ENV: str({ default: 'production', choices: ['production', 'staging', 'development', 'test'] }),
    NATS_URL: str(),
    NATS_USER: str(),
    NATS_PW: str(),
    MONGO_URL: str(),
    LOG_LEVEL: str({ default: 'info', devDefault: 'trace', choices: ['info', 'debug', 'trace'] }),
    REDIS_CLUSTER_URL: json({
        devDefault: '[{"port":6379,"host":"localhost"}]',
        example: '[{"port":6379,"host":"localhost"}]',
    }),
    REDIS_URL: str({ devDefault: 'localhost' }),
    REDIS_CLUSTER_ENABLED: bool({ devDefault: false }),
    REDIS_SENTINEL_ENABLED: bool({ devDefault: true }),
    HEMERA_LOG_LEVEL: str({ default: 'info' }),
    BACKEND_URL: str({ devDefault: __BACKEND_URL__ }),
    GRAPHQL_URL: str({ devDefault: __GRAPHQL_URL__ }),
    CLIENT_URL: str({ devDefault: __BACKEND_URL__ }),
    CONNECTION_ID: str({ devDefault: 'CONNECTION_ID' }),
    NAMESPACE: str({ default: 'default' }),
    apolloLogging: bool({ default: false, devDefault: true }),
    API_NAMESPACE: str({ devDefault: 'default' }),
    ADMIN_API_NAMESPACE: str({ devDefault: 'default' }),
});

```

# servers/backend-server/src/api/schema-builder.ts

```ts
/* eslint-disable global-require */
/* eslint-disable class-methods-use-this */
/* eslint-disable no-useless-constructor */
/* eslint-disable import/no-extraneous-dependencies */
import { GraphQLSchema, OperationDefinitionNode } from 'graphql';
import { mergeSchemas } from '@graphql-tools/merge';
import { makeExecutableSchema, addErrorLoggingToSchema } from '@graphql-tools/schema';
import { linkToExecutor } from '@graphql-tools/links';
import { introspectSchema, makeRemoteExecutableSchema } from '@graphql-tools/wrap';
// import { transformSchema } from '@graphql-tools/delegate';
import * as ws from 'ws';
import { getMainDefinition } from '@apollo/client/utilities';
import { WebSocketLink } from '@apollo/client/link/ws';
import { split } from '@apollo/client';
import { logger } from '@common-stack/server-core';
import { HttpLink } from '@apollo/client/link/http';
import * as fetch from 'isomorphic-fetch';
import { remoteSchemaDetails } from './remote-config';
import rootSchemaDef from './root-schema.graphqls';
import { resolvers as rootResolver } from './resolver';

export class GatewaySchemaBuilder {
    constructor(private options: { schema: string | string[]; resolvers; directives; logger }) {}

    public async build(): Promise<GraphQLSchema> {
        let schema;
        let ownSchema;
        try {
            ownSchema = this.createOwnSchema();
            const remoteSchema = await this.load();
            // techSchema = this.patchSchema(techSchema, 'TechService');

            schema = mergeSchemas({
                schemas: [ownSchema, remoteSchema],
            });
            // TODO after updating graphql-tools to v8
            addErrorLoggingToSchema(schema, { log: (e) => logger.error(e as Error) });
        } catch (err) {
            logger.error('[Graphql Schema Errors] when building schema::', err.message);
            schema = ownSchema;
        }

        return schema;
    }

    private async load() {
        const schemas = [];
        // eslint-disable-next-line no-plusplus
        for (let i = 0; i < remoteSchemaDetails.length; i++) {
            // eslint-disable-next-line no-await-in-loop
            const schema = await this.loadRemoteSchema(remoteSchemaDetails[i]);
            schemas.push(schema);
        }
        return schemas;
    }

    private async createRemoteSchema(service: string, iteration?: number): Promise<GraphQLSchema> {
        logger.info('Fetch service [%s] iteration [%s]', service, iteration);
        const services = remoteSchemaDetails;
        if (!services.length) {
            console.warn(`Service ${services} is undefined`);
            if (iteration && iteration > 2) {
                return Promise.reject(`tried upto ${iteration} attempts, now failing...`);
            }
            return new Promise<GraphQLSchema>((resolve, reject) => {
                const timeout = iteration ? 1000 * iteration : 1000;
                logger.info('Wait for service startup %s', timeout);
                setTimeout(() => {
                    this.createRemoteSchema(service, iteration ? iteration + 1 : 1)
                        .then(resolve)
                        .catch(reject);
                }, timeout);
            });
        }
        // instead need to loop it
        // https://github.com/j-colter/graphql-gateway/blob/9c64d90a74727d2002d10b06f47e1f4a316070fc/src/schema.js#L50
        const url = services[0].uri;
        logger.info('fetch service [%s]', url);
        // 1. Create apollo Link that's connected to the underlying GraphQL API
        const link = new HttpLink({ uri: url, fetch });
        const executor: any = linkToExecutor(link);
        // 2. Retrieve schema definition of the underlying GraphQL API
        const remoteSchema = await introspectSchema(link as any);

        // 3. Create the executable schema based on schema definition and Apollo Link
        return makeRemoteExecutableSchema({
            schema: remoteSchema,
            executor,
        });
    }

    private async loadRemoteSchema({ uri, wsUri }) {
        try {
            const httpLink = new HttpLink({ uri, fetch });
            let link = null;

            if (wsUri) {
                const wsLink = new WebSocketLink({
                    uri: wsUri,
                    options: {
                        reconnect: true,
                    },
                    webSocketImpl: ws,
                });
                link = split(
                    // split based on operatino type
                    ({ query }) => {
                        const { kind, operation } = getMainDefinition(query) as OperationDefinitionNode;
                        return kind === 'OperationDefinition' && operation === 'subscription';
                    },
                    wsLink,
                    httpLink,
                );
            } else {
                link = httpLink;
            }
            const executor: any = linkToExecutor(link);
            const remoteSchema = await introspectSchema(link);
            const executableSchema = makeRemoteExecutableSchema({
                schema: remoteSchema,
                executor,
            });
            return executableSchema;
        } catch (err) {
            this.options.logger.error('fetching schema error: ', err);
            return {};
        }
    }

    // disabled after updating to apollo-client to v3 and graphql-tools to v8
    // private patchSchema(schema: GraphQLSchema, systemName: string) {
    //     return transformSchema(schema, [
    //         new RenameTypes((name: string) => (name === 'StatusInfo' ? `${systemName}StatusInfo` : undefined)),
    //         new RenameRootFields((_operation: string, name: string) =>
    //             name === 'status'
    //                 ? `${systemName.substring(0, 1).toLowerCase()}${systemName.substring(1)}Status`
    //                 : name,
    //         ),
    //     ]);
    // }

    private createOwnSchema(): GraphQLSchema {
        const typeDefs = [rootSchemaDef, this.options.schema].join('\n');
        if (__DEV__) {
            const { ExternalModules } = require('../modules/module');
            const externalSchema = ExternalModules.schemas;
            const fs = require('fs');
            const writeData = `${externalSchema}`;
            fs.writeFileSync('./generated-schema.graphql', writeData);
        }
        return makeExecutableSchema({
            resolvers: [rootResolver, this.options.resolvers],
            typeDefs,
            // TODO disabled https://github.com/ardatan/graphql-tools/blob/e1fbc79e2714bae61aa0fa014a6231b151bb6c8e/website/docs/schema-directives.mdx#what-about-directiveresolvers
            directiveResolvers: this.options.directives,
            resolverValidationOptions: {
                requireResolversForResolveType: true,
            },
        });
    }
}

```

# servers/backend-server/src/api/scalar.ts

```ts
// add any scalar types
import { GraphQLError, GraphQLScalarType, Kind } from 'graphql';

// https://stackoverflow.com/questions/41557536/custom-map-keys-in-graphql-response
export const GraphQLAnyObject = new GraphQLScalarType({
    name: 'AnyObject',
    description: 'Any JSON object. This type bypasses type checking.',
    serialize: (value) => value,
    parseValue: (value) => value,
    parseLiteral: (ast) => {
        if (ast.kind !== Kind.OBJECT) {
            throw new GraphQLError(`Query error: Can only parse object but got a: ${ast.kind}`, [ast]);
        }
        return ast.fields;
    },
});

```

# servers/backend-server/src/api/root-schema.graphqls

```graphqls
scalar AnyObject
scalar JSON
scalar JSONObject
type FieldError {
  field: String!
  message: String!
}

type Query {
    dummy: Int
}

type Mutation {
    dummy: Int
}

type Subscription {
    dummy: Int
}

interface Node {
      id: ID!
}


schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}
```

# servers/backend-server/src/api/resolver.ts

```ts
import GraphQLJSON, { GraphQLJSONObject } from 'graphql-type-json';

export const resolvers = {
    JSON: GraphQLJSON,
    JSONObject: GraphQLJSONObject,
};

```

# servers/backend-server/src/api/remote-config.ts

```ts
interface ISchemaConfig {
    uri: string;
    wsUri: string;
}

export const remoteSchemaDetails: ISchemaConfig[] = [
    // {
    // uri: 'http://localhost:8085/graphql',
    // wsUri: 'ws://localhost:8085/graphql',
    // },
];

```

# portable-devices/mobile/assets/images/splash.png

This is a binary file of the type: Image

# portable-devices/mobile/assets/images/icon.png

This is a binary file of the type: Image

# portable-devices/mobile/assets/images/favicon.png

This is a binary file of the type: Image

# portable-devices/mobile/assets/images/adaptive-icon.png

This is a binary file of the type: Image

# portable-devices/mobile/assets/fonts/SpaceMono-Regular.ttf

This is a binary file of the type: Binary

# portable-devices/desktop/src/renderer/tray-main.tsx

```tsx
import 'reflect-metadata';
import 'antd/dist/antd.css';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import './config/public-config'; // load before rendering `Main`
import Main from './app/Tray';

// Virtual (module as any), generated in-memory by zenjs, contains count of backend rebuilds
// tslint:disable-next-line
// import 'backend_reload';

const rootEl = document.getElementById('app');
let frontendReloadCount = 0;

const renderApp = ({ key }: { key: number }) => ReactDOM.render(<Main key={key} />, rootEl);
renderApp({ key: frontendReloadCount });
if (__DEV__) {
    if ((module as any).hot) {
        (module as any).hot.accept();
        // (module as any).hot.accept('backend_reload', () => {
        //     // log.debug('Reloading front-end');
        //     // when the backend restarts wait for 5 seconds
        //     setTimeout(() => window.location.reload(), 5000);
        //     // window.location.reload();
        // });
        (module as any).hot.accept((err) => {
            if (err) {
                console.error('Cannot apply HMR update.', err);
            }
        });
        //  React-hot-loader v4 doesn't require following code any more.
        //  but if RHL not working we can uncomment below code to make normal HMR to refresh the page
        (module as any).hot.accept('./app/Tray', () => {
            try {
                console.log('Updating front-end');
                frontendReloadCount = (frontendReloadCount || 0) + 1;

                renderApp({ key: frontendReloadCount });
            } catch (err) {
                // log(err.stack);
            }
        });
    }
}

```

# portable-devices/desktop/src/renderer/main.tsx

```tsx
import 'reflect-metadata';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import './config/public-config'; // load before rendering `Main`
import Main from './app/Main';
import 'antd/dist/antd.css';
// import 'react-table/react-table.css';
// import 'react-big-calendar/lib/css/react-big-calendar.css';
// import 'react-big-calendar/lib/addons/dragAndDrop/styles.css';
// Virtual (module as any), generated in-memory by zenjs, contains count of backend rebuilds
// tslint:disable-next-line
// import 'backend_reload';

const rootEl = document.getElementById('app');
let frontendReloadCount = 0;

const renderApp = ({ key }: { key: number }) => ReactDOM.render(<Main key={key} />, rootEl);
renderApp({ key: frontendReloadCount });
if (__DEV__) {
    if ((module as any).hot) {
        (module as any).hot.accept();
        // (module as any).hot.accept('backend_reload', () => {
        //     // log.debug('Reloading front-end');
        //     // when the backend restarts wait for 5 seconds
        //     setTimeout(() => window.location.reload(), 5000);
        //     // window.location.reload();
        // });
        (module as any).hot.accept((err) => {
            if (err) {
                console.error('Cannot apply HMR update.', err);
            }
        });
        //  React-hot-loader v4 doesn't require following code any more.
        //  but if RHL not working we can uncomment below code to make normal HMR to refresh the page
        (module as any).hot.accept('./app/Main', () => {
            try {
                console.log('Updating front-end');
                frontendReloadCount = (frontendReloadCount || 0) + 1;

                renderApp({ key: frontendReloadCount });
            } catch (err) {
                // log(err.stack);
            }
        });
    }
}

```

# portable-devices/desktop/src/renderer/about.tsx

```tsx
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import './config/public-config';
import About from './app/About';
import 'antd/dist/antd.css';

// Virtual (module as any), generated in-memory by zenjs, contains count of backend rebuilds
// tslint:disable-next-line
// import 'backend_reload';

const rootEl = document.getElementById('app');
let frontendReloadCount = 0;

const renderApp = ({ key }: { key: number }) => ReactDOM.render(<About key={key} />, rootEl);
renderApp({ key: frontendReloadCount });
if (__DEV__) {
    if ((module as any).hot) {
        (module as any).hot.accept();
        // (module as any).hot.accept('backend_reload', () => {
        //     // log.debug('Reloading front-end');
        //     // when the backend restarts wait for 5 seconds
        //     setTimeout(() => window.location.reload(), 5000);
        //     // window.location.reload();
        // });
        (module as any).hot.accept((err) => {
            if (err) {
                console.error('Cannot apply HMR update.', err);
            }
        });
        //  React-hot-loader v4 doesn't require following code any more.
        //  but if RHL not working we can uncomment below code to make normal HMR to refresh the page
        (module as any).hot.accept('./app/About', () => {
            try {
                console.log('Updating front-end');
                frontendReloadCount = (frontendReloadCount || 0) + 1;

        renderApp({ key: frontendReloadCount });
      } catch (err) {
        // log(err.stack);
      }
    });
  }
}

```

# portable-devices/desktop/src/main/menu-template.ts

```ts
import { format as formatUrl } from 'url';
import { app, shell, ipcMain } from 'electron';
import { IPC_EVENTS } from '../common';

export const template: Electron.MenuItemConstructorOptions[] = [
    {
        label: 'Edit',
        submenu: [
            { role: 'undo' },
            { role: 'redo' },
            { type: 'separator' },
            { role: 'cut' },
            { role: 'copy' },
            { role: 'paste' },
            { role: 'pasteAndMatchStyle' },
            { role: 'delete' },
            { role: 'selectAll' },
        ],
    },
    {
        label: 'View',
        submenu: [
            { role: 'reload' },
            { role: 'forceReload' },
            { role: 'toggleDevTools' },
            { type: 'separator' },
            { role: 'resetZoom' },
            { role: 'zoomIn' },
            { role: 'zoomOut' },
            { type: 'separator' },
            { role: 'togglefullscreen' },
        ],
    },
    { role: 'window', submenu: [{ role: 'minimize' }, { role: 'close' }] },
    {
        role: 'help',
        submenu: [
            {
                label: 'Learn More',
                click() {
                    require('electron').shell.openExternal('https://electron.atom.io');
                },
            },
            {
                label: 'about', role: 'about'
                // click() {
                //     ipcMain.emit(IPC_EVENTS.SHOW_ABOUT);
                // },
            },
        ],
    },
];

```

# portable-devices/desktop/src/main/index.ts

```ts
import { bootstrap } from './bootstrap';

bootstrap().catch(console.error);

```

# portable-devices/desktop/src/main/bootstrap.ts

```ts
import { app, protocol } from 'electron';
import { dev } from 'electron-is';

import { createLogProxy } from '../common';
import { getLogger } from './utils';
import { loadContainerAsync } from './ioc';
import { createClientContainer } from './config/client.service';
import { App } from './app';
import { createReduxStore } from './config/redux-electron-config';

/**
 * Operation before initialization
 */
const beforeInit = async () => {
    // Registration Agreement
    protocol.registerSchemesAsPrivileged([{ scheme: 'app', privileges: { secure: true, standard: true } }]);

    // control singleton
    const isSingle = app.requestSingleInstanceLock();
    if (!isSingle) {
        app.exit(0);
    }

    // Replace error logger
    if (!dev()) {
        console.error = createLogProxy('error', getLogger('error'))(console.error);
    }

    // Initialize the database part
    const baseContainer = await loadContainerAsync();
    return baseContainer;
};

/**
 * Start method
 */
export const bootstrap = async () => {
    const baseContainer = await beforeInit();
    const { container } = createClientContainer();
    container.parent = baseContainer;
    container.get(App);
    createReduxStore();
};

```

# portable-devices/desktop/src/common/index.ts

```ts
export * from './channel';
export * from './utils';
export * from './constants';

```

# portable-devices/desktop/src/common/channel.ts

```ts
export const CHANNELS = {
    CHECK_ACCESSIBILITY_FOR_MAC_OS: 'CHECK_ACCESSIBILITY_FOR_MAC_OS',
};

```

# portable-devices/desktop/assets/icons/icon-256.png

This is a binary file of the type: Image

# portable-devices/desktop/assets/icons/icon-22.png

This is a binary file of the type: Image

# portable-devices/desktop/assets/icons/96x96.png

This is a binary file of the type: Image

# portable-devices/desktop/assets/icons/64x64.png

This is a binary file of the type: Image

# portable-devices/desktop/assets/icons/512x512.png

This is a binary file of the type: Image

# portable-devices/desktop/assets/icons/48x48.png

This is a binary file of the type: Image

# portable-devices/desktop/assets/icons/32x32.png

This is a binary file of the type: Image

# portable-devices/desktop/assets/icons/256x256.png

This is a binary file of the type: Image

# portable-devices/desktop/assets/icons/24x24.png

This is a binary file of the type: Image

# portable-devices/desktop/assets/icons/16x16.png

This is a binary file of the type: Image

# portable-devices/desktop/assets/icons/128x128.png

This is a binary file of the type: Image

# portable-devices/desktop/assets/icons/1024x1024.png

This is a binary file of the type: Image

# portable-devices/desktop/assets/html/tray-page.html

```html
<!DOCTYPE html>
<html>

<head>
  <script>require("source-map-support/source-map-support.js").install()</script>
  <link href="styles.css" rel="stylesheet">
  <script type='text/javascript'>
    window.ipcRenderer = require('electron').ipcRenderer;
  </script>
</head>

<body>
  <div id="app"></div>

  <script type='text/javascript'>
    var bundlePath = './tray.js';
    if (process.env.NODE_ENV === 'development') {
      bundlePath = `http://${process.env.ELECTRON_WEBPACK_WDS_HOST}:${process.env.ELECTRON_WEBPACK_WDS_PORT}/tray.js`;
    }

    var js_script = document.createElement('script');
    js_script.src = bundlePath;
    js_script.async = true;
    document.body.appendChild(js_script);

  </script>
</body>

</html>
```

# portable-devices/desktop/assets/html/main-page.html

```html
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>SampleDesktop</title>
  <script>require("source-map-support/source-map-support.js").install()</script>
  <link href="styles.css" rel="stylesheet">
</head>

<body>
  <div id="app" />
  <script type='text/javascript'>
    var bundlePath = './renderer.js';
    if (process.env.NODE_ENV === 'development') {
      bundlePath = `http://${process.env.ELECTRON_WEBPACK_WDS_HOST}:${process.env.ELECTRON_WEBPACK_WDS_PORT}/renderer.js`;
    }

    var js_script = document.createElement('script');
    js_script.src = bundlePath;
    js_script.async = true;
    document.body.appendChild(js_script);

  </script>
</body>

</html>
```

# portable-devices/desktop/assets/html/about-page.html

```html
<!DOCTYPE html>
<html>
  <head>
    <script type='text/javascript'>
      window.shell = require('electron').shell;
      window.remote = require('electron').remote;
    </script>
  </head>

  <body>

    <div id='app'></div>
    <script type='text/javascript'>
      var bundlePath = './about.js';
      if (process.env.NODE_ENV === 'development') { 
        bundlePath = `http://${process.env.ELECTRON_WEBPACK_WDS_HOST}:${process.env.ELECTRON_WEBPACK_WDS_PORT}/about.js`;
      }
  
      var js_script = document.createElement('script');
      js_script.src = bundlePath;
      js_script.async = true;
      document.body.appendChild(js_script);
  
    </script>


    <style type="text/css">
      #header {
        -webkit-user-select: none;
        -webkit-app-region: drag;

        background-color: blue;
      }
    </style>

    <script type='text/javascript'>
     document.getElementById("open-external").addEventListener("click", function (e) {
        e.preventDefault();
        var remoteLink = this.getAttribute('href');
        shell.openExternal( remoteLink );
      });



       document.getElementById("close").addEventListener("click", function (e) {
        remote.getCurrentWindow().hide();
       });

       document.getElementById("hide").addEventListener("click", function (e) {
        remote.getCurrentWindow().minimize();
       });

       document.getElementById("maximize").addEventListener("click", function (e) {
        if (remote.getCurrentWindow().isMaximized()) {
          remote.getCurrentWindow().unmaximize();
        } else {
          remote.getCurrentWindow().maximize();
        }
       })
    </script>
  </body>
</html>
```

# packages-modules/counter/server/src/module.ts

```ts
import { Feature } from '@common-stack/server-core';
import { interfaces } from 'inversify';
import schema from './schema/schema.graphql';
import { ICounterService, IService } from './interfaces';
import { resolver } from './resolvers';
import { localCounterModule, externalCounterModule } from './containers';
import { CounterMockMoleculerService } from './services';
import { TYPES } from './constants';
import { CounterDataSource } from './dataloader';

const counterServiceGen = (container: interfaces.Container): IService => {
    return {
        counterMockService: container.getNamed<ICounterService>(TYPES.CounterMockService, 'proxy'),
    };
};

const dataSources: (container: interfaces.Container) => any = () => {
    return {
        counterCache: new CounterDataSource(),
    };
};

export default new Feature({
    schema,
    createContainerFunc: [localCounterModule],
    createResolversFunc: resolver,
    createServiceFunc: counterServiceGen,
    // createContextFunc: () => ({ counterMock: counterMock }), // note anything set here should be singleton.
    createDataSourceFunc: dataSources,
    createHemeraContainerFunc: [externalCounterModule],
    addBrokerClientServiceClass: [CounterMockMoleculerService],
    addBrokerMainServiceClass: [],
});


```

# packages-modules/counter/server/src/index.ts

```ts
import { Feature } from '@common-stack/server-core';
import counter from './module';

export { CounterMockMoleculerService } from './services';
export * from './constants';
export default new Feature(counter);

```

# packages-modules/counter/server/src/generated-models.ts

```ts
/* tslint:disable */

import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';

export type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    AnyObject: any;
    JSON: any;
    JSONObject: any;
    Date: any;
    Time: any;
    DateTime: any;
};

export type ClientCounter = {
    counter?: Maybe<Scalars['Int']>;
};

export type Counter = {
    amount: Scalars['Int'];
};

export type FieldError = {
    field: Scalars['String'];
    message: Scalars['String'];
};

export type Mutation = {
    dummy?: Maybe<Scalars['Int']>;
    addCounterState?: Maybe<ClientCounter>;
    addCounter?: Maybe<Counter>;
};

export type MutationAddCounterStateArgs = {
    amount: Scalars['Int'];
};

export type MutationAddCounterArgs = {
    amount?: Maybe<Scalars['Int']>;
};

export type Node = {
    id: Scalars['ID'];
};

export type Query = {
    dummy?: Maybe<Scalars['Int']>;
    counterState?: Maybe<ClientCounter>;
    counter?: Maybe<Counter>;
};

export type Subscription = {
    dummy?: Maybe<Scalars['Int']>;
    counterUpdated?: Maybe<Counter>;
};

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => Promise<TResult> | TResult;

export type StitchingResolver<TResult, TParent, TContext, TArgs> = {
    fragment: string;
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ResolverFn<TResult, TParent, TContext, TArgs>
    | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs>;
    resolve?: SubscriptionResolveFn<TResult, TParent, TContext, TArgs>;
}

export type SubscriptionResolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ((...args: any[]) => SubscriptionResolverObject<TResult, TParent, TContext, TArgs>)
    | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
    parent: TParent,
    context: TContext,
    info: GraphQLResolveInfo,
) => Maybe<TTypes>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
    next: NextResolverFn<TResult>,
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
    Query: {};
    Int: Scalars['Int'];
    ClientCounter: ClientCounter;
    Counter: Counter;
    Mutation: {};
    Subscription: {};
    String: Scalars['String'];
    Boolean: Scalars['Boolean'];
    AnyObject: Scalars['AnyObject'];
    JSON: Scalars['JSON'];
    JSONObject: Scalars['JSONObject'];
    FieldError: FieldError;
    Node: Node;
    ID: Scalars['ID'];
    Date: Scalars['Date'];
    Time: Scalars['Time'];
    DateTime: Scalars['DateTime'];
};

export interface AnyObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['AnyObject'], any> {
    name: 'AnyObject';
}

export type ClientCounterResolvers<ContextType = any, ParentType = ResolversTypes['ClientCounter']> = {
    counter?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
};

export type CounterResolvers<ContextType = any, ParentType = ResolversTypes['Counter']> = {
    amount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
};

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
    name: 'Date';
}

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
    name: 'DateTime';
}

export type FieldErrorResolvers<ContextType = any, ParentType = ResolversTypes['FieldError']> = {
    field?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
    name: 'JSON';
}

export interface JsonObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSONObject'], any> {
    name: 'JSONObject';
}

export type MutationResolvers<ContextType = any, ParentType = ResolversTypes['Mutation']> = {
    dummy?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    addCounterState?: Resolver<
        Maybe<ResolversTypes['ClientCounter']>,
        ParentType,
        ContextType,
        MutationAddCounterStateArgs
    >;
    addCounter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType, MutationAddCounterArgs>;
};

export type NodeResolvers<ContextType = any, ParentType = ResolversTypes['Node']> = {
    __resolveType: TypeResolveFn<null, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType = ResolversTypes['Query']> = {
    dummy?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    counterState?: Resolver<Maybe<ResolversTypes['ClientCounter']>, ParentType, ContextType>;
    counter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
};

export type SubscriptionResolvers<ContextType = any, ParentType = ResolversTypes['Subscription']> = {
    dummy?: SubscriptionResolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    counterUpdated?: SubscriptionResolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
};

export interface TimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Time'], any> {
    name: 'Time';
}

export type Resolvers<ContextType = any> = {
    AnyObject?: GraphQLScalarType;
    ClientCounter?: ClientCounterResolvers<ContextType>;
    Counter?: CounterResolvers<ContextType>;
    Date?: GraphQLScalarType;
    DateTime?: GraphQLScalarType;
    FieldError?: FieldErrorResolvers<ContextType>;
    JSON?: GraphQLScalarType;
    JSONObject?: GraphQLScalarType;
    Mutation?: MutationResolvers<ContextType>;
    Node?: NodeResolvers;
    Query?: QueryResolvers<ContextType>;
    Subscription?: SubscriptionResolvers<ContextType>;
    Time?: GraphQLScalarType;
};

/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
 */
export type IResolvers<ContextType = any> = Resolvers<ContextType>;

```

# packages-modules/counter/mobile/typings/graphql.d.ts

```ts
declare module "*/AddCounter.client.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const addCounterState: DocumentNode;

  export default defaultDocument;
}

declare module "*/AddCounter.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const addCounter: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterQuery.client.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const CounterState: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterQuery.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const counterQuery: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterSubscription.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const onCounterUpdated: DocumentNode;

  export default defaultDocument;
}

```

# packages-modules/counter/mobile/src/index.ts

```ts
import { Feature } from '@common-stack/client-react';
import ConnectedReactRouter from './connected-react-router/index';

export default new Feature(ConnectedReactRouter);

```

# portable-devices/mobile/src/screens/NotFoundScreen.tsx

```tsx
import { StackScreenProps } from '@react-navigation/stack';
import * as React from 'react';
import { StyleSheet, Text, TouchableOpacity, View } from 'react-native';

import { RootStackParamList } from '../types';

export default function NotFoundScreen({
  navigation,
}: StackScreenProps<RootStackParamList, 'NotFound'>) {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>This screen doesn't exist.</Text>
      <TouchableOpacity onPress={() => navigation.replace('Root')} style={styles.link}>
        <Text style={styles.linkText}>Go to home screen!</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
  linkText: {
    fontSize: 14,
    color: '#2e78b7',
  },
});

```

# portable-devices/mobile/src/pages/index.ts

```ts
import Dashboard from './dashboard';
import Hello from './hello';

export { Dashboard, Hello };

```

# portable-devices/mobile/src/pages/hello.tsx

```tsx
import React from 'react';
import { StyleSheet, View, Text, ViewStyle } from 'react-native';
import { Footer, Content } from 'native-base';
import { connect } from 'react-redux';

interface Style {
    container: ViewStyle;
}

const HelloScreen = () => {
    return (
        <View style={styles.container}>
            <Content>
                <Text>Hello Value</Text>
            </Content>
            <Footer style={{ position: 'absolute', left: 0, right: 0, bottom: 0 }}>
                <View>
                    <Text>Footer will be here</Text>
                </View>
            </Footer>
        </View>
    );
};

const styles = StyleSheet.create<Style>({
    container: {
        flex: 1,
        textAlign: 'center',
    },
});

const Hello = connect((state: any) => {
    return {
        settings: state.settings,
        location: state?.route?.location,
    };
})(HelloScreen);

export default Hello;

```

# portable-devices/mobile/src/pages/dashboard.tsx

```tsx
import React from "react"
import {StyleSheet, View, Text, ViewStyle} from "react-native"
import { Link } from 'react-router-native';
interface Style {
    container: ViewStyle
}

const Dashboard = () => {
    return(
        <View style={styles.container}>
            <Text>Dashboard Value</Text>
            <Link to={'/org/counter'}><Text>Calendar</Text></Link>
        </View>
    )
}

const styles = StyleSheet.create<Style>({
    container:{
        textAlign: 'center'
    }
})

export default Dashboard;

```

# portable-devices/mobile/src/modules/render.tsx

```tsx
import * as React from 'react';
import { useEffect, useState, createElement } from 'react';
// import { Plugin, ApplyPluginsType } from '@umijs/runtime';
import { IRoute, IComponent } from '@common-stack/client-react';
import { Switch, Route, Redirect } from 'react-router-native';

interface IOpts {
  routes: IRoute[];
  plugin?: Plugin;
  extraProps?: object;
  pageInitialProps?: object;
  getInitialPropsCtx?: object;
  isServer?: boolean;
  ssrProps?: object;
  rootRoutes?: IRoute[];
}

interface IGetRouteElementOpts {
  route: IRoute;
  index: number;
  opts: IOpts;
}

function wrapInitialPropsFetch(route: IRoute, opts: IOpts): IComponent {
  const { component, ...restRouteParams } = route;
  let Component: any = route.component;
  function ComponentWithInitialPropsFetch(props: any) {
    const [initialProps, setInitialProps] = useState(() => (window as any).g_initialProps);

    useEffect(() => {
      /**
       * 1. 首次渲染时，此时 window.g_initialProps 变量存在，不需要再走一次 getInitialProps，这样一次 SSR 就走了 2 次 getInitialProps
       * 2. 但是路由切换时，window.getInitialProps 会被赋为 null，这时候就走 getInitialProps 逻辑
       * 3. 如果任何时候都走 2 次，配置 forceInitial: true，这个场景用于静态站点的首屏加载希望走最新数据
       * 4. 开启动态加载后，会在执行 getInitialProps 前预加载下
       */
      const handleGetInitialProps = async () => {
        // preload when enalbe dynamicImport
        if (Component.preload) {
          const preloadComponent = await Component.preload();
          // for test case, really use .default
          Component = preloadComponent.default || preloadComponent;
        }

        // @sri not suppported
        // const defaultCtx = {
        //   isServer: false,
        //   match: props?.match,
        //   route,
        //   ...(opts.getInitialPropsCtx || {}),
        //   ...restRouteParams,
        // };
        // @sri not suppported
        // if (Component?.getInitialProps) {
        //   const ctx = await opts.plugin.applyPlugins({
        //     key: 'ssr.modifyGetInitialPropsCtx',
        //     type: ApplyPluginsType.modify,
        //     initialValue: defaultCtx,
        //     async: true,
        //   });

        //   const initialProps = await Component!.getInitialProps!(
        //     ctx || defaultCtx,
        //   );
        //   setInitialProps(initialProps);
        // }
      };
      // null 时，一定会触发 getInitialProps 执行
      if (!(window as any).g_initialProps) {
        handleGetInitialProps();
      }
    }, [window.location.pathname, window.location.search]);
    return <Component {...props} {...initialProps} />;
  }
  // flag for having wrappered
  ComponentWithInitialPropsFetch.wrapInitialPropsLoaded = true;
  ComponentWithInitialPropsFetch.displayName = 'ComponentWithInitialPropsFetch';
  return ComponentWithInitialPropsFetch;
}

function render({ route, opts, props }: { route: IRoute; opts: IOpts; props: object }) {
  const routes = renderRoutes({
    ...opts,
    routes: route.routes || [],
    rootRoutes: opts.rootRoutes,
  });
  const { component: Component, wrappers } = route;
  if (Component) {
    const defaultPageInitialProps = opts.isServer ? {} : (window as any).g_initialProps;
    const newProps = {
      ...props,
      ...opts.extraProps,
      ...(opts.pageInitialProps || defaultPageInitialProps),
      route,
      routes: opts.rootRoutes,
    };
    // @ts-ignore
    let ret = <Component {...newProps}>{routes}</Component>;

    // route.wrappers
    if (wrappers) {
      let len = wrappers.length - 1;
      while (len >= 0) {
        ret = createElement(wrappers[len], newProps, ret);
        len -= 1;
      }
    }

    return ret;
  }
  return routes;
}

function getRouteElement({ route, index, opts }: IGetRouteElementOpts) {
  const routeProps = {
    key: route.key || index,
    exact: route.exact,
    strict: route.strict,
    sensitive: route.sensitive,
    path: route.path,
  };
  if (route.redirect) {
    return <Redirect {...routeProps} from={route.path} to={route.redirect} />;
  }
  // avoid mount and unmount with url hash change
  // @sri not supproted yet
  // if (
  //   // only when SSR config enable
  //   opts.ssrProps &&
  //   !opts.isServer &&
  //   // make sure loaded once
  //   !(route.component as any)?.wrapInitialPropsLoaded &&
  //   (route.component?.getInitialProps || route.component?.preload)
  // ) {
  //   // client Render for enable ssr, but not sure SSR success
  //   route.component = wrapInitialPropsFetch(route, opts);
  // }
  return (
    <Route
      {...routeProps}
      render={(props: object) => {
        return render({ route, opts, props });
      }}
    />
  );
}

function renderRoutes(opts: IOpts) {
  return opts.routes ? (
    <Switch>
      {opts.routes.map((route, index) => {
        const renderedR = getRouteElement({
          route,
          index,
          opts: {
            ...opts,
            rootRoutes: opts.rootRoutes || opts.routes,
          },
        });
        return renderedR;
      })}
    </Switch>
  ) : null;
}

export { renderRoutes as renderRoutes2 };

```

# portable-devices/mobile/src/modules/modules.tsx

```tsx
import * as React from 'react';
import { Feature, FeatureWithRouterFactory } from '@common-stack/client-react';
import counterModule from '@sample-stack/counter-module-mobile';
import { StatusBar } from 'expo-status-bar';
import { enableScreens } from 'react-native-screens';
import { Route } from 'react-router-native';
import LayoutModule from '../components/layout/module';
import { renderRoutes2 } from './render';

const features = new Feature(FeatureWithRouterFactory, LayoutModule, counterModule);
const configuredRoutes = features.getConfiguredRoutes();
const routes = renderRoutes2({ routes: configuredRoutes }) || [];
enableScreens();

export const MainRoute = () => {
  /**
   * when used renderRoutes2 opts.routes come as empty need to debug that
   * for now using switch directly inroder to render routes properly.
   */
  return (
    <>
      {routes}
    </>
  );
};

export default features;

```

# portable-devices/mobile/src/modules/index.ts

```ts
/* eslint-disable import/no-cycle */
/* eslint-disable @typescript-eslint/no-var-requires */
import { ClientTypes } from '@common-stack/client-react';
import { logger } from '@cdm-logger/client';
import modules, { MainRoute } from './modules';

Object.assign(global, require('../../build.config'));


class UtilityClass {
    // tslint:disable-next-line:no-shadowed-variable
    constructor(private modules) {}

    public getCacheKey(storeObj) {
        return this.modules.getDataIdFromObject(storeObj);
    }
}

const utility = new UtilityClass(modules);
// additional bindings to container
const container = modules.createContainers({}) as any;
container.bind(ClientTypes.Logger).toConstantValue(logger);
container.bind(ClientTypes.UtilityClass).toConstantValue(utility);

export default modules;
export { MainRoute, container, logger };

```

# portable-devices/mobile/src/hooks/useColorScheme.web.ts

```ts
// useColorScheme from react-native does not support web currently. You can replace
// this with react-native-appearance if you would like theme support on web.
export default function useColorScheme() {
    return 'light';
}

```

# portable-devices/mobile/src/hooks/useColorScheme.ts

```ts
import { ColorSchemeName, useColorScheme as _useColorScheme } from 'react-native';

// The useColorScheme value is always either light or dark, but the built-in
// type suggests that it can be null. This will not happen in practice, so this
// makes it a bit easier to work with.
export default function useColorScheme(): NonNullable<ColorSchemeName> {
    return _useColorScheme();
}

```

# portable-devices/mobile/src/hooks/useCachedResources.ts

```ts
import { Ionicons } from '@expo/vector-icons';
import * as Font from 'expo-font';
import * as SplashScreen from 'expo-splash-screen';
import * as React from 'react';

export default function useCachedResources() {
    const [isLoadingComplete, setLoadingComplete] = React.useState(false);

    // Load any resources or data that we need prior to rendering the app
    React.useEffect(() => {
        async function loadResourcesAndDataAsync() {
            try {
                SplashScreen.preventAutoHideAsync();

                // Load fonts
                await Font.loadAsync({
                    ...Ionicons.font,
                    'space-mono': require('../assets/fonts/SpaceMono-Regular.ttf'),
                });
            } catch (e) {
                // We might want to provide this error information to an error reporting service
                console.warn(e);
            } finally {
                setLoadingComplete(true);
                SplashScreen.hideAsync();
            }
        }

        loadResourcesAndDataAsync();
    }, []);

    return isLoadingComplete;
}

```

# portable-devices/mobile/src/constants/Layout.ts

```ts
import { Dimensions } from 'react-native';

const { width } = Dimensions.get('window');
const { height } = Dimensions.get('window');

export default {
    window: {
        width,
        height,
    },
    isSmallDevice: width < 375,
};

```

# portable-devices/mobile/src/constants/Colors.ts

```ts
const tintColorLight = '#2f95dc';
const tintColorDark = '#fff';

export default {
    light: {
        text: '#000',
        background: '#fff',
        tint: tintColorLight,
        tabIconDefault: '#ccc',
        tabIconSelected: tintColorLight,
    },
    dark: {
        text: '#fff',
        background: '#000',
        tint: tintColorDark,
        tabIconDefault: '#ccc',
        tabIconSelected: tintColorDark,
    },
};

```

# portable-devices/mobile/src/config/router-history.ts

```ts
import { createMemoryHistory } from 'history';

const hist = createMemoryHistory();

export default hist;

```

# portable-devices/mobile/src/config/redux-config.ts

```ts
import storage from '@react-native-async-storage/async-storage';
import autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2';
import { createEpicMiddleware } from 'redux-observable';
import { connectRouter, routerMiddleware } from 'connected-react-router';
import { createReduxStore as createBaseReduxStore } from './base-redux-config';
import modules, { logger } from '../modules';
import { rootEpic } from './epic-config';
import history from './router-history';
import { createClientContainer } from './client.service';

export { history };
const { apolloClient, container, services } = createClientContainer();

export const epicMiddleware = createEpicMiddleware({
    dependencies: {
        apolloClient,
        routes: modules.getConfiguredRoutes(),
        services,
        container,
        logger,
    },
});

export const persistConfig = {
    key: 'root',
    storage,
    stateReconciler: autoMergeLevel2,
    transforms: modules.reduxPersistStateTransformers,
};

/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = () => {
    // middleware
    const router = connectRouter(history);

    const store = createBaseReduxStore({
        scope: 'browser',
        isDebug: __DEBUGGING__,
        isDev: process.env.NODE_ENV === 'development',
        initialState: {},
        persistConfig,
        middleware: [routerMiddleware(history)],
        epicMiddleware,
        rootEpic: rootEpic as any,
        reducers: { router, ...modules.reducers },
    });
    container.bind('ReduxStore').toConstantValue(store);

    return store;
};

```

# portable-devices/mobile/src/config/public-config.ts

```ts
import { NODE_ENV, GRAPHQL_URL, FACEBOOK_APP_ID, GA_ID, LOG_LEVEL } from '@env';

const env = {
    NODE_ENV,
    GRAPHQL_URL,
    FACEBOOK_APP_ID,
    GA_ID,
    LOG_LEVEL,
    LOCAL_GRAPHQL_URL: GRAPHQL_URL,
    $typeof: 'null', // bug https://github.com/af/envalid/issues/150
};

const isBrowser = typeof window !== 'undefined';

export default env;

if (isBrowser) {
    // process.env = env;
    process.APP_ENV = env;
}

export const PUBLIC_SETTINGS: __PUBLIC_SETTINGS__ = {
    apolloLogging: false,
    GRAPHQL_URL: env.GRAPHQL_URL,
    LOCAL_GRAPHQL_URL: env.LOCAL_GRAPHQL_URL,
    LOG_LEVEL: env.LOG_LEVEL || 'trace',
};

```

# portable-devices/mobile/src/config/index.ts

```ts
import { LOG_LEVEL } from '@env';

const config = {
    LOG_LEVEL,
};

export default config;

```

# portable-devices/mobile/src/config/fela-renderer.ts

```ts
import { createRenderer, IRenderer } from 'fela';
import webPreset from 'fela-preset-web';

export default () => {
    const renderer = createRenderer({
        plugins: [...webPreset],
        devMode: process.env.NODE_ENV ? process.env.NODE_ENV !== 'production' : false,
    });
    renderer.renderStatic(
        `
        html, body, #demo, .content{
            height: 100%;
          }
          body {
            background-color: #fff;
            color: #ccc;
            padding: 0;
            margin: 0;
            font-family: sans-serif;
            font-size: 13px;
          }
          div, a {
            outline: none !important;
          }
          a {
            text-decoration: none;
            cursor: pointer;
          }
          footer {
            position:fixed;
            bottom: 0;
            left: 0;
            right:0;
            height: 20px;
            background: #007acc;
          }
          footer > .container {
            padding: 2px;
          }
          #content {
            height: calc(100vh - 20px);
          }
          #container {
            height: 100%;
          }
          .editor-container {
            height: 100%;
            overflow: hidden;
          }
          .error {
            color: orangered;
          }
        `,
    );

    return renderer;
};

```

# portable-devices/mobile/src/config/epic-config.ts

```ts
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-call */
import { combineEpics, ofType } from 'redux-observable';
import { BehaviorSubject } from 'rxjs';
import { mergeMap, takeUntil } from 'rxjs/operators';
import modules from '../modules';

export const epic$ = new BehaviorSubject(combineEpics(...modules.epics));

// Since we're using mergeMap, by default any new
// epic that comes in will be merged into the previous
// one, unless an EPIC_END action is dispatched first,
// which would cause the old one(s) to be unsubscribed
export const rootEpic = (action$, ...rest) =>
    epic$.pipe(mergeMap((epic) => epic(action$, ...rest).pipe(takeUntil(action$.pipe(ofType('EPIC_END'))))));

```

# portable-devices/mobile/src/config/config.ts

```ts

```

# portable-devices/mobile/src/config/client.service.ts

```ts
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ClientTypes } from '@common-stack/client-core';
import { Container } from 'inversify';
import { ApolloClient } from '@apollo/client';
import { CdmLogger } from '@cdm-logger/core';
import modules, { container, logger } from '../modules';
import { createApolloClient } from './base-apollo-client';
import { PUBLIC_SETTINGS } from './public-config';

let __CLIENT_SERVICE__: {
    apolloClient: ApolloClient<any>;
    container: Container;
    services: any;
    logger: CdmLogger.ILogger
};
export const createClientContainer = () => {
    if (__CLIENT_SERVICE__) {
        return __CLIENT_SERVICE__;
    }
    const clientState = modules.getStateParams({ resolverContex: () => modules.createService({}, {}) });
    const { cache, apolloClient } = createApolloClient({
        httpGraphqlURL: PUBLIC_SETTINGS.GRAPHQL_URL,
        httpLocalGraphqlURL: PUBLIC_SETTINGS.LOCAL_GRAPHQL_URL,
        isDev: process.env.NODE_ENV === 'development',
        isDebug: __DEBUGGING__,
        isSSR: __SSR__,
        scope: 'browser',
        clientState,
        getDataIdFromObject: (result) => modules.getDataIdFromObject(result),
        initialState: null,
        logger,
    });
    // attaching the context to client as a workaround.
    container.bind(ClientTypes.ApolloClient).toConstantValue(apolloClient);
    container.bind(ClientTypes.InMemoryCache).toConstantValue(cache);
    const services = modules.createService({}, {});
    (apolloClient as any).container = services;

    __CLIENT_SERVICE__ = {
        container,
        apolloClient,
        services,
        logger,
    };
    return __CLIENT_SERVICE__;
};

```

# portable-devices/mobile/src/config/base-redux-config.ts

```ts
// version 11/12/2021
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable global-require */
/* eslint-disable no-underscore-dangle */
import {
    createStore,
    combineReducers,
    applyMiddleware,
    StoreEnhancer,
    Middleware,
    compose,
    Action,
    ReducersMapObject,
    PreloadedState,
} from 'redux';
import { EpicMiddleware, Epic } from 'redux-observable';
import { persistReducer, PersistConfig } from 'redux-persist';

interface IReduxStore<S = any> {
    scope: 'browser' | 'server' | 'native' | 'ElectronMain';
    isDebug: boolean;
    isDev: boolean;
    reducers: ReducersMapObject<S>;
    rootEpic?: Epic<Action<S>, Action<any>, void, any>;
    epicMiddleware?: EpicMiddleware<Action<S>, Action<any>>;
    preMiddleware?: Middleware[];
    postMiddleware?: Middleware[];
    middleware?: Middleware[];
    initialState: PreloadedState<S>;
    persistConfig?: PersistConfig<S, any>;
}
/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = ({
    scope,
    isDebug,
    isDev,
    reducers,
    rootEpic,
    epicMiddleware,
    preMiddleware,
    postMiddleware,
    middleware,
    initialState = {},
    persistConfig,
}: IReduxStore<any>) => {
    const isBrowser = scope === 'browser';
    const isElectronMain = scope === 'ElectronMain';
    /**
     * Add middleware that required for this app.
     */

    const middlewares: Middleware[] = [];
    // add epicMiddleware
    if (epicMiddleware) {
        middlewares.push(epicMiddleware);
    }
    if (preMiddleware) {
        middlewares.unshift(...preMiddleware);
    }
    // Add redux logger during development only
    if ((isDev || isDebug) && isBrowser) {
        const { createLogger } = require('redux-logger');

        middlewares.push(
            createLogger({
                level: 'info',
                collapsed: true,
            }),
        );
    }

    if (middleware) {
        middlewares.push(...middleware);
    }

    if (postMiddleware) {
        middlewares.push(...postMiddleware);
    }

    const enhancers: () => StoreEnhancer<any>[] = () => [applyMiddleware(...middlewares)];

    const composeEnhancers: any =
        ((isDev || isDebug) && isBrowser && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) || compose;

    const rootReducer = combineReducers(reducers);
    const persistedReducer = persistConfig ? persistReducer(persistConfig, rootReducer) : rootReducer;

    const store = createStore(persistedReducer, initialState, composeEnhancers(...enhancers()));
    if (isBrowser || isElectronMain) {
        // no SSR for now
        if (epicMiddleware) {
            epicMiddleware.run(rootEpic);
        }
    }

    return store;
};

```

# portable-devices/mobile/src/config/base-apollo-client.ts

```ts
// version 09/18/2021
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
import { ApolloClient, ApolloClientOptions, ApolloLink } from '@apollo/client';
import { InMemoryCache } from '@apollo/client/cache';
import { HttpLink, createHttpLink } from '@apollo/client/link/http';
import { BatchHttpLink } from '@apollo/client/link/batch-http';
import { onError } from '@apollo/client/link/error';
import { WebSocketLink } from '@apollo/client/link/ws';
import { getOperationAST } from 'graphql';
import { invariant } from 'ts-invariant';
import { IClientState } from '@common-stack/client-core';
import fetch from 'node-fetch';
import { ConnectionParams } from 'subscriptions-transport-ws';
import { isBoolean, merge } from 'lodash';
import { CdmLogger } from '@cdm-logger/core';
import { RetryLink } from '@apollo/client/link/retry';

const schema = `

`;

interface IApolloClientParams {
    initialState?: any;
    scope: 'browser' | 'server' | 'native';
    getDataIdFromObject: (x?: any) => string;
    clientState: IClientState;
    isDebug: boolean;
    isDev: boolean;
    isSSR: boolean;
    httpGraphqlURL: string;
    httpLocalGraphqlURL: string;
    logger: CdmLogger.ILogger;
}

const errorLink = onError(({ graphQLErrors, networkError }) => {
    if (graphQLErrors) {
        graphQLErrors.map(({ message, locations, path }) =>
            // tslint:disable-next-line
            invariant.warn(`[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`),
        );
    }
    if (networkError) {
        // tslint:disable-next-line
        invariant.warn(`[Network error]: ${networkError}`);
    }
});

let _apolloClient: ApolloClient<any>;
let _memoryCache: InMemoryCache;
export const createApolloClient = ({
    scope,
    isDev,
    isDebug,
    isSSR,
    getDataIdFromObject,
    clientState,
    httpGraphqlURL,
    httpLocalGraphqlURL,
    initialState,
    logger,
}: IApolloClientParams) => {
    const isBrowser = scope === 'browser';
    const isServer = scope === 'server';
    let link;

    const cache = new InMemoryCache({
        dataIdFromObject: getDataIdFromObject,
        possibleTypes: clientState.possibleTypes,
    });

    const attemptConditions = async (count: number, operation: any, error: Error) => {
        const promises = (clientState.retryLinkAttemptFuncs || []).map((func) => func(count, operation, error));

        try {
            const result = await promises;
            return !!result.find((item) => item && isBoolean(item));
        } catch (e) {
            logger.trace('Error occured in retryLink Attempt condition', e);
            throw e;
        }
    };

    const retrylink = new RetryLink({
        attempts: attemptConditions,
    });

    if (_apolloClient && _memoryCache) {
        // return quickly if client is already created.
        return {
            apolloClient: _apolloClient,
            cache: _memoryCache,
        };
    }
    _memoryCache = cache;
    if (isBrowser) {
        const connectionParams = async () => {
            const param: ConnectionParams = {};
            for (const connectionParam of clientState.connectionParams) {
                merge(param, await connectionParam);
            }
            return param;
        };

        const wsLink = new WebSocketLink({
            uri: httpGraphqlURL.replace(/^http/, 'ws'),
            options: {
                reconnect: true,
                timeout: 20000,
                reconnectionAttempts: 10,
                lazy: true,
                connectionParams,
                connectionCallback: async (error, result) => {
                    if (error) {
                        logger.error(error, '[WS connectionCallback error] %j');
                    }
                    const promises = (clientState.connectionCallbackFuncs || []).map((func) =>
                        func(wsLink, error, result),
                    );
                    try {
                        await promises;
                    } catch (e) {
                        logger.trace('Error occured in connectionCallback condition', e);
                        throw e;
                    }
                },
            },
            inactivityTimeout: 10000,
        });

        link = ApolloLink.split(
            ({ query, operationName }) => {
                if (operationName.endsWith('_WS')) {
                    return true;
                }
                const operationAST = getOperationAST(query as any, operationName);
                return !!operationAST && operationAST.operation === 'subscription';
            },
            wsLink,
            new HttpLink({
                uri: httpGraphqlURL,
            }),
        );
    } else if (isServer) {
        link = new BatchHttpLink({ uri: httpLocalGraphqlURL, fetch: fetch as any });
    } else {
        link = createHttpLink({ uri: httpLocalGraphqlURL, fetch: fetch as any });
    }

    const links = [errorLink, retrylink, ...(clientState.preLinks || []), link];

    // Add apollo logger during development only
    if (isBrowser && (isDev || isDebug)) {
        const apolloLogger = require('apollo-link-logger');
        links.unshift(apolloLogger.default);
    }

    const params: ApolloClientOptions<any> = {
        queryDeduplication: true,
        typeDefs: schema.concat(<string>clientState.typeDefs),
        resolvers: clientState.resolvers as any,
        link: ApolloLink.from(links),
        cache,
        connectToDevTools: isBrowser && (isDev || isDebug),
    };
    if (isSSR) {
        if (isBrowser) {
            if (initialState) {
                cache.restore(initialState);
            }
            params.ssrForceFetchDelay = 100;
        } else if (isServer) {
            params.ssrMode = true;
        }
    }
    _apolloClient = new ApolloClient<any>(params);

    clientState?.defaults?.forEach((x) => {
        if (x.type === 'query') {
            cache.writeQuery(x);
        } else if (x.type === 'fragment') {
            cache.writeFragment(x);
        }
    });

    return { apolloClient: _apolloClient, cache };
};

```

# packages-modules/counter/electron/typings/graphql.d.ts

```ts
declare module "*/AddCounter.client.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const addCounterState: DocumentNode;

  export default defaultDocument;
}

declare module "*/AddCounter.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const addCounter: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterQuery.client.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const CounterState: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterQuery.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const counterQuery: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterSubscription.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const onCounterUpdated: DocumentNode;

  export default defaultDocument;
}

```

# packages-modules/counter/electron/src/index.ts

```ts
import { Feature } from '@common-stack/client-react';
import { connectedReactRouterCounter } from '@sample-stack/counter-module-browser/lib/connected-react-router/redux/reducers/counter';
import { onCountChangedEpic } from './epics';

const ElectronMainModule = new Feature({
    reducer: { connectedReactRouterCounter },
    epic: [onCountChangedEpic],
});

export default new Feature(ElectronMainModule);

```

# packages-modules/counter/browser/typings/graphql.d.ts

```ts
declare module "*/AddCounter.client.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const addCounterState: DocumentNode;

  export default defaultDocument;
}

declare module "*/AddCounter.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const addCounter: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterQuery.client.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const CounterState: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterQuery.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const counterQuery: DocumentNode;

  export default defaultDocument;
}

declare module "*/CounterSubscription.gql" {
  import { DocumentNode } from "graphql";
  const defaultDocument: DocumentNode;
  export const onCounterUpdated: DocumentNode;

  export default defaultDocument;
}

```

# packages-modules/counter/browser/src/index.ts

```ts
import { Feature } from '@common-stack/client-react';

import Common from './common';
import ApolloCounter from './apollo-server-n-client';
import ConnectedReactRouter from './connected-react-router';
import Fela from './fela';
import { ElectronTrayModule } from './connected-react-router/index.electron';

export default new Feature(Common, ConnectedReactRouter, ApolloCounter, Fela);
export { ElectronTrayModule };

```

# packages-modules/counter/browser/src/generated-models.ts

```ts
/* tslint:disable */
import { GraphQLResolveInfo } from 'graphql';
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type RequireFields<T, K extends keyof T> = { [X in Exclude<keyof T, K>]?: T[X] } & { [P in K]-?: NonNullable<T[P]> };
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
};

export type ClientCounter = {
  __typename?: 'ClientCounter';
  counter?: Maybe<Scalars['Int']>;
};

/**  Database counter  */
export type Counter = {
  __typename?: 'Counter';
  /**  Current amount  */
  amount: Scalars['Int'];
};

export type Mutation = {
  __typename?: 'Mutation';
  /**  Increase counter value returns current counter amount  */
  addCounter?: Maybe<Counter>;
  addCounterState?: Maybe<ClientCounter>;
  /**  add Counter  */
  addMoleculerCounter?: Maybe<Counter>;
  /**  sync cached counter with current value  */
  syncCachedCounter?: Maybe<Scalars['Boolean']>;
};


export type MutationAddCounterArgs = {
  amount?: Maybe<Scalars['Int']>;
};


export type MutationAddCounterStateArgs = {
  amount: Scalars['Int'];
};


export type MutationAddMoleculerCounterArgs = {
  amount?: Maybe<Scalars['Int']>;
};

export type Query = {
  __typename?: 'Query';
  /**  Counter  */
  counter?: Maybe<Counter>;
  /**  Counter from Datasource  */
  counterCache?: Maybe<Counter>;
  counterState?: Maybe<ClientCounter>;
  /**  Moleculer Counter  */
  moleculerCounter?: Maybe<Counter>;
};

export type Subscription = {
  __typename?: 'Subscription';
  /**  Subscription fired when anyone increases counter  */
  counterUpdated?: Maybe<Counter>;
  moleculerCounterUpdate?: Maybe<Counter>;
};

export type AddCounterStateMutationVariables = Exact<{
  amount: Scalars['Int'];
}>;


export type AddCounterStateMutation = (
  { __typename?: 'Mutation' }
  & { addCounterState?: Maybe<(
    { __typename?: 'ClientCounter' }
    & Pick<ClientCounter, 'counter'>
  )> }
);

export type AddCounterMutationVariables = Exact<{
  amount: Scalars['Int'];
}>;


export type AddCounterMutation = (
  { __typename?: 'Mutation' }
  & { addCounter?: Maybe<(
    { __typename?: 'Counter' }
    & Pick<Counter, 'amount'>
  )> }
);

export type AddCounter_WsMutationVariables = Exact<{
  amount: Scalars['Int'];
}>;


export type AddCounter_WsMutation = (
  { __typename?: 'Mutation' }
  & { addCounter?: Maybe<(
    { __typename?: 'Counter' }
    & Pick<Counter, 'amount'>
  )> }
);

export type SyncCachedCounterMutationVariables = Exact<{ [key: string]: never; }>;


export type SyncCachedCounterMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'syncCachedCounter'>
);

export type CounterCacheQueryQueryVariables = Exact<{ [key: string]: never; }>;


export type CounterCacheQueryQuery = (
  { __typename?: 'Query' }
  & { counterCache?: Maybe<(
    { __typename?: 'Counter' }
    & Pick<Counter, 'amount'>
  )> }
);

export type CounterStateQueryVariables = Exact<{ [key: string]: never; }>;


export type CounterStateQuery = (
  { __typename?: 'Query' }
  & { counterState?: Maybe<(
    { __typename?: 'ClientCounter' }
    & Pick<ClientCounter, 'counter'>
  )> }
);

export type CounterQueryQueryVariables = Exact<{ [key: string]: never; }>;


export type CounterQueryQuery = (
  { __typename?: 'Query' }
  & { counter?: Maybe<(
    { __typename?: 'Counter' }
    & Pick<Counter, 'amount'>
  )> }
);

export type OnCounterUpdatedSubscriptionVariables = Exact<{ [key: string]: never; }>;


export type OnCounterUpdatedSubscription = (
  { __typename?: 'Subscription' }
  & { counterUpdated?: Maybe<(
    { __typename?: 'Counter' }
    & Pick<Counter, 'amount'>
  )> }
);



export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
  selectionSet: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  Query: ResolverTypeWrapper<{}>;
  Counter: ResolverTypeWrapper<Counter>;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  ClientCounter: ResolverTypeWrapper<ClientCounter>;
  Mutation: ResolverTypeWrapper<{}>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  Subscription: ResolverTypeWrapper<{}>;
  String: ResolverTypeWrapper<Scalars['String']>;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  Query: {};
  Counter: Counter;
  Int: Scalars['Int'];
  ClientCounter: ClientCounter;
  Mutation: {};
  Boolean: Scalars['Boolean'];
  Subscription: {};
  String: Scalars['String'];
};

export type ClientCounterResolvers<ContextType = any, ParentType extends ResolversParentTypes['ClientCounter'] = ResolversParentTypes['ClientCounter']> = {
  counter?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CounterResolvers<ContextType = any, ParentType extends ResolversParentTypes['Counter'] = ResolversParentTypes['Counter']> = {
  amount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
  addCounter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType, RequireFields<MutationAddCounterArgs, never>>;
  addCounterState?: Resolver<Maybe<ResolversTypes['ClientCounter']>, ParentType, ContextType, RequireFields<MutationAddCounterStateArgs, 'amount'>>;
  addMoleculerCounter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType, RequireFields<MutationAddMoleculerCounterArgs, never>>;
  syncCachedCounter?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  counter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
  counterCache?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
  counterState?: Resolver<Maybe<ResolversTypes['ClientCounter']>, ParentType, ContextType>;
  moleculerCounter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
};

export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {
  counterUpdated?: SubscriptionResolver<Maybe<ResolversTypes['Counter']>, "counterUpdated", ParentType, ContextType>;
  moleculerCounterUpdate?: SubscriptionResolver<Maybe<ResolversTypes['Counter']>, "moleculerCounterUpdate", ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  ClientCounter?: ClientCounterResolvers<ContextType>;
  Counter?: CounterResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  Subscription?: SubscriptionResolvers<ContextType>;
};


/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
 */
export type IResolvers<ContextType = any> = Resolvers<ContextType>;


export const AddCounterStateDocument = gql`
    mutation addCounterState($amount: Int!) {
  addCounterState(amount: $amount) @client {
    counter
  }
}
    `;

/**
 * __useAddCounterStateMutation__
 *
 * To run a mutation, you first call `useAddCounterStateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCounterStateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCounterStateMutation, { data, loading, error }] = useAddCounterStateMutation({
 *   variables: {
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useAddCounterStateMutation(baseOptions?: Apollo.MutationHookOptions<AddCounterStateMutation, AddCounterStateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCounterStateMutation, AddCounterStateMutationVariables>(AddCounterStateDocument, options);
      }
export type AddCounterStateMutationHookResult = ReturnType<typeof useAddCounterStateMutation>;
export type AddCounterStateMutationResult = Apollo.MutationResult<AddCounterStateMutation>;
export type AddCounterStateMutationOptions = Apollo.BaseMutationOptions<AddCounterStateMutation, AddCounterStateMutationVariables>;
export const AddCounterDocument = gql`
    mutation addCounter($amount: Int!) {
  addCounter(amount: $amount) {
    amount
  }
}
    `;

/**
 * __useAddCounterMutation__
 *
 * To run a mutation, you first call `useAddCounterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCounterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCounterMutation, { data, loading, error }] = useAddCounterMutation({
 *   variables: {
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useAddCounterMutation(baseOptions?: Apollo.MutationHookOptions<AddCounterMutation, AddCounterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCounterMutation, AddCounterMutationVariables>(AddCounterDocument, options);
      }
export type AddCounterMutationHookResult = ReturnType<typeof useAddCounterMutation>;
export type AddCounterMutationResult = Apollo.MutationResult<AddCounterMutation>;
export type AddCounterMutationOptions = Apollo.BaseMutationOptions<AddCounterMutation, AddCounterMutationVariables>;
export const AddCounter_WsDocument = gql`
    mutation AddCounter_WS($amount: Int!) {
  addCounter(amount: $amount) {
    amount
  }
}
    `;

/**
 * __useAddCounter_WsMutation__
 *
 * To run a mutation, you first call `useAddCounter_WsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCounter_WsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCounterWsMutation, { data, loading, error }] = useAddCounter_WsMutation({
 *   variables: {
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useAddCounter_WsMutation(baseOptions?: Apollo.MutationHookOptions<AddCounter_WsMutation, AddCounter_WsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCounter_WsMutation, AddCounter_WsMutationVariables>(AddCounter_WsDocument, options);
      }
export type AddCounter_WsMutationHookResult = ReturnType<typeof useAddCounter_WsMutation>;
export type AddCounter_WsMutationResult = Apollo.MutationResult<AddCounter_WsMutation>;
export type AddCounter_WsMutationOptions = Apollo.BaseMutationOptions<AddCounter_WsMutation, AddCounter_WsMutationVariables>;
export const SyncCachedCounterDocument = gql`
    mutation SyncCachedCounter {
  syncCachedCounter
}
    `;

/**
 * __useSyncCachedCounterMutation__
 *
 * To run a mutation, you first call `useSyncCachedCounterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSyncCachedCounterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [syncCachedCounterMutation, { data, loading, error }] = useSyncCachedCounterMutation({
 *   variables: {
 *   },
 * });
 */
export function useSyncCachedCounterMutation(baseOptions?: Apollo.MutationHookOptions<SyncCachedCounterMutation, SyncCachedCounterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SyncCachedCounterMutation, SyncCachedCounterMutationVariables>(SyncCachedCounterDocument, options);
      }
export type SyncCachedCounterMutationHookResult = ReturnType<typeof useSyncCachedCounterMutation>;
export type SyncCachedCounterMutationResult = Apollo.MutationResult<SyncCachedCounterMutation>;
export type SyncCachedCounterMutationOptions = Apollo.BaseMutationOptions<SyncCachedCounterMutation, SyncCachedCounterMutationVariables>;
export const CounterCacheQueryDocument = gql`
    query counterCacheQuery {
  counterCache {
    amount
  }
}
    `;

/**
 * __useCounterCacheQueryQuery__
 *
 * To run a query within a React component, call `useCounterCacheQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useCounterCacheQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCounterCacheQueryQuery({
 *   variables: {
 *   },
 * });
 */
export function useCounterCacheQueryQuery(baseOptions?: Apollo.QueryHookOptions<CounterCacheQueryQuery, CounterCacheQueryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CounterCacheQueryQuery, CounterCacheQueryQueryVariables>(CounterCacheQueryDocument, options);
      }
export function useCounterCacheQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CounterCacheQueryQuery, CounterCacheQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CounterCacheQueryQuery, CounterCacheQueryQueryVariables>(CounterCacheQueryDocument, options);
        }
export type CounterCacheQueryQueryHookResult = ReturnType<typeof useCounterCacheQueryQuery>;
export type CounterCacheQueryLazyQueryHookResult = ReturnType<typeof useCounterCacheQueryLazyQuery>;
export type CounterCacheQueryQueryResult = Apollo.QueryResult<CounterCacheQueryQuery, CounterCacheQueryQueryVariables>;
export const CounterStateDocument = gql`
    query CounterState {
  counterState @client {
    counter
  }
}
    `;

/**
 * __useCounterStateQuery__
 *
 * To run a query within a React component, call `useCounterStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useCounterStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCounterStateQuery({
 *   variables: {
 *   },
 * });
 */
export function useCounterStateQuery(baseOptions?: Apollo.QueryHookOptions<CounterStateQuery, CounterStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CounterStateQuery, CounterStateQueryVariables>(CounterStateDocument, options);
      }
export function useCounterStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CounterStateQuery, CounterStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CounterStateQuery, CounterStateQueryVariables>(CounterStateDocument, options);
        }
export type CounterStateQueryHookResult = ReturnType<typeof useCounterStateQuery>;
export type CounterStateLazyQueryHookResult = ReturnType<typeof useCounterStateLazyQuery>;
export type CounterStateQueryResult = Apollo.QueryResult<CounterStateQuery, CounterStateQueryVariables>;
export const CounterQueryDocument = gql`
    query counterQuery {
  counter {
    amount
  }
}
    `;

/**
 * __useCounterQueryQuery__
 *
 * To run a query within a React component, call `useCounterQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useCounterQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCounterQueryQuery({
 *   variables: {
 *   },
 * });
 */
export function useCounterQueryQuery(baseOptions?: Apollo.QueryHookOptions<CounterQueryQuery, CounterQueryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CounterQueryQuery, CounterQueryQueryVariables>(CounterQueryDocument, options);
      }
export function useCounterQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CounterQueryQuery, CounterQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CounterQueryQuery, CounterQueryQueryVariables>(CounterQueryDocument, options);
        }
export type CounterQueryQueryHookResult = ReturnType<typeof useCounterQueryQuery>;
export type CounterQueryLazyQueryHookResult = ReturnType<typeof useCounterQueryLazyQuery>;
export type CounterQueryQueryResult = Apollo.QueryResult<CounterQueryQuery, CounterQueryQueryVariables>;
export const OnCounterUpdatedDocument = gql`
    subscription onCounterUpdated {
  counterUpdated {
    amount
  }
}
    `;

/**
 * __useOnCounterUpdatedSubscription__
 *
 * To run a query within a React component, call `useOnCounterUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnCounterUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnCounterUpdatedSubscription({
 *   variables: {
 *   },
 * });
 */
export function useOnCounterUpdatedSubscription(baseOptions?: Apollo.SubscriptionHookOptions<OnCounterUpdatedSubscription, OnCounterUpdatedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnCounterUpdatedSubscription, OnCounterUpdatedSubscriptionVariables>(OnCounterUpdatedDocument, options);
      }
export type OnCounterUpdatedSubscriptionHookResult = ReturnType<typeof useOnCounterUpdatedSubscription>;
export type OnCounterUpdatedSubscriptionResult = Apollo.SubscriptionResult<OnCounterUpdatedSubscription>;
```

# packages/sample-store/src/repository/index.ts

```ts
export * from './counter-repository';
export * from './interfaces';
// export * from './counter-hemera-repository';

```

# packages/sample-store/src/repository/counter-repository.ts

```ts
import { injectable } from 'inversify';

import { Counter_Table } from '../database-store/migrations/counter';
import { AbstractRepository } from '../db-helpers';
import { ICount } from '../models';
import { ICounterRepository } from './interfaces';

@injectable()
export class CounterRepository
    extends AbstractRepository
    implements ICounterRepository {
    // Set the table name to count
    public readonly tableName: string = Counter_Table;

    public async getById(id: number): Promise<ICount> {
        return this.getTable().where({ id }).first();
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    public async find(
        filter: string,
        pageNumber = 1,
        count = 20,
    ): Promise<ICount[]> {
        return this.getTable().where('amount', 'like', `%${filter}`).select();
    }

    public async create(dto: ICount): Promise<ICount> {
        return this.create(dto);
    }

    public async update(dto: ICount): Promise<ICount> {
        return this.getTable().update(dto);
    }

    public async getCount(): Promise<ICount> {
        return this.getTable().first();
    }

    public async addCount(amount) {
        await this.getTable().increment('amount', amount);
    }
}

```

# packages/sample-store/src/repository/counter-hemera-repository.ts

```ts
// import { AbstractRepository } from '../db-helpers';
// import { ICounterRepository } from './interfaces';
// import { ICount } from '../models';
// import { injectable, inject, named } from 'inversify';
// import * as Hemera from 'nats-hemera';
// import HemeraJoi from 'hemera-joi';
// import * as Nats from 'nats';
// import { Counter_Table } from '../database-store/migrations/counter';

// const NATS_HEMERA_DATBASE_MANAGER = 'sql-store';

// @injectable()
// export class CounterRemoteRepository implements ICounterRepository {

//     constructor(
//         @inject('Hemera') private hemera: Hemera<any, any>,
//     ) {
//     }
//     // Set the table name to count
//     public readonly tableName: string = Counter_Table;
//     private topic = NATS_HEMERA_DATBASE_MANAGER;

//     public async getById(id) {
//         const result = await this.hemera.act<ICount>(
//             {
//                 topic: NATS_HEMERA_DATBASE_MANAGER,
//                 cmd: 'findById',
//                 collection: this.tableName,
//                 id,
//             },
//         );
//         return result.data;
//     }

//     public async find(filter: string, pageNumber: number = 1, count: number = 20): Promise<ICount[]> {
//         const result = await this.hemera.act<ICount[]>(
//             {
//                 topic: NATS_HEMERA_DATBASE_MANAGER,
//                 cmd: 'find',
//                 collection: this.tableName,
//                 query: {},
//             },
//         );
//         return result.data;
//     }

//     public async create(data: ICount): Promise<ICount> {
//         const result = await this.hemera.act<ICount>(
//             {
//                 topic: NATS_HEMERA_DATBASE_MANAGER,
//                 cmd: 'create',
//                 collection: this.tableName,
//                 data,
//             },
//         );
//         return result.data;
//     }

//     public async update(data: ICount): Promise<ICount> {
//         const result = await this.hemera.act<ICount>(
//             {
//                 topic: NATS_HEMERA_DATBASE_MANAGER,
//                 cmd: 'update',
//                 collection: this.tableName,
//                 query: {
//                     id: data.id,
//                 },
//                 data: {
//                     amount: data.amount,
//                 },
//             },
//         );
//         return result.data;
//     }

//     public async getCount(): Promise<ICount> {
//         return this.getById(1);
//     }

//     public async  addCount(amount) {
//         return this.update({ id: 1, amount: amount });
//     }

// }

```

# packages/sample-store/src/models/index.ts

```ts
export * from './interfaces';
export * from './counter';

```

# packages/sample-store/src/models/counter.ts

```ts
import { DataTypes, Sequelize } from 'sequelize';

export default (sequelize: Sequelize, dataTypes: typeof DataTypes) => {
    // const count = sequelize.define('count', {
    //     name: dataTypes.STRING,
    // });
};

```

# packages/sample-store/src/db-helpers/repository.ts

```ts
export interface IRepository<T> {
    getById(id: number): Promise<T>;

    find(filter: string, pageNumber: number, count: number): Promise<T[]>;

    create(dto: T): Promise<T>;

    update(dto: T): Promise<T>;
}

```

# packages/sample-store/src/db-helpers/index.ts

```ts
export * from './entity';
export * from './db-config';
export * from './abstract-repository';
export * from './repository';

```

# packages/sample-store/src/db-helpers/entity.ts

```ts
export interface IEntity {
    id: number;
}

```

# packages/sample-store/src/db-helpers/db-config.ts

```ts
import { Config } from 'knex';

export class DbConfig {
    constructor(private config: Config) {}

    public getConfiguration(): Config {
        return this.config;
    }
}

```

# packages/sample-store/src/db-helpers/abstract-repository.ts

```ts
import { inject, injectable } from 'inversify';
import * as Knex from 'knex';

import { DbConfig } from './db-config';

let _db: Knex;

/**
 * Returns an instance of database
 */
const getDb = (config: DbConfig): Knex => {
    if (!_db) {
        _db = Knex(config.getConfiguration());
    }

    return _db;
};

@injectable()
export abstract class AbstractRepository {
    @inject('DefaultDbConfig')
    public dbConfig: DbConfig;

    public abstract readonly tableName: string;

    /**
     * Returns an instance of database
     */
    public getDb(): Knex {
        return getDb(this.dbConfig);
    }

    /**
     * Returns a IQueryBuilder instance of Table
     */
    public getTable(): Knex.QueryBuilder {
        return this.getDb().table(this.tableName);
    }
}

```

# packages/sample-store/src/container/module.ts

```ts
import { TaggedType } from '@common-stack/core';
import { ContainerModule, interfaces } from 'inversify';

import { TYPES } from '../constants';
import { DbConfig } from '../db-helpers';
import { CounterRepository, ICounterRepository } from '../repository';

export const repositoryModule: (
    config: DbConfig,
) => interfaces.ContainerModule = (dbConfig) =>
    new ContainerModule((bind: interfaces.Bind) => {
        bind<DbConfig>('DefaultDbConfig').toConstantValue(dbConfig);
        bind<ICounterRepository>(TYPES.ICounterRepository)
            .to(CounterRepository)
            .whenTargetIsDefault();

        // bind<ICounterRepository>(TYPES.ICounterRepository)
        //     .to(CounterRemoteRepository)
        //     .whenTargetNamed(TaggedType.MICROSERVICE);
    });

```

# packages/sample-store/src/container/index.ts

```ts
export * from './module';

```

# packages/sample-store/src/constants/index.ts

```ts
export * from './constants';

```

# packages/sample-store/src/constants/constants.ts

```ts
export const TYPES = {
    ICounterRepository: Symbol('ICounterRepository'),
};

```

# packages/sample-store/src/__tests__/counter-repository.test.ts

```ts
import 'reflect-metadata';
import 'jest';

import { Container } from 'inversify';
import * as Knex from 'knex';

import { TYPES } from '../constants';
import { DbConfig } from '../db-helpers';
import { CounterRepository, ICounterRepository } from '../repository';

const DEFAULT_DB_CONFIG = require('./db/config.json');

describe('dI Test', () => {
    let container: Container;
    let knex;
    beforeAll(async () => {
        knex = Knex(DEFAULT_DB_CONFIG);
        await knex.migrate.latest();
        await knex.seed.run();

        const dbConfig = new DbConfig(DEFAULT_DB_CONFIG);
        container = new Container();

        container.bind<DbConfig>('DefaultDbConfig').toConstantValue(dbConfig);

        // container...
        container
            .bind<ICounterRepository>(TYPES.ICounterRepository)
            .to(CounterRepository);
    });

    afterAll(() => {
        knex.destroy();
    });

    it('counter', async () => {
        const repository = container.get<ICounterRepository>(
            TYPES.ICounterRepository,
        );
        expect(repository).toBeInstanceOf(CounterRepository);
        try {
            const count = await repository.getById(1);
            expect(count.amount).toEqual(5);
        } catch (e) {
            expect(e).toBeUndefined();
        }
    });

    it('add counter', async () => {
        const repository = container.get<ICounterRepository>(
            TYPES.ICounterRepository,
        );
        try {
            await repository.addCount(2);
            const cnt = await repository.getCount();
            expect(cnt.amount).toEqual(7);
        } catch (e) {
            expect(e).toBeUndefined();
        }
    });
});

```

# packages/sample-store/src/__tests__/counter-hemera-repository.test.ts

```ts
// import 'reflect-metadata';

// import * as Hemera from 'nats-hemera';
// import * as Nats from 'nats';
// import * as HemeraTestSuite from 'hemera-testsuite';
// import * as HemeraSqlStore from 'hemera-sql-store';
// import { CounterRemoteRepository } from '../repository/counter-hemera-repository';
// import { createCounter, dropCounter, Counter_Table } from '../database-store/migrations/counter';
// import * as knex from 'knex';
// import { logger } from '@cdm-logger/server';

// require('dotenv').config({ path: process.env.ENV_FILE });

// import 'jest';

// describe('Hemera-sql-store', function () {
//     let PORT = 6242;
//     let authUrl = 'nats://localhost:' + PORT;
//     let server;
//     let hemera;
//     let testDatabase = process.env.DB_DATABASE;
//     let testTable = Counter_Table;
//     let repo: CounterRemoteRepository;

//     beforeAll(async (done) => {
//         server = HemeraTestSuite.start_server(PORT, () => {
//             const nats = Nats.connect(authUrl);
//             hemera = new Hemera(nats, {});
//             hemera.use(require('hemera-safe-promises'));
//             hemera.use(HemeraSqlStore, {
//                 knex: {
//                     dialect: 'mysql',
//                     connection: {
//                         host: process.env.DB_HOST,
//                         user: process.env.DB_USER,
//                         password: process.env.DB_PASSWORD,
//                         database: testDatabase,
//                     },
//                     pool: {
//                         min: 0,
//                         max: 7,
//                     },
//                 },
//             });
//             hemera.ready(async () => {
//                 await createCounter(hemera.sqlStore.useDb(testDatabase));
//                 repo = new CounterRemoteRepository(hemera);
//                 done();
//             });
//         });
//     });

//     afterAll(async () => {
//         await dropCounter(hemera.sqlStore.useDb(testDatabase));
//         hemera.close();
//         server.kill();
//     });

//     it('create', async (done) => {
//         const count = { id: 1, amount: 1 };
//         try {
//             const addCoutOutput = await repo.create(count);
//             expect(addCoutOutput).toEqual([1]);
//             done();
//         } catch (err) {
//             logger.error(err);
//             done.fail();
//         }
//     });

//     it('getById', async (done) => {
//         try {
//             const count = await repo.getById(1);
//             expect(count[0].amount).toEqual(1);
//             done();
//         } catch (err) {
//             logger.error(err);
//             done.fail();
//         }
//     });
//     it('getCount', async (done) => {
//         try {
//             const count = await repo.getCount();
//             done();
//         } catch (err) {
//             logger.error(err);
//             done.fail();
//         }
//     });

//     it('addCount', async (done) => {
//         try {
//             await repo.addCount(1);
//             done();
//         } catch (err) {
//             logger.error(err);
//             done.fail();
//         }
//     });
// });

```

# packages/sample-platform/server/src/index.ts

```ts

```

# packages/sample-platform/browser/src/module.ts

```ts
import { Feature } from '@common-stack/client-react';

import { interfaces } from 'inversify';
import { ApolloClient } from '@apollo/client';
import { ClientTypes as BrowserTypes } from '@common-stack/client-core';
import { platformModule } from './inversify-containers';

const platformServiceGen = (container: interfaces.Container) => ({
    apolloClient: container.get<ApolloClient<any>>(BrowserTypes.ApolloClient),
    cache: container.get<any>(BrowserTypes.InMemoryCache),
    utility: container.get(BrowserTypes.UtilityClass),
});
export default new Feature({
    createContainerFunc: platformModule,
    createServiceFunc: platformServiceGen,
});

```

# packages/sample-platform/browser/src/index.ts

```ts
import PlatformModule from './module';
export * from './graphql';
export * from './components';
export * from './containers';


export default PlatformModule;

```

# packages/sample-platform/browser/src/api.ts

```ts
// Simulate a flaky API around otherwise an otherwise synchronous `f()`.
const flakify = <T>(f: () => T): Promise<T> =>
    new Promise((resolve, reject) =>
        // We'll always take 200 * (1d10 + 1) ms to respond
        window.setTimeout(() => {
            try {
                // And ~20% of the time we'll fail
                if (Math.random() < 0.2) {
                    throw new Error('Failed arbitrarily');
                }

                resolve(f());
            } catch (e) {
                return reject(e);
            }
        }, 200 + Math.random() * 2000),
    );

export type Api = {
    save(x: { value: number }): Promise<null>;
    load(): Promise<{ value: number }>;
};

export const api: Api = {
    save: (counter) =>
        flakify(() => {
            localStorage.setItem('__counterValue', counter.value.toString());
            return null;
        }),
    load: () =>
        flakify(() => {
            const value = parseInt(localStorage.getItem('__counterValue'), 10);
            return { value };
        }),
};

```

# docs/development/CodeContribution/React-Patterns/Styles_With_Type.md

```md

Sample Style Sheet implementation. 

\`\`\`js
import * as CSS from 'csstype';

const DefaultSettingsView = (props: IDefaultSettings) => {

    const { css, theme } = useFela();

    return(()=> {
            <div className={css(styleSheet.title)}>
                <span className={css(styleSheet.note({ width: width || 0 }))}>test</span>
            </div>
    })

}
const styleSheet: { [key: string]: (x: any) => CSS.Properties } = {
    resizable: () => ({
        position: 'relative',
        '> .react-resizable-handle': {
            position: 'absolute',
            width: '3px',
            height: '100%',
            top: 0,
            right: 0,
            padding: '0 3px 3px 0',
            boxSizing: 'border-box',
            cursor: 'col-resize',
        },
    }),
    title: ({ theme }) => ({
        textTransform: 'uppercase',
        padding: '5px 0',
        fontSize: '11px',
        marginLeft: '33px',
        color: theme.name === 'light' ? '#424242bd' : '#e7e7e77a',
        boxShadow: theme.name === 'light' ? '0px 1px 2px 0px #f3f3f3' : '0px 1px 2px 0px #000000',
        marginBottom: '2px',
    }),
    note: ({ width }) => ({
        marginLeft: '33px',
        fontSize: '14px',
        whiteSpace: 'nowrap',
        textOverflow: 'clip',
        display: 'block',
        maxWidth: width,
        overflow: 'hidden',
    }),
};

\`\`\`
```

# docs/development/CodeContribution/React-Patterns/RxJS_notes.md

```md


https://itnext.io/handling-redux-side-effects-the-rxjs-way-59c057b12cd4
```

# docs/development/CodeContribution/React-Patterns/React_Componet_Extensions.md

```md


https://github.com/superdesk/superdesk-client-core/blob/d5ee7b11dddd2255a77b518e177b7ec33b167311/scripts/apps/extension-points/services/ExtensionPoints.js

https://github.com/taskrabbit/react-component-extension



https://github.com/camwest/react-slot-fill

Reference: https://www.youtube.com/watch?v=395ou6k6C6k
```

# docs/development/CodeContribution/React-Patterns/Mongoose_Connection.md

```md

Reference:
https://github.com/barakbd/docker_typescript_debug_vscode/blob/8454ab4bdd9713da373e898e7c606193bfbfc5e2/src/config/mongoose_connection.ts

\`\`\`
/ https://codingsans.com/blog/mongoose-models-using-typescript-classes
import * as mongoose from "mongoose";
var connectionOptions: mongoose.ConnectionOptions | undefined;

const uri: string = `mongodb://${process.env.MONGODB_HOST_AND_PORT_LIST}/${
  process.env.MONGODB_DATABASE_NAME
}`;

console.log("uri", uri);
const mongooseConnectionOptions: mongoose.ConnectionOptions = {
  autoReconnect: true,
  reconnectTries: 3,
  keepAlive: 120,
  user: process.env.MONGODB_DB_USERNAME,
  pass: process.env.MONGODB_DB_PASSWORD,
  authSource: process.env.MONGODB_AUTH_SOURCE,
  replicaSet: process.env.MONGODB_REPLICASET
};

process.env.NODE_ENV === "local"
  ? (connectionOptions = undefined)
  : (connectionOptions = mongooseConnectionOptions);

console.log("mongoose connectionOptions - ", connectionOptions);

mongoose
  .connect(uri, connectionOptions)
  .then(() => {
    console.info("mogoose connect - success");
    // console.info(`uri - ${uri}`);
    // console.info(`connectionOptions - ${connectionOptions}`);
  })
  .catch((err: mongoose.Error) => {
    console.error("mogoose connect - error - ", err);
    // throw err;
    process.kill(process.pid);
  });
const mongooseConnection: mongoose.Connection = mongoose.connection;
export { mongooseConnection };
\`\`\`
```

# docs/development/CodeContribution/React-Patterns/HOC_With_Render_Props.md

```md
Reference: https://gist.github.com/mjackson/a1bee5a8b24a0db7ff29586b124cfb38
https://www.youtube.com/watch?v=BcVAq3YFiuc&t=1397s
https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce
\`\`\`
import React from "react";
import ReactDOM from "react-dom";
import PropTypes from "prop-types";

document.body.style.background = `
  linear-gradient(135deg,
    #1e5799 0%,
    #2989d8 50%,
    #207cca 51%,
    #7db9e8 100%
  )
`;

const getHeaderStyle = y => {
  const pin = y >= 100;
  const top = -y / 2;
  return {
    textTransform: "uppercase",
    textAlign: "center",
    width: "100%",
    margin: 0,
    position: "fixed",
    top: pin ? "0px" : `${top + 50}px`,
    textShadow: pin
      ? `0px ${(y - 100) / 5}px ${Math.min(
          (y - 100) / 10,
          20
        )}px rgba(0, 0, 0, 0.5)`
      : "none"
  };
};

class ScrollY extends React.Component {
  state = { y: 0 };

  handleWindowScroll = () => {
    this.setState({ y: window.scrollY });
  };

  componentDidMount() {
    this.handleWindowScroll();
    window.addEventListener("scroll", this.handleWindowScroll);
  }

  componentWillUnmount() {
    window.removeEventListener("scroll", this.handleWindowScroll);
  }

  render() {
    return this.props.children(this.state.y);
  }
}

class App extends React.Component {
  render() {
    const { y } = this.props;

    return (
      <div style={{ height: "300vh", color: "white" }}>
        <h1 style={getHeaderStyle(y)}>{this.props.message}</h1>
      </div>
    );
  }
}

function withScrollY(Component) {
  return class extends React.Component {
    render() {
      return (
        <ScrollY>{y => <Component {...this.props} y={y} />}</ScrollY>
      );
    }
  };
}

const AppWithScrollY = withScrollY(App);

ReactDOM.render(
  <AppWithScrollY message="hello" />,
  document.getElementById("app")
);

\`\`\`
```

# docs/development/CodeContribution/React-Patterns/Dynamically_Render_Components.md

```md

Refernce: https://medium.com/@j5bot/react-dynamically-rendering-different-components-without-switch-the-capitalized-reference-e668d89e460b

\`\`\`
import React from 'react'; // required to use JSX

export const CapitalizedReferenceComponentCollectionExternals = (props) => {

  // get references to all possible components
  // that this component might render,
  // and the collection of dynamic components we need to render,
  // using destructuring
  const { components: Components, collection } = props;

  // A Capitalized reference to reuse
  let Component;

  // A reference to the component's props to reuse
  let componentProps;

  // A function which returns component.props if it exists,
  // and otherwise returns props
  const defaultMapPropsToComponent = function (
    {
      component = {},
      props = {}
    } = {}
  ) {

    return component.props || props;

  };

  // render the component collection
  return(
    <div>{
        collection.map(
          ( component ) => {
            // Reference the proper component
            Component = Components[ component.type ];
            // Get the props you want to use for this component instance
            // here we are assuming that you can specify a mapping function
            // on the component definition, in props, or use the default
            componentProps = (
              component.mapPropsToComponent ||
                props.mapPropsToComponent ||
                  defaultMapPropsToComponent
            )( component, props );
            return (<Component { ...componentProps } />);
          }
        )
    }</div>
  );
};

export default CapitalizedReferenceComponentCollectionExternals;
\`\`\`
```

# .git-crypt/keys/default/0/EBA4B7A860BD152BF5F9F727F12B84D048062B79.gpg

This is a binary file of the type: Binary

# .git-crypt/keys/default/0/70961F6ECD8220394FD8AB555E94AC25CBCBA1A3.gpg

This is a binary file of the type: Binary

# .git-crypt/keys/default/0/54EBB791640A664510494E416177B1BAA1083A88.gpg

This is a binary file of the type: Binary

# .git-crypt/keys/default/0/49AB3942E38DB928ACF3905EC2DB4383B4A6E5EA.gpg

This is a binary file of the type: Binary

# .git-crypt/keys/default/0/147885163DF27F4877B0BC14DE8C27DDE38F1E61.gpg

This is a binary file of the type: Binary

# tools/templates/module/browser/src/module.tsx

```tsx
import { Feature } from '@common-stack/client-react';
import { $Module$_NAMESPACE, $Module$_API_ROUTES } from './constants';


export default new Feature({
  routeConfig: [{
    [$Module$_API_ROUTES.$Module$_ROOT]: { component: RepositoriesContainer },
  }],
});


```

# tools/templates/module/browser/src/index.tsx

```tsx
import $module$ from './module';
import { Feature } from '@common-stack/client-react';

export default new Feature($module$);

```

# tools/templates/module/server/src/module.ts

```ts
import * as _ from 'lodash';
import { TaggedType } from '@common-stack/core';
import { Feature } from '@common-stack/server-core';

import { TYPES } from './constants';
import { activityModule, activityModuleNats } from './containers';
import { interfaces } from 'inversify';
import { IActivityCollector } from './interfaces';
import { config } from './config';

const createActivityServiceFunc = (container: interfaces.Container) => {
    const environment = container.get('Environment');
    if (environment === 'development') {
        return {
            activityService: container.get<IActivityCollector>(TYPES.ActivityCollector),
        };
    } else {
        return {
            activityService: container.getNamed<IActivityCollector>(TYPES.ActivityCollector, TaggedType.MICROSERVICE),
        };
    }
};


export default new Feature({
    createContainerFunc: config.isDevelopment ? [activityModule] : [activityModule, activityModuleNats],
    createServiceFunc: createActivityServiceFunc,
    beforeware: [
        (app) => {
            app.use('/graphql', (req, res, next) => {
                const user = _.get(req.user, 'sub');
                req.services.activityService.user({ key: user, timestamp: Date.now() });

                next();
            });
        },
    ],
});

```

# tools/templates/module/server/src/index.ts

```ts
import { Feature } from '@common-stack/server-core';
import module from './module';

export * from './constants';
export default new Feature(module);

```

# servers/moleculer-server/src/test/unit/greeter.spec.ts

```ts
'use strict';

// import { ServiceBroker, Errors } from 'moleculer';
// import TestService from '../../greeter.service';

// describe("Test 'greeter' service", () => {
//     let broker = new ServiceBroker();
//     broker.createService(TestService);

//     beforeAll(() => broker.start());
//     afterAll(() => broker.stop());

//     describe("Test 'greeter.hello' action", () => {

//         it("should return with 'Hello Moleculer'", () => {
//             expect(broker.call("greeter.hello")).resolves.toBe("Hello Moleculer");
//         });

//     });

//     describe("Test 'greeter.welcome' action", () => {

//         it("should return with 'Welcome'", () => {
//             expect(broker.call("greeter.welcome", { name: "Adam" })).resolves.toBe("Welcome, Adam");
//         });

//         it("should reject an ValidationError", () => {
//             expect(broker.call("greeter.welcome")).rejects.toBeInstanceOf(Errors.ValidationError);
//         });

//     });

// });


```

# servers/moleculer-server/charts/chart/templates/service.yaml

```yaml
apiVersion: v1
kind: Service
metadata:
  annotations:
    prometheus.io/scrape: "true"
  name: {{ template "fullname" . }}
  labels:
    chart: "{{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}"
spec:
  type: {{ .Values.service.type }}
  ports:
  - port: {{ .Values.service.externalPort }}
    targetPort: {{ .Values.service.internalPort }}
    protocol: TCP
    name: {{ .Values.service.name }}
  - port: 3030
    targetPort: 3030
    protocol: TCP
    name: metrics
  selector:
    app: {{ template "fullname" . }}

```

# servers/moleculer-server/charts/chart/templates/redis-external-service.yaml

```yaml
{{- if .Values.external.service.redis.enabled  }}
apiVersion: v1
kind: Service
metadata:
  name: {{ template "redis.fullname" . }}
  namespace: "{{ .Release.Namespace }}"
  labels:
{{ include "labels.standard" . | indent 4 }}
    component: {{ template "redis.fullname" . }}
spec:
  type: ExternalName
  externalName: {{ .Values.external.service.redis.serviceName | quote }}
  ports:
  - port: {{ .Values.external.service.redis.port }}
{{- end -}}
```

# servers/moleculer-server/charts/chart/templates/nats-external-service.yaml

```yaml
{{- if .Values.external.service.nats.enabled  }}
apiVersion: v1
kind: Service
metadata:
  name: {{ template "nats.fullname" . }}
  namespace: "{{ .Release.Namespace }}"
  labels:
{{ include "labels.standard" . | indent 4 }}
    component: {{ template "nats.fullname" . }}
spec:
  type: ExternalName
  externalName:  {{ .Values.external.service.nats.serviceName | quote }}
  ports:
  - port: {{ .Values.external.service.nats.port }}
{{- end -}}
```

# servers/moleculer-server/charts/chart/templates/mongodb-external-service.yaml

```yaml
{{- if .Values.external.service.mongodb.enabled  }}
apiVersion: v1
kind: Service
metadata:
  name: {{ template "mongodb.fullname" . }}
  namespace: "{{ .Release.Namespace }}"
  labels:
{{ include "labels.standard" . | indent 4 }}
    component: {{ template "mongodb.fullname" . }}
spec:
  type: ExternalName
  externalName: {{ .Values.external.service.mongodb.serviceName | quote }}
  ports:
  - port: {{ .Values.external.service.mongodb.port }}
{{- end -}}

```

# servers/moleculer-server/charts/chart/templates/ingress.yaml

```yaml
{{- if .Values.ingress.enabled -}}
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: {{ template "fullname" . }}
  labels:
    chart: "{{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}"
spec:
  rules:
  - host: {{ .Release.Name }}.{{ .Values.basedomain }}
    http:
      paths:
      - path: /
        backend:
          serviceName: {{ template "fullname" . }}
          servicePort: {{ .Values.service.externalPort }}
{{- end -}}

```

# servers/moleculer-server/charts/chart/templates/deployment.yaml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ template "fullname" . }}
  labels:
    chart: "{{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}"
spec:
  selector:
    matchLabels:
      chart: "{{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}"
  replicas: {{ .Values.replicaCount }}
  template:
    metadata:
      annotations:
        buildID: "{{ .Values.buildID }}"
      labels:
        app: {{ template "fullname" . }}
        chart: "{{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}"
    spec:
      containers:
      - name: {{ .Chart.Name }}
        image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        env:
          - name: NAMESPACE
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace 
{{- if  or .Values.external.service.mongodb.generateEnv .Values.external.service.mongodb.enabled }}
          - name: MONGO_URL
            value: "{{ template "mongodb_service" . }}"
{{- end }}
{{- if  or .Values.external.service.redis.generateEnv .Values.external.service.redis.enabled }}
          - name: REDIS_URL
            value: "{{ template "redis_service" . }}"
{{- end }}
{{- if  or .Values.external.service.zipkin.generateEnv .Values.external.service.zipkin.enabled }}
          - name: ZIPKIN_URL
            value: {{ template "zipkin_host" . }}
          - name: ZIPKIN_PORT
            value: {{ .Values.external.service.zipkin.port | quote }}
{{- end }}
{{- if  or .Values.external.service.nats.generateEnv .Values.external.service.nats.enabled }}
          - name: NATS_PW
            value: {{ .Values.external.service.nats.password | quote }}
          - name: NATS_URL
            value: "{{ template "nats_service" . }}"
          - name: NATS_USER
            value: {{ .Values.external.service.nats.user | quote }}
{{- end }}
{{- range $name, $value := .Values.env }}
{{- if not (empty $value) }}
          - name: {{ $name | quote }}
            value: {{ $value | quote }}
{{- end }}
{{- end }}
        ports:
        - containerPort: {{ .Values.service.internalPort }}
        resources:
{{ toYaml .Values.resources | indent 12 }}

```

# servers/moleculer-server/charts/chart/templates/_helpers.tpl

```tpl
# fqdn
{{- define "region"}}cluster{{- end}}
{{- define "tld"}}local{{- end}}

{{/* vim: set filetype=mustache: */}}
{{/*
Expand the name of the chart.
*/}}
{{- define "name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" -}}
{{- end -}}

{{/*
Create a default fully qualified app name.
We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).
*/}}
{{- define "fullname" -}}
{{- $name := default "" -}}
{{- printf "%s-%s" .Release.Name $name | trunc 63 | trimSuffix "-" -}}
{{- end -}}

{{- /*
https://github.com/technospophos/common-chart/
chartref prints a chart name and version.
It does minimal escaping for use in Kubernetes labels.
Example output:
  zookeeper-1.2.3
  wordpress-3.2.1_20170219
*/ -}}
{{- define "chartref" }}
  {{- replace "+" "_" .Chart.Version | printf "%s-%s" .Chart.Name -}}
{{- end -}}


{{- /*
https://github.com/technosophos/common-chart/
labels.standard prints the standard Helm labels.
The standard labels are frequently used in metadata.
*/ -}}
{{- define "labels.standard" -}}
app: {{ template "fullname" . }}
heritage: {{ .Release.Service | quote }}
release: {{ .Release.Name | quote }}
chart: {{ template "chartref" . }}
{{- end -}}


{{/*
Create a default fully qualified zipkin name.
We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).
*/}}
{{- define "zipkin.fullname" -}}
{{- printf "%s-%s-%s" .Release.Namespace .Values.external.name "zipkin" | trunc 63 | trimSuffix "-" -}}
{{- end -}}


{{/*
Create a default fully qualified nats name.
We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).
*/}}
{{- define "nats.fullname" -}}
{{- printf "%s-%s-%s" .Release.Namespace .Values.external.name "nats" | trunc 63 | trimSuffix "-" -}}
{{- end -}}

{{/*
Create a default fully qualified mysql name.
We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).
*/}}
{{- define "mongodb.fullname" -}}
{{- printf "%s-%s-%s" .Release.Namespace .Values.external.name "mongodb" | trunc 63 | trimSuffix "-" -}}
{{- end -}}

{{/*
Create a default fully qualified zipkin name.
We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).
*/}}
{{- define "redis.fullname" -}}
{{- printf "%s-%s-%s" .Release.Namespace .Values.external.name "redis" | trunc 63 | trimSuffix "-" -}}
{{- end -}}


{{- define "nats_host"}}{{ include "nats.fullname" . }}.{{.Release.Namespace}}.svc.{{ include "region" . }}.{{ include "tld" . }}{{- end}}
{{- define "mongodb_host"}}{{ include "mongodb.fullname" . }}.{{.Release.Namespace}}.svc.{{ include "region" . }}.{{ include "tld" . }}{{- end}}
{{- define "mongodb_service"}}mongodb://{{ include "mongodb_host" . }}:{{ .Values.external.service.mongodb.port }}/{{ .Values.external.service.mongodb.dbname }}{{- end}}
{{- define "nats_service"}}nats://{{ include "nats_host" . }}:{{ .Values.external.service.nats.port }}{{- end}}
{{- define "zipkin_host"}}{{ include "zipkin.fullname" . }}.{{.Release.Namespace}}.svc.{{ include "region" . }}.{{ include "tld" . }}{{- end}}
{{- define "redis_host"}}{{ include "redis.fullname" . }}.{{.Release.Namespace}}.svc.{{ include "region" . }}.{{ include "tld" . }}{{- end}}
{{- define "redis_service"}}redis://{{ include "redis_host" . }}:{{ .Values.external.service.redis.port }}{{- end}}

```

# servers/moleculer-server/charts/chart/templates/NOTES.txt

```txt

{{- if contains "NodePort" .Values.service.type }}
  Get the application URL by running these commands:
  export NODE_PORT=$(kubectl get --namespace {{ .Release.Namespace }} -o jsonpath="{.spec.ports[0].nodePort}" services {{ template "fullname" . }})
  export NODE_IP=$(kubectl get nodes --namespace {{ .Release.Namespace }} -o jsonpath="{.items[0].status.addresses[0].address}")
  echo http://$NODE_IP:$NODE_PORT/login
{{- else if contains "LoadBalancer" .Values.service.type }}
  Get the application URL by running these commands:
     NOTE: It may take a few minutes for the LoadBalancer IP to be available.
           You can watch the status of by running 'kubectl get svc -w {{ template "fullname" . }}'
  export SERVICE_IP=$(kubectl get svc --namespace {{ .Release.Namespace }} {{ template "fullname" . }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
  echo http://$SERVICE_IP:{{ .Values.service.externalPort }}
{{- else }}
  http://{{ .Release.Name }}.{{ .Values.basedomain }} to access your application
{{- end }}

```

# servers/frontend-server/src/modules/layout/index.ts

```ts
export * from './components';

```

# servers/frontend-server/src/config/__tests__/apollo-client-subscribe-to-more.ts

```ts
import gql from 'graphql-tag';
import { Operation } from '@apollo/client';
import { InMemoryCache } from 'apollo-cache-inmemory';
import { DocumentNode, OperationDefinitionNode } from 'graphql';
import { mockSingleLink, mockObservableLink } from '@apollo/client/testing';


const isSub = (operation: Operation) =>
    (operation.query as DocumentNode).definitions
        .filter(x => x.kind === 'OperationDefinition')
        .some((x: OperationDefinitionNode) => x.operation === 'subscription');

describe('subscribeToMore', () => {
    const query = gql`
        query aQuery {
            entry {
                value
            }
        }
    `;
    const result = {
        data: {
            entry: {
                value: '1',
            },
        },
    };

    const req1 = { request: { query } as Operation, result };

    const results = ['Dahivat Pandya', 'Amanda Liu'].map(name => ({
        result: { data: { name } },
        delay: 10,
    }));

    const results2 = [
        { result: { data: { name: 'Amanda Liu' } }, delay: 10 },
        { error: new Error('You cant touch this'), delay: 10 },
    ];

    const results3 = [
        { error: new Error('You cant touch this'), delay: 10 },
        { result: { data: { name: 'Amanda Liu' } }, delay: 10 },
    ];

    const result4 = {
        data: {
            entry: [{ value: '1' }, { value: '2' }],
        },
    };
    const req4 = { request: { query } as Operation, result: result4 };


});

```

# servers/frontend-server/src/config/__mocks__/mockWatchQuery.ts

```ts

```

# servers/frontend-server/src/config/__mocks__/mockFetch.ts

```ts
import 'whatwg-fetch';


// This is an implementation of a mocked window.fetch implementation similar in
// structure to the MockedNetworkInterface.


export interface MockedIResponse {
    ok: boolean;
    status: number;
    statusText?: string;
    json(): Promise<Object>;
}

export interface MockedFetchResponse {
    url: string;
    opts: RequestInit;
    result: MockedIResponse;
    delay?: number;
}

export function createMockedIResponse(
    result: Object,
    options?: any,
): MockedIResponse {
    const status = (options && options.status) || 200;
    const statusText = (options && options.statusText) || undefined;

    return {
        ok: status === 200,
        status,
        statusText,
        json() {
            return Promise.resolve<Object>(result);
        },
    };
}

export class MockFetch {
    private mockedResponsesByKey: { [key: string]: MockedFetchResponse[] };

    constructor(...mockedResponse: MockedFetchResponse[]) {
        this.mockedResponsesByKey = {};

        mockedResponses.forEach(mockedResponse => {
            this.addMockedResponse(mockedResponse);
        });
    }

    public addMockedResponse(mockedResponse: MockedFetchResponse) {
        const key = this.fetchParamsToKey(mockedResponse.url, mockedResponse.opts);
        let mockedResponses = this.mockedResponsesByKey[key];

        if (!mockedResponses) {
            mockedResponses = [];
            this.mockedResponsesByKey[key] = mockedResponses;
        }

        mockedResponses.push(mockedResponse);
    }

    public fetch(url: string, opts: RequestInit) {
        const key = this.fetchParamsToKey(url, opts);
        const responses = this.mockedResponsesByKey[key];
        if (!responses || response.length === 0) {
            throw new Error(
                `No more mocked fetch responses for the params ${url} and ${opts}`,
            );
        }

        const { result, delay } = responses.shift();

        if (!result) {
            throw new Error(`Mocked fetch response should contain a result.`);
        }

        return new Promise((resolve) => {
            setTimeout(() => {
                resolve(result);
            }, delay ? delay : 0);
        });
    }

    public fetchParamsToKey(url: string, opts: RequestInit): string {
        return JSON.stringify({
            url,
            opts: sortByKey(opts),
        });
    }
}
```

# servers/frontend-server/src/backend/ssr/html.tsx

```tsx
/// <reference path='../../../../../typings/index.d.ts' />

import * as React from 'react';
import serialize from 'serialize-javascript';
import { HelmetData } from 'react-helmet';
import modules from '../../modules';

/**
 * A simple herlper function to prepare the HTML markup. This loads:
 *      - Page title
 *      - SEO meta tags
 *      - Preloaded state (for Redux, Apollo, additional Environment variables) depending on the current route
 *      - Code-split script tags depending on the current route
 * @param param0
 */
const Html = ({
    content,
    state,
    reduxState,
    fela,
    env,
    assetMap,
    styleSheet,
    helmet,
}:
    { content?: any, state: any, reduxState: any, assetMap?: string[], env: any, fela?: any, styleSheet?: any[], helmet?: HelmetData }) => {
    const htmlAttrs = helmet.htmlAttributes.toComponent(); // react-helmet html document tags
    const bodyAttrs = helmet.bodyAttributes.toComponent(); // react-helmet body document tags

    return (
        <html lang="en" {...htmlAttrs}>
            <head>
                {helmet.title.toComponent()}
                {helmet.meta.toComponent()}
                {helmet.link.toComponent()}
                <meta charSet="utf-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" />
                {<link rel="stylesheet" type="text/css" href={`${assetMap['index.css']}`} />}
                {assetMap['vendor.css'] && <link rel="stylesheet" type="text/css" href={`${assetMap['vendor.css']}`} />}
                <style id="font-stylesheet" />
                {!!__DEV__ && (
                    <style
                        dangerouslySetInnerHTML={{
                            __html: modules.stylesInserts.map(style => style._getCss()).join(''),
                        }}
                    />
                )}
                {styleSheet.map(({ type, rehydration, css, media, support }) => (
                    <style
                        id="stylesheet"
                        dangerouslySetInnerHTML={{ __html: css }}
                        data-fela-rehydration={rehydration}
                        data-fela-type={type}
                        data-fela-support={support}
                        key={`${type}-${media}`}
                        media={media}
                    />
                ))}
                {modules.scriptsInserts.map((script, i) => {
                    if (script) {
                        return <script key={i} src={script} />;
                    }
                })}
            </head>
            <body {...bodyAttrs}>
                <div id="root"/>
                <div className="demo">
                    <div
                        id="content"
                        dangerouslySetInnerHTML={
                            {
                                __html: content ||
                                    'Try building the app:<br/> ...and refreshing this page!',
                            }}
                    />
                </div>
                <script
                    dangerouslySetInnerHTML={{
                        __html: `window.__ENV__=${serialize(env, {
                            isJSON: true,
                        })};`,
                    }}
                    charSet="UTF-8"
                />
                <script
                    dangerouslySetInnerHTML={{
                        __html: `window.__APOLLO_STATE__=${serialize(state, {
                            isJSON: true,
                        })};`,
                    }}
                    charSet="UTF-8"
                />
                <script
                    dangerouslySetInnerHTML={{
                        __html: `window.__PRELOADED_STATE__=${serialize(reduxState, {
                            isJSON: true,
                        })};`,
                    }}
                    charSet="UTF-8"
                />
                {assetMap['vendor.js'] && <script src={`${assetMap['vendor.js']}`} charSet="utf-8" />}
                <script src={`${assetMap['index.js']}`} charSet="utf-8" />
            </body>
        </html>
    );
};

export { Html };

```

# servers/frontend-server/src/backend/modules/modules.ts

```ts
import { Feature } from '@common-stack/server-core';

export default new Feature({});


```

# servers/frontend-server/src/backend/modules/index.ts

```ts
import modules from './modules';
export default modules;

```

# servers/frontend-server/src/backend/middlewares/error.ts

```ts
/// <reference path='../../../../../typings/index.d.ts' />

import * as path from 'path';
import * as fs from 'fs';
import * as url from 'url';
import { logger } from '@cdm-logger/server';


let assetMap;

const stripCircular = (from, seen?: any) => {
    const to = Array.isArray(from) ? [] : {};
    seen = seen || [];
    seen.push(from);
    Object.getOwnPropertyNames(from).forEach(key => {
        if (!from[key] || (typeof from[key] !== 'object' && !Array.isArray(from[key]))) {
            to[key] = from[key];
        } else if (seen.indexOf(from[key]) < 0) {
            to[key] = stripCircular(from[key], seen.slice(0));
        } else { to[key] = '[Circular]'; }
    });
    return to;
};

const { pathname } = url.parse(__BACKEND_URL__);

export const errorMiddleware =
    (e, req, res, next) => {
        if (req.path === pathname) {
            const stack = e.stack.toString().replace(/[\n]/g, '\\n');
            res.status(200).send(`[{"data": {}, "errors":[{"message": "${stack}"}]}]`);
        } else {
            logger.error(e);

            if (__DEV__ || !assetMap) {
                assetMap = JSON.parse(fs.readFileSync(path.join(__FRONTEND_BUILD_DIR__, 'assets.json')).toString());
            }

            const serverErrorScript = `<script charset="UTF-8">window.__SERVER_ERROR__=${JSON.stringify(
                stripCircular(e),
            )};</script>`;
            const vendorScript = assetMap['vendor.js']
                ? `<script src="/${assetMap['vendor.js']}" charSet="utf-8"></script>`
                : '';

            res.status(200).send(
                `<html>${serverErrorScript}<body><div id="content"></div>
        ${vendorScript}
            <script src="/${assetMap['index.js']}" charSet="utf-8"></script>
            </body></html>`,
            );
        }
    };



```

# servers/frontend-server/src/backend/middlewares/cors.ts

```ts
import cors from 'cors';
import { config } from '../../config';
import { logger } from '@common-stack/client-core';

const CLIENT_URL = config.CLIENT_URL;
const BACKEND_URL = config.BACKEND_URL;


const corsWhitelist = [
    CLIENT_URL,
    BACKEND_URL,
];
logger.info('corsWhitelist (%j)', corsWhitelist);

const corsOptions: cors.CorsOptions = {
    origin: (origin, callback) => {
        if (corsWhitelist.indexOf(origin) !== -1) {
            callback(null, true);
        } else {
            // TODO: only throw when in debug mode
            logger.error('url (%s) is not in the whitelist', origin);
            // callback(new Error('Not allowed by CORS'))
            logger.warn('allowing all origins temporarily, you need to disable it.');
            callback(null, true);
        }
    },
    credentials: false,
};

export const corsMiddleware = cors(corsOptions);

```

# portable-devices/desktop/src/renderer/config/router-history.ts

```ts
import { createHashHistory } from 'history';

module.exports = createHashHistory(); // use hashistory in electron

```

# portable-devices/desktop/src/renderer/config/public-config.ts

```ts
/* eslint-disable no-underscore-dangle */
import { lowerCase } from 'lodash';

/**
 * This file opens up in public site, so make sure it is
 * not dependent on any other file that compromises the security.
 */
const publicEnv = [
    'NODE_ENV',
    'GRAPHQL_URL',
    'GRAPHQL_SUBSCRIPTION_URL',
    'FACEBOOK_APP_ID',
    'GA_ID',
    'LOG_LEVEL',
    'AUTH0_CLIENT_ID',
    'AUTH0_DOMAIN',
    'CLIENT_URL',
    'APP_NAME',
    'AUTH0_API_AUDIENCE',
    'AUTH0_REALM',
    'STRIPE_PUBLISHABLE_KEY',
    'CDE_WORKSPACE_DOMAIN',
    'CDE_WORKSPACE_URL_PRFIX',
    'AUTH0_TOKEN_GRANTED_TIME',
    'ZIPKIN_URL',
    'EXTENSION_SOCKET_URL',
];

const isBrowser = typeof window !== 'undefined';
// const base = (isBrowser ? ( window.__ENV__ || __ENV__) : process.env) || {};
const base = {
    AUTH0_CLIENT_ID: 'GVh8k85SAftTTRbotGxsc986piXsR825',
    AUTH0_DOMAIN: 'dev-cdebase.auth0.com',
    AUTH0_ISSUER: 'https://dev-cdebase.auth0.com/',
    AUTH0_API_AUDIENCE: 'https://dev-cdebase.auth0.com/api/v2/',
    STRIPE_ENDPOINT_SECRET: 'werwerw',
    CLIENT_URL: 'http://localhost',
};

const env: any = {};
for (const v of publicEnv) {
    env[v] = base[v];
}

export default env;

if (isBrowser) {
    process[lowerCase('env')] = env; // to avoid webpack to replace `process` with actual value.
    process.APP_ENV = env;
}
export const PUBLIC_SETTINGS: __PUBLIC_SETTINGS__ = {
    apolloLogging: false,
    GRAPHQL_URL: process.env.GRAPHQL_URL || env.GRAPHQL_URL || __GRAPHQL_URL__,
    LOCAL_GRAPHQL_URL: process.env.LOCAL_GRAPHQL_URL || __GRAPHQL_URL__,
    LOG_LEVEL: process.env.LOG_LEVEL || 'trace',
};

```

# portable-devices/desktop/src/renderer/config/index.ts

```ts
export * from './config';

```

# portable-devices/desktop/src/renderer/config/config.ts

```ts
import * as envalid from 'envalid';

const { str, bool, num } = envalid;

export const config = envalid.cleanEnv(process.env, {
    NODE_ENV: str({ default: 'production', choices: ['production', 'staging', 'development', 'test'] }),
    BACKEND_URL: str({ devDefault: __BACKEND_URL__ }),
    LOCAL_BACKEND_URL: str({ devDefault: __BACKEND_URL__ }),
    LOCAL_GRAPHQL_URL: str({ default: __GRAPHQL_URL__ }),
    GRAPHQL_URL: str({ devDefault: __GRAPHQL_URL__ }),
    CLIENT_URL: str({ devDefault: __BACKEND_URL__ }),
    NAMESPACE: str({ default: 'default' }),
    AUTH0_TOKEN_GRANTED_TIME: num({ default: 2592000000, desc: 'set to 30 days(30*24*60*60*1000) by default' }),
});

```

# portable-devices/desktop/src/renderer/components/WindowHeader.tsx

```tsx
import * as React from 'react';

export class WindowHeader extends React.Component {
  handleWindowClose = () => {
    if (this.props.close) {
      remote.app.dock.hide();
      remote.getCurrentWindow().hide();
    }
    return false;
  }
  handleWindowMinimize = () => {
    if (this.props.minimize) {
      remote.getCurrentWindow().minimize();
    }
    return false;
  }
  handleWindowToggleMaximize = () => {
    if (this.props.maximize) {
      if (remote.getCurrentWindow().isMaximized()) {
        remote.getCurrentWindow().unmaximize();
      } else {
        remote.getCurrentWindow().maximize();
      }
    }
    return false;
  }

  render() {
    return (
      <div className='window-header' onDoubleClick={ this.handleWindowToggleMaximize }>
        <div className='window-header-controls'>
          <div className={`btn ${this.props.close    ? 'close'    : 'disabled' }`} onClick={ this.handleWindowClose } />
          <div className={`btn ${this.props.minimize ? 'minimize' : 'disabled' }`} onClick={ this.handleWindowMinimize } />
          <div className={`btn ${this.props.maximize ? 'maximize' : 'disabled' }`} onClick={ this.handleWindowToggleMaximize } />
        </div>

        <div className='window-header-title'>{this.props.title}</div>
      </div>
    );
  }
};

```

# portable-devices/desktop/src/renderer/app/Tray.tsx

```tsx
import { hot } from 'react-hot-loader/root';
import * as React from 'react';
import { RendererProvider } from 'react-fela';
import { ApolloProvider } from '@apollo/client';
import { Provider } from 'react-redux';
import { rehydrate } from 'fela-dom';
import createRenderer from '../config/tray/fela-renderer';
import { createClientContainer } from '../config/main/client.service';
import { epic$ } from '../config/tray/epic-config';
import { ConnectedRouter } from 'connected-react-router';
import { createReduxStore, history } from '../config/tray/redux-config';
import { MainRoute } from '../modules/tray';
import { ErrorBoundary } from './ErrorBoundary';

const { apolloClient: client, container } = createClientContainer();

let store;
if ((module as any).hot && (module as any).hot.data && (module as any).hot.data.store) {
    // console.log('Restoring Redux store:', JSON.stringify((module as any).hot.data.store.getState()));
    store = (module as any).hot.data.store;
    // replace the reducers always as we don't have ablity to find
    // new reducer added through our `modules`
    // store.replaceReducer(storeReducer((module as any).hot.data.history || history));
} else {
    store = createReduxStore();
}
if ((module as any).hot) {
    (module as any).hot.dispose((data) => {
        // console.log("Saving Redux store:", JSON.stringify(store.getState()));
        data.store = store;
        data.history = history;
        // Force Apollo to fetch the latest data from the server
        delete window.__APOLLO_STATE__;
    });
    (module as any).hot.accept('../config/tray/epic-config', () => {
        // we may need to reload epic always as we don't
        // know whether it is updated using our `modules`
        const nextRootEpic = require('../config/tray/epic-config').rootEpic;
        // First kill any running epics
        store.dispatch({ type: 'EPIC_END' });
        // Now setup the new one
        epic$.next(nextRootEpic);
    });
}
export class Main extends React.Component<{}, {}> {
    public render() {
        const renderer = createRenderer();
        rehydrate(renderer);
        return (
            <ErrorBoundary>
                <Provider store={store}>
                    <ApolloProvider client={client}>
                        <RendererProvider renderer={renderer}>
                            <ConnectedRouter history={history}>
                                <MainRoute />
                            </ConnectedRouter>,
                        </RendererProvider>
                    </ApolloProvider>
                </Provider>
            </ErrorBoundary>
        );
    }
}

export default hot(Main);

```

# portable-devices/desktop/src/renderer/app/ServerError.tsx

```tsx
class ServerError extends Error {
    constructor(error: any) {
        super();
        for (const key of Object.getOwnPropertyNames(error)) {
            this[key] = error[key];
        }
        this.name = 'ServerError';
    }
}

export { ServerError };

```

# portable-devices/desktop/src/renderer/app/Main.tsx

```tsx
import { hot } from 'react-hot-loader/root';
import * as React from 'react';
import { RendererProvider } from 'react-fela';
import { ApolloProvider } from '@apollo/client';
import { Provider } from 'react-redux';
import { rehydrate } from 'fela-dom';
import { PluginArea } from '@common-stack/client-react';
import { ConnectedRouter } from 'connected-react-router';
import { PersistGate } from 'redux-persist/integration/react';
import { persistStore } from 'redux-persist';
import createRenderer from '../config/main/fela-renderer';
import { createReduxStore } from '../config/main/redux-config';
import { createClientContainer } from '../config/main/client.service';
import modules, { MainRoute } from '../modules/main';
import { ErrorBoundary } from './ErrorBoundary';

const { apolloClient: client } = createClientContainer();

const { store, history } = createReduxStore();
export class Main extends React.Component<{}, {}> {
    render() {
        const renderer = createRenderer();
        const persistor = persistStore(store);
        rehydrate(renderer);
        return (
            <ErrorBoundary>
                <Provider store={store}>
                    <ApolloProvider client={client}>
                        <RendererProvider renderer={renderer}>
                            <PersistGate persistor={persistor}>
                                <PluginArea />
                                {modules.getWrappedRoot(
                                    <ConnectedRouter history={history}>
                                        <MainRoute />
                                    </ConnectedRouter>,
                                )}
                            </PersistGate>
                        </RendererProvider>
                    </ApolloProvider>
                </Provider>
            </ErrorBoundary>
        );
    }
}

export default hot(Main);

```

# portable-devices/desktop/src/renderer/app/ErrorBoundary.tsx

```tsx
import * as React from 'react';
import { Error500 } from './500';
import { ServerError } from './ServerError';

type IErrorBoundryState = { error: any; type: string };

export class ErrorBoundary extends React.Component<any, IErrorBoundryState> {
    constructor(props) {
        super(props);
        const serverError: any = __CLIENT__ ? window.__SERVER_ERROR__ : null;
        if (serverError) {
            this.state = { error: new ServerError(serverError), type: 'serverError' };
        } else {
            this.state = { error: undefined, type: undefined };
        }
    }

    componentDidCatch(error) {
        let type;

        if (process.env.NODE_ENV === 'production') {
            type = '404';
        } else {
            type = '500';
        }
        // Update state so the next render will show the fallback UI.
        this.setState({ error, type });
    }

    render() {
        const { error, type } = this.state;
        if (error) {
            return <Error500 error={error} />;
        }
        return this.props.children;
    }
}

```

# portable-devices/desktop/src/renderer/app/About.tsx

```tsx
import React, { Component } from 'react'

const pJson = require('../../../package.json');
const timeTrackerIcon = require('../../../assets/icon.png');

export default class About extends Component {

  render() {
    return (
      <div className='window'>
        <div className='mt-45 text-center' style={{ width: 500 }}>
          <img src={timeTrackerIcon} style={{ width: 64 }} />
          <div className='version'>Version {pJson.version}</div>
          <div>copyright &copy; cqb325@163.com</div>
        </div>
      </div>
    )
  }
}

```

# portable-devices/desktop/src/renderer/app/500.tsx

```tsx
import * as React from 'react';

export const Error500 = ({ error }: any) => {
    React.useEffect(() => {
        console.trace(error);
    }, [error]);

    return (
        <div>ERROR</div>
    );
}
```

# portable-devices/desktop/src/main/views/tray.ts

```ts
/* eslint-disable no-unused-expressions */
/* eslint-disable no-use-before-define */
import { BrowserWindow, ipcMain, Tray } from 'electron';
import { ElectronTypes } from '@common-stack/client-core';
import * as path from 'path';
import { createWindow, provideSingleton } from '../utils';
import { isDev } from '../../common';

import { IPC_EVENTS } from '../../common';

const iconPath = path.join(__dirname, './icons/16x16.png');

@provideSingleton(ElectronTypes.TrayWindow)
export class TrayWindow {
    private window: BrowserWindow;

    private trayIcon: Tray;

    constructor() {
        this.window = createWindow({
            show: false,
            name: 'tray-page',
            remote: true,
            height: 500,
            width: 500,
            backgroundColor: '#E4ECEF',
            frame: false,
            fullscreenable: false,
            resizable: !isDev,
            transparent: true,
            webPreferences: {
                nodeIntegration: true,
                webSecurity: false,
                enableRemoteModule: true,
                // add preload to load esm
                preload: path.resolve(path.join(__dirname, 'preload.js')),
                devTools: true,
            },
        });
        // Object BrowserWindow has a lot of standart events
        // We will hide Tray window on blur. To emulate standart behavior of the tray-like apps.
        this.window.on('blur', () => {
            this.window.hide();
        });

        this.trayIcon = new Tray(iconPath);
        this.trayIcon.setToolTip('Sample Desktop'); // This tooltip will show up, when user hovers over our tray-icon.

        // By clicking on the icon we have to show TrayWindow and position it in the middle under
        // the tray icon (initially this window is hidden).
        this.trayIcon.on('click', this.toggleWidow);
        // ipcMain.on(WB_HIDE_TRAY, this.ipcHideTray);
        // ipcMain.on(WB_SHOW_TRAY, this.ipcShowTray);
    }

    private toggleWidow = (e, bounds) => {
        this.window.isVisible() ? this.window.hide() : this.showWindow();
    };

    // Since we want the window to be shown under our icon, we need to get the position of the icon and then set the position of the window to be right under it. To achieve this, we create a getWindowPosition() method:
    private getWindowPosition = () => {
        const windowBounds = this.window.getBounds();
        const trayBounds = this.trayIcon.getBounds();

        // Center window horizontally below the tray icon
        const x = Math.round(trayBounds.x + trayBounds.width / 2 - windowBounds.width / 2);
        // Position window 4 pixels vertically below the tray icon
        const y = Math.round(trayBounds.y + trayBounds.height + 4);
        return { x, y };
    };

    // This is a simple show / hide method. We’re using a one-line if statement; if the window is visible, hide it. If not, show it. The isVisible() method comes from Electron. Here is our showWindow() method:
    private showWindow = () => {
        const position = this.getWindowPosition();
        this.window.setPosition(position.x, position.y, false);
        this.window.show();
    };

    show() {
        this.window.show();
    }

    close() {
        this.window.close();
        this.window = null;
    }

    public updateTitle(title: string) {
        this.trayIcon.setTitle(title);
    }
}

```

# portable-devices/desktop/src/main/views/main.ts

```ts
/* eslint-disable no-use-before-define */
import { BrowserWindow, ipcMain } from 'electron';
import { ElectronTypes } from '@common-stack/client-core';
import * as path from 'path';
import { createWindow, provideSingleton } from '../utils';
import { IPC_EVENTS } from '../../common';

@provideSingleton(ElectronTypes.MainWindow)
export class MainWindow {
    private window: BrowserWindow;

    constructor() {
        this.startWindow();
    }

    private startWindow() {
        this.window = createWindow({
            name: 'main-page',
            show: true,
            remote: true,
            webPreferences: {
                nodeIntegration: true,
                webSecurity: false,
                enableRemoteModule: true,
                // add preload to load esm
                preload: path.resolve(path.join(__dirname, 'preload.js')),
            },
        });
        this.window.on('close', (event) => {
            (event as any).sender.hide();
            event.preventDefault(); // prevent quit process
        });
        // Custom events MAIN WINDOW
        ipcMain.on(IPC_EVENTS.SHOW_MAIN, function () {
            if (this.window) {
                this.window.show();
            }
        });
    }

    show() {
        this.window.show();
    }

    close() {
        this.window.close();
        this.window = null;
    }
}

```

# portable-devices/desktop/src/main/views/index.ts

```ts
export { MainWindow } from './main';
export { AboutWindow } from './about';
export { TrayWindow } from './tray';

```

# portable-devices/desktop/src/main/views/about.ts

```ts
/* eslint-disable no-use-before-define */
import { provide } from 'inversify-binding-decorators';
import { BrowserWindow, ipcMain } from 'electron';
import Positioner from 'electron-positioner';
import { ElectronTypes } from '@common-stack/client-core';
import { createWindow } from '../utils';
import { IPC_EVENTS } from '../../common';

@provide(ElectronTypes.AboutWindow)
export class AboutWindow {
    private window: BrowserWindow;

    constructor() {
        this.window = createWindow({ name: 'about-page', height: 250, width: 300, remote: true });
        // Object BrowserWindow has a lot of standart events
        // We will hide Tray window on blur. To emulate standart behavior of the tray-like apps.
        this.window.on('blur', () => {
            this.window.hide();
        });

        // On show - we should display About Window in the center of the screen.
        this.window.on('show', () => {
            const positioner = new Positioner(this.window);
            (positioner as any).move('center');
        });

        ipcMain.on(IPC_EVENTS.SHOW_ABOUT, () => {
            this.window.show();
        });
    }

    show() {
        this.window.show();
    }

    close() {
        this.window.close();
        this.window = null;
    }
}

```

# portable-devices/desktop/src/main/utils/ioc.ts

```ts
import { fluentProvide } from 'inversify-binding-decorators';

export const provideSingleton = (identifier: any) => fluentProvide(identifier).inSingletonScope().done();

```

# portable-devices/desktop/src/main/utils/index.ts

```ts
export * from './logger';
export * from './window';
export * from './ioc';
export * from './sqlite/connection';

export * from './AutoUpdater';

```

# portable-devices/desktop/src/main/utils/createProtocol.ts

```ts
import { protocol } from 'electron';
import { URL } from 'url';
import * as path from 'path';

export default (scheme: string) => {
    protocol.registerFileProtocol(scheme, (request, respond) => {
        let pathName = new URL(request.url).pathname;
        pathName = decodeURI(pathName); // Needed in case URL contains spaces

        const filePath = path.join(__dirname, pathName);
        respond({ path: filePath });
    });
};

```

# portable-devices/desktop/src/main/utils/AutoUpdater.ts

```ts
/* eslint-disable no-use-before-define */
import { autoUpdater } from 'electron-updater';
import { provide } from 'inversify-binding-decorators';

@provide(AppUpdater)
export class AppUpdater {
    constructor() {
        autoUpdater.checkForUpdatesAndNotify();
    }
}

```

# portable-devices/desktop/src/main/services/index.ts

```ts
export { UserService } from './User';
export { SystemService } from './System';
export { Logger } from './Logger';

```

# portable-devices/desktop/src/main/services/User.ts

```ts
/* eslint-disable no-use-before-define */
import { provide } from 'inversify-binding-decorators';
import { inject } from 'inversify';
import { Repository } from 'typeorm';

import { User } from '../models';
import TYPES from '../ioc/types';

@provide(UserService)
export class UserService {
    @inject(TYPES.UserRepository) private model!: Repository<User>;

    /**
     * Create an object
     * @param name
     * @param surname
     */
    public insert(name: string, surname: string): Promise<User> {
        return this.model.save({ name, surname });
    }

    public async finAll(): Promise<User[]> {
        return this.model.find();
    }
}

```

# portable-devices/desktop/src/main/services/System.ts

```ts
/* eslint-disable class-methods-use-this */
/* eslint-disable no-use-before-define */
import { systemPreferences } from 'electron';
import { provideSingleton } from '../utils';
import { isMacOS } from '../../common';

@provideSingleton(SystemService)
export class SystemService {
    /**
     * Check availability
     */
    checkAccessibilityForMacOS() {
        if (!isMacOS) return;
        return systemPreferences.isTrustedAccessibilityClient(true);
    }
}

```

# portable-devices/desktop/src/main/services/Logger.ts

```ts
/* eslint-disable @typescript-eslint/ban-types */
import { arch, cpus, platform, release, totalmem } from 'os';
import osName from 'os-name';
import { app } from 'electron';
import { isDev } from '../../common';
import { logger, getLogger } from '../utils';

interface LogInfo {
    level: any;
    message: string;
    key: any;
}

interface WithLogParams {
    before?: LogInfo | Function;
    after?: LogInfo | Function;
}

export class Logger {
    /**
     * Record system log
     */
    static logSystemInfo = () => {
        if (isDev) return;
        logger.divider();
        logger.info('Start the app...');

        logger.info(`Operating system: ${platform()} ${release()}(${arch()}`);
        logger.info(`System version: ${osName()}`);
        logger.info(`Processor: ${cpus().length} core`);
        logger.info(`Total memory: ${(totalmem() / 1024 / 1024 / 1024).toFixed(0)}G`);
        logger.info(`installation path: ${app.getAppPath()}`);
        logger.divider();
    };

    /**
     * Bring the log section to the subject
     * @param before
     * @param after
     */
    static withLog =
        ({ before, after }: WithLogParams) =>
        (func: Function) => {
            if (before) {
                if (typeof before === 'function') {
                    before();
                } else {
                    const logger = getLogger(before.key);
                    logger[before.level](before.message);
                }
            }

            func();

            if (after) {
                if (typeof after === 'function') {
                    after();
                } else {
                    const logger = getLogger(after.key);
                    logger[after.level](after.message);
                }
            }
        };
}

```

# portable-devices/desktop/src/main/modules/module.ts

```ts
import { Feature } from '@common-stack/client-react';
import ElectronMainModule from '@sample-stack/counter-module-electron';

const modules = new Feature(ElectronMainModule);

export default modules;

```

# portable-devices/desktop/src/main/modules/index.ts

```ts
import { ClientTypes } from '@common-stack/client-react';
import { interfaces } from 'inversify';
import modules from './module';
import parentContainer from '../ioc';
import { logger } from '../utils/logger';

class UtilityClass {
    // tslint:disable-next-line:no-shadowed-variable
    constructor(private modules) {}

    public getCacheKey(storeObj) {
        return this.modules.getDataIdFromObject(storeObj);
    }
}

const utility = new UtilityClass(modules);

// additional bindings to container
const container = modules.createContainers({}) as interfaces.Container;
container.bind(ClientTypes.Logger).toConstantValue(logger);
container.bind(ClientTypes.UtilityClass).toConstantValue(utility);
container.parent = parentContainer;

export default modules;
export { container, logger };

```

# portable-devices/desktop/src/main/models/index.ts

```ts
export * from './User';

```

# portable-devices/desktop/src/main/models/User.ts

```ts
import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity('User')
export class User {
    @PrimaryGeneratedColumn()
    id?: number;

    @Column('text', { nullable: true })
    name?: string;

    @Column('text', { nullable: true })
    surname?: string;
}

```

# portable-devices/desktop/src/main/ioc/types.ts

```ts
const TYPES = {
    UserRepository: Symbol.for('UserRepository'),
};

export default TYPES;

```

# portable-devices/desktop/src/main/ioc/loader.ts

```ts
import '../app';
import '../services';
import '../views';
import '../utils/sqlite/connection';
import '../utils/AutoUpdater';

```

# portable-devices/desktop/src/main/ioc/inversify.config.ts

```ts
import { AsyncContainerModule, Container } from 'inversify';
import { buildProviderModule } from 'inversify-binding-decorators';
import type { Repository } from 'typeorm';
import { User } from '../models';
import { getDBConnection, getRepository } from '../utils';
import TYPES from './types';

import './loader';
// container
const container = new Container();

container.load(buildProviderModule());

export default container;

/**
 * Load asynchronous objects
 */
export const asyncBindings = new AsyncContainerModule(async (bind) => {
    await getDBConnection();

    bind<Repository<User>>(TYPES.UserRepository)
        .toDynamicValue(() => getRepository(User))
        .inRequestScope();
});

```

# portable-devices/desktop/src/main/ioc/index.ts

```ts
import 'reflect-metadata';
import container, { asyncBindings } from './inversify.config';

export default container;

export const loadContainerAsync = async () => {
    await container.loadAsync(asyncBindings);
    return container;
};

```

# portable-devices/desktop/src/main/interfaces/tray-window.ts

```ts
import { BrowserWindow } from 'electron';

export interface ITrayWindow {
    window: BrowserWindow;
    init(): void;
}

```

# portable-devices/desktop/src/main/interfaces/tray-icon.ts

```ts
import { Tray } from 'electron';

export interface ITraceIcon {
    trayIcon: Tray;
    updateTitle(title: string): void;
}

```

# portable-devices/desktop/src/main/interfaces/index.ts

```ts
export * from './tray-icon';
export * from './tray-window';

export const TYPES = {
    ITrayIcon: 'ITrayIcon',
    ITrayWindow: 'ITrayWindow',
};

```

# portable-devices/desktop/src/main/config/redux-electron-config.ts

```ts
import { triggerAlias, replayActionMain, forwardToRenderer } from 'electron-redux';
import { createEpicMiddleware } from 'redux-observable';
import modules, { container } from '../modules';
import { createReduxStore as createBaseReduxStore } from '../../common/config/base-redux-config';
import { rootEpic } from './epic-config';
import { isDev } from '../../common';

export const epicMiddleware = createEpicMiddleware({
    dependencies: {
        routes: modules.getConfiguredRoutes(),
        container,
    },
});

/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = () => {
    const store = createBaseReduxStore({
        scope: 'ElectronMain',
        isDebug: __DEBUGGING__,
        isDev,
        initialState: {},
        epicMiddleware,
        rootEpic,
        middleware: [triggerAlias],
        postMiddleware: [forwardToRenderer],
        reducers: modules.reducers,
    });

    replayActionMain(store);
    return store;
};

```

# portable-devices/desktop/src/main/config/epic-config.ts

```ts
import { combineEpics, ofType } from 'redux-observable';
import { BehaviorSubject } from 'rxjs';
import { mergeMap, takeUntil } from 'rxjs/operators';
import modules from '../modules';

export const epic$ = new BehaviorSubject(combineEpics(...modules.epics));

// Since we're using mergeMap, by default any new
// epic that comes in will be merged into the previous
// one, unless an EPIC_END action is dispatched first,
// which would cause the old one(s) to be unsubscribed
export const rootEpic = (action$, ...rest) =>
    epic$.pipe<any>(mergeMap((epic) => epic(action$, ...rest).pipe(takeUntil(action$.pipe(ofType('EPIC_END'))))));

```

# portable-devices/desktop/src/main/config/client.service.ts

```ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ClientTypes } from '@common-stack/client-core';
import { interfaces } from 'inversify';
import { ApolloClient } from '@apollo/client';
import { CdmLogger } from '@cdm-logger/core';
import modules, { container, logger } from '../modules';
import { createApolloClient } from '../../common/config/base-apollo-client';
import { PUBLIC_SETTINGS } from '../../renderer/config/public-config';

let __CLIENT_SERVICE__: {
    apolloClient: ApolloClient<any>;
    container: interfaces.Container;
    services: any;
    logger: CdmLogger.ILogger;
};
export const createClientContainer = () => {
    if (__CLIENT_SERVICE__) {
        return __CLIENT_SERVICE__;
    }
    const clientState = modules.getStateParams({ resolverContex: () => modules.createService({}, {}) });
    const { cache, apolloClient } = createApolloClient({
        httpGraphqlURL: PUBLIC_SETTINGS.GRAPHQL_URL,
        httpLocalGraphqlURL: PUBLIC_SETTINGS.LOCAL_GRAPHQL_URL,
        isDev: process.env.NODE_ENV === 'development',
        isDebug: __DEBUGGING__,
        isSSR: __SSR__,
        scope: 'server',
        clientState,
        getDataIdFromObject: (result) => modules.getDataIdFromObject(result),
        initialState: null,
        logger,
    });
    // attaching the context to client as a workaround.
    container.bind(ClientTypes.ApolloClient).toConstantValue(apolloClient);
    container.bind(ClientTypes.InMemoryCache).toConstantValue(cache);
    const services = modules.createService({}, {});
    (apolloClient as any).container = services;

    __CLIENT_SERVICE__ = {
        container,
        apolloClient,
        services,
        logger,
    };
    return __CLIENT_SERVICE__;
};

```

# portable-devices/desktop/src/main/app/index.ts

```ts
export { Service } from './Service';
export { App } from './App';
export { View } from './View';

```

# portable-devices/desktop/src/main/app/View.ts

```ts
/* eslint-disable no-use-before-define */
import { inject } from 'inversify';
import { ElectronTypes } from '@common-stack/client-core';
import { MainWindow, TrayWindow, AboutWindow } from '../views';
import { logAfter, logBefore, provideSingleton } from '../utils';

@provideSingleton(View)
export class View {
    @inject(ElectronTypes.MainWindow)
    main!: MainWindow;

    @inject(ElectronTypes.AboutWindow)
    about!: AboutWindow;

    @inject(ElectronTypes.TrayWindow)
    tray!: TrayWindow;

    /**
     * Process all window initialization
     */
    @logBefore('[View] Initialization...')
    @logAfter('[View] Initialization complete!')
    init() {
        // Window on the bridge
        // global.windows = {
        //     home: this.home,
        //     tray: this.tray,
        //     about: this.about,
        // };
    }

    close() {
        this.main.close();
        this.about.close();
        this.tray.close();
    }
}

```

# portable-devices/desktop/src/main/app/Service.ts

```ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-use-before-define */
import { inject } from 'inversify';
import { ipcMain } from 'electron';
import { logAfter, logBefore, provideSingleton } from '../utils';
import { CHANNELS } from '../../common';
import { SystemService, UserService } from '../services';

@provideSingleton(Service)
export class Service {
    /** Service class * */

    @inject(UserService)
    user!: UserService;

    @inject(SystemService)
    system!: SystemService;

    /**
     * Handle the initialization of all services
     */
    @logBefore('[Service] Initialize service...')
    @logAfter('[Service] Initialization complete!')
    init() {
        // Service on the bridge
        // global.services = {
        //     user: this.user,
        //     system: this.system,
        // };

        // Check macOS permissions on the bridge
        ipcMain.handle(CHANNELS.CHECK_ACCESSIBILITY_FOR_MAC_OS, this.system.checkAccessibilityForMacOS);
    }
}

```

# portable-devices/desktop/src/main/app/App.ts

```ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-use-before-define */
import { inject } from 'inversify';
import { app, ipcMain, Menu } from 'electron';
import { windows } from 'electron-is';
import { logger, provideSingleton } from '../utils';
import { template } from '../menu-template';
import { Service } from './Service';
import { View } from './View';

@provideSingleton(App)
export class App {
    constructor() {
        app.whenReady().then(() => {
            this.services.init();

            this.views.init();

            logger.info('The app is initialized!');
        });

        app.on('window-all-closed', () => {
            if (windows()) {
                app.quit();
            }
        });
        app.on('activate', this.onActivate);

        app.on('before-quit', () => {
            this.beforeQuit();
            app.exit();
        });

        ipcMain.on('show-main-window-event', () => {
            app.dock.show();
        });

        Menu.setApplicationMenu(Menu.buildFromTemplate(template));
    }

    @inject(View)
    views!: View;

    @inject(Service)
    services!: Service;

    onActivate = () => {
        this.views.main.show();
        app.dock.show();
    };

    beforeQuit() {
        this.views.close();
    }
}

```

# portable-devices/desktop/src/common/utils/logger.ts

```ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable @typescript-eslint/ban-types */
import { CdmLogger } from '@cdm-logger/core';
/**
 *  Create log proxy method
 * @param logLevel log level
 * @param mainLogger log object
 * @return {function}
 */
export const createLogProxy =
    (logLevel: string, mainLogger: CdmLogger.ILogger) =>
    (fn: Function) =>
    (...args: any) => {
        fn(...args);
        mainLogger[logLevel](...args);
    };

```

# portable-devices/desktop/src/common/utils/is.ts

```ts
/* eslint-disable import/no-extraneous-dependencies */
import { osx, windows as _windows, main, renderer } from 'electron-is/is';

/**
 * Determine whether it is a mac platform
 */
export const isMacOS = osx();

/**
 * Determine whether it is windows
 */
export const isWindows = _windows();

export const isMain = main();

export const isRenderer = renderer();

export const isDev = process.env.NODE_ENV === 'development';

export const isTest = process.env.NODE_ENV === 'test';

```

# portable-devices/desktop/src/common/utils/index.ts

```ts
export * from './is';
export * from './logger';

```

# portable-devices/desktop/src/common/constants/ipcEvents.ts

```ts
const enum IPC_EVENTS {
    // MAIN
    SHOW_MAIN = 'SHOW_MAIN',
    // ABOUT
    SHOW_ABOUT = 'SHOW_ABOUT',

    // Tray
    HIDE_TRAY = 'HIDE_TRAY',
    SHOW_TRAY = 'SHOW_TRAY',
    SHOW_TRAY_WINDOWED = 'SHOW_TRAY_WINDOWED',
    TRAY_OPEN_ITEM = 'TRAY_OPEN_ITEM',
    TRAY_TOGGLE_AWLAYS_ON_TOP = 'TRAY_TOGGLE_AWLAYS_ON_TOP',
    TRAY_WINDOWED_MODE_CHANGED = 'TRAY_WINDOWED_MODE_CHANGED',
    TRAY_WINDOWED_ALWAYS_ON_TOP_CHANGED = 'TRAY_WINDOWED_ALWAYS_ON_TOP_CHANGED',
    TOGGLE_TRAY_WITH_BOUNDS = 'TOGGLE_TRAY_WITH_BOUNDS',
    TRAY_ICON_CREATED = 'TRAY_ICON_CREATED',
    TRAY_ICON_DESTROYED = 'TRAY_ICON_DESTROYED',
}

export { IPC_EVENTS };

```

# portable-devices/desktop/src/common/constants/index.ts

```ts
export * from './ipcEvents';

```

# portable-devices/desktop/src/common/config/config.ts

```ts
/// <reference path='../../../../../typings/index.d.ts' />
import * as envalid from 'envalid';

const { str, bool, json, num } = envalid;

export const config = envalid.cleanEnv(process.env, {
    NODE_ENV: str({ default: 'production', choices: ['production', 'staging', 'development', 'test'] }),
    ELECTRON_WEBPACK_WDS_PORT: num({ default: 3000 }),
    ELECTRON_WEBPACK_WDS_HOST: str({ default: 'localhost' }),
    // BACKEND_URL: str({ devDefault: __BACKEND_URL__ }),
    // GRAPHQL_URL: str({ devDefault: __GRAPHQL_URL__ }),
    CLIENT_URL: str({ default: 'http://localhost' }),
    NAMESPACE: str({ default: 'default' }),
    apolloLogging: bool({ default: false, devDefault: true }),
});

```

# portable-devices/desktop/src/common/config/base-redux-config.ts

```ts
// version 11/12/2021
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable global-require */
/* eslint-disable no-underscore-dangle */
import {
    createStore,
    combineReducers,
    applyMiddleware,
    StoreEnhancer,
    Middleware,
    compose,
    Action,
    ReducersMapObject,
    PreloadedState,
} from 'redux';
import { EpicMiddleware, Epic } from 'redux-observable';
import { persistReducer, PersistConfig } from 'redux-persist';
// import thunkMiddleware from 'redux-thunk';

interface IReduxStore<S = any> {
    scope: 'browser' | 'server' | 'native' | 'ElectronMain';
    isDebug: boolean;
    isDev: boolean;
    reducers: ReducersMapObject<S>;
    rootEpic?: Epic<Action<S>, Action<any>, void, any>;
    epicMiddleware?: EpicMiddleware<Action<S>, Action<any>>;
    preMiddleware?: Middleware[];
    postMiddleware?: Middleware[];
    middleware?: Middleware[];
    initialState: PreloadedState<S>;
    persistConfig?: PersistConfig<S, any>;
}
/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = ({
    scope,
    isDebug,
    isDev,
    reducers,
    rootEpic,
    epicMiddleware,
    preMiddleware,
    postMiddleware,
    middleware,
    initialState = {},
    persistConfig,
}: IReduxStore<any>) => {
    const isBrowser = scope === 'browser';
    const isElectronMain = scope === 'ElectronMain';
    /**
     * Add middleware that required for this app.
     */

    const middlewares: Middleware[] = [];
    // add epicMiddleware
    if (epicMiddleware) {
        middlewares.push(epicMiddleware);
    }
    if (preMiddleware) {
        middlewares.unshift(...preMiddleware);
    }
    // Add redux logger during development only
    if ((isDev || isDebug) && isBrowser) {
        const { createLogger } = require('redux-logger');

        middlewares.push(
            createLogger({
                level: 'info',
                collapsed: true,
            }),
        );
    }

    if (middleware) {
        middlewares.push(...middleware);
    }

    if (postMiddleware) {
        middlewares.push(...postMiddleware);
    }

    const enhancers: () => StoreEnhancer<any>[] = () => [applyMiddleware(...middlewares)];

    const composeEnhancers: any =
        ((isDev || isDebug) && isBrowser && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) || compose;

    const rootReducer = combineReducers(reducers);
    const persistedReducer = persistConfig ? persistReducer(persistConfig, rootReducer) : rootReducer;

    const store = createStore(persistedReducer, initialState, composeEnhancers(...enhancers()));
    if (isBrowser || isElectronMain) {
        // no SSR for now
        if (epicMiddleware) {
            epicMiddleware.run(rootEpic);
        }
    }

    return store;
};

```

# portable-devices/desktop/src/common/config/base-apollo-client.ts

```ts
// version 09/18/2021
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
import { ApolloClient, ApolloClientOptions, ApolloLink } from '@apollo/client';
import { InMemoryCache } from '@apollo/client/cache';
import { HttpLink, createHttpLink } from '@apollo/client/link/http';
import { BatchHttpLink } from '@apollo/client/link/batch-http';
import { onError } from '@apollo/client/link/error';
import { WebSocketLink } from '@apollo/client/link/ws';
import { getOperationAST } from 'graphql';
import { invariant } from 'ts-invariant';
import { IClientState } from '@common-stack/client-core';
import fetch from 'node-fetch';
import { ConnectionParams } from 'subscriptions-transport-ws';
import { isBoolean, merge } from 'lodash';
import { CdmLogger } from '@cdm-logger/core';
import { RetryLink } from '@apollo/client/link/retry';

const schema = `

`;

interface IApolloClientParams {
    initialState?: any;
    scope: 'browser' | 'server' | 'native';
    getDataIdFromObject: (x?: any) => string;
    clientState: IClientState;
    isDebug: boolean;
    isDev: boolean;
    isSSR: boolean;
    httpGraphqlURL: string;
    httpLocalGraphqlURL: string;
    logger: CdmLogger.ILogger;
}

const errorLink = onError(({ graphQLErrors, networkError }) => {
    if (graphQLErrors) {
        graphQLErrors.map(({ message, locations, path }) =>
            // tslint:disable-next-line
            invariant.warn(`[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`),
        );
    }
    if (networkError) {
        // tslint:disable-next-line
        invariant.warn(`[Network error]: ${networkError}`);
    }
});

let _apolloClient: ApolloClient<any>;
let _memoryCache: InMemoryCache;
export const createApolloClient = ({
    scope,
    isDev,
    isDebug,
    isSSR,
    getDataIdFromObject,
    clientState,
    httpGraphqlURL,
    httpLocalGraphqlURL,
    initialState,
    logger,
}: IApolloClientParams) => {
    const isBrowser = scope === 'browser';
    const isServer = scope === 'server';
    let link;

    const cache = new InMemoryCache({
        dataIdFromObject: getDataIdFromObject,
        possibleTypes: clientState.possibleTypes,
    });

    const attemptConditions = async (count: number, operation: any, error: Error) => {
        const promises = (clientState.retryLinkAttemptFuncs || []).map((func) => func(count, operation, error));

        try {
            const result = await promises;
            return !!result.find((item) => item && isBoolean(item));
        } catch (e) {
            logger.trace('Error occured in retryLink Attempt condition', e);
            throw e;
        }
    };

    const retrylink = new RetryLink({
        attempts: attemptConditions,
    });

    if (_apolloClient && _memoryCache) {
        // return quickly if client is already created.
        return {
            apolloClient: _apolloClient,
            cache: _memoryCache,
        };
    }
    _memoryCache = cache;
    if (isBrowser) {
        const connectionParams = async () => {
            const param: ConnectionParams = {};
            for (const connectionParam of clientState.connectionParams) {
                merge(param, await connectionParam);
            }
            return param;
        };

        const wsLink = new WebSocketLink({
            uri: httpGraphqlURL.replace(/^http/, 'ws'),
            options: {
                reconnect: true,
                timeout: 20000,
                reconnectionAttempts: 10,
                lazy: true,
                connectionParams,
                connectionCallback: async (error, result) => {
                    if (error) {
                        logger.error(error, '[WS connectionCallback error] %j');
                    }
                    const promises = (clientState.connectionCallbackFuncs || []).map((func) =>
                        func(wsLink, error, result),
                    );
                    try {
                        await promises;
                    } catch (e) {
                        logger.trace('Error occured in connectionCallback condition', e);
                        throw e;
                    }
                },
            },
            inactivityTimeout: 10000,
        });

        link = ApolloLink.split(
            ({ query, operationName }) => {
                if (operationName.endsWith('_WS')) {
                    return true;
                }
                const operationAST = getOperationAST(query as any, operationName);
                return !!operationAST && operationAST.operation === 'subscription';
            },
            wsLink,
            new HttpLink({
                uri: httpGraphqlURL,
            }),
        );
    } else if (isServer) {
        link = new BatchHttpLink({ uri: httpLocalGraphqlURL, fetch: fetch as any });
    } else {
        link = createHttpLink({ uri: httpLocalGraphqlURL, fetch: fetch as any });
    }

    const links = [errorLink, retrylink, ...(clientState.preLinks || []), link];

    // Add apollo logger during development only
    if (isBrowser && (isDev || isDebug)) {
        const apolloLogger = require('apollo-link-logger');
        links.unshift(apolloLogger.default);
    }

    const params: ApolloClientOptions<any> = {
        queryDeduplication: true,
        typeDefs: schema.concat(<string>clientState.typeDefs),
        resolvers: clientState.resolvers as any,
        link: ApolloLink.from(links),
        cache,
        connectToDevTools: isBrowser && (isDev || isDebug),
    };
    if (isSSR) {
        if (isBrowser) {
            if (initialState) {
                cache.restore(initialState);
            }
            params.ssrForceFetchDelay = 100;
        } else if (isServer) {
            params.ssrMode = true;
        }
    }
    _apolloClient = new ApolloClient<any>(params);

    clientState?.defaults?.forEach((x) => {
        if (x.type === 'query') {
            cache.writeQuery(x);
        } else if (x.type === 'fragment') {
            cache.writeFragment(x);
        }
    });

    return { apolloClient: _apolloClient, cache };
};

```

# packages-modules/counter/server/src/services/index.ts

```ts
export * from './counter-mock-service';
export * from './counter-mock-moleculer-service';
export * from './counter-mock-proxy-service';

```

# packages-modules/counter/server/src/services/counter-mock-service.ts

```ts
import { injectable } from 'inversify';
import { ICounterService } from '../interfaces';

@injectable()
export class CounterMockService implements ICounterService {
    private amount: number;

    constructor() {
        this.amount = 0;
    }

    public counterQuery() {
        return {
            amount: this.amount,
        };
    }

    public addCounter(amount) {
        if (amount) {
            this.amount += amount;
        } else {
            this.amount++;
        }
    }
}

// to make this instance singleton.
const counterMock = new CounterMockService();

export { counterMock };

```

# packages-modules/counter/server/src/services/counter-mock-proxy-service.ts

```ts
import { ServiceBroker, ServiceSettingSchema } from 'moleculer';
import { injectable, inject, tagged } from 'inversify';
import { TaggedType } from '@common-stack/core';
import { Counter } from '../generated-models';
import { ICounterService } from '../interfaces';
import { CounterCommands, NATS_MOLECULER_COUNTER_SERIVCE } from '../constants';

/**
 * Proxies all calls to CounterMock service through Moleculer Borker
 */
@injectable()
export class CounterMockProxyService implements ICounterService {
    constructor(
        @inject('MoleculerBroker')
        private broker: ServiceBroker,

        @inject('Settings')
        @tagged(TaggedType.MICROSERVICE, true)
        private settings: { subTopic: string },
    ) {}

    private topic = NATS_MOLECULER_COUNTER_SERIVCE;

    public counterQuery() {
        return this.broker.call<Counter>(this.fullActionName(CounterCommands.COUNTER_QUERY));
    }

    public addCounter(amount?: number) {
        return this.broker.call<void, any>(this.fullActionName(CounterCommands.ADD_COUNTER), { amount });
    }

    private fullActionName(subCommand: string) {
        return `${this.settings.subTopic}.${this.topic}.${subCommand}`;
    }
}

```

# packages-modules/counter/server/src/services/counter-mock-moleculer-service.ts

```ts
import { ServiceBroker, ServiceSettingSchema, Service, Context } from 'moleculer';
import { injectable, inject, Container } from 'inversify';
import { ICounterService } from '../interfaces';
import { CounterCommands, NATS_MOLECULER_COUNTER_SERIVCE, TYPES } from '../constants';

/**
 * Exposes CounterMock services by registering to the Moleculer Broker.
 * Note: This class is not injectable.
 */
export class CounterMockMoleculerService extends Service {
    private counterMock: ICounterService;

    constructor(broker: ServiceBroker, { container, settings }: { container: Container } & { settings: any }) {
        super(broker);
        const { subTopic } = settings;
        const topic = NATS_MOLECULER_COUNTER_SERIVCE;
        this.counterMock = container.get<ICounterService>(TYPES.CounterMockService);
        this.parseServiceSchema({
            name: topic,
            version: subTopic,
            actions: {
                [CounterCommands.ADD_COUNTER]: {
                    handler: async (ctx: Context<{ amount?: number }>) =>
                        this.counterMock.addCounter(ctx.params.amount),
                },
                [CounterCommands.COUNTER_QUERY]: {
                    handler: async (ctx: Context) => this.counterMock.counterQuery(),
                },
            },
        });
    }
}

```

# packages-modules/counter/server/src/services/counter-mock-microservice.ts

```ts
import { ServiceBroker, ServiceSettingSchema, Service, Context } from 'moleculer';
import { injectable, inject, Container } from 'inversify';
import { ICounterService } from '../interfaces';
import { CounterCommands, NATS_MOLECULER_COUNTER_SERIVCE, TYPES } from '../constants';

/**
 * Exposes CounterMock services by registering to the Moleculer Broker.
 * Note: This class is not injectable.
 */
export class CounterMockMicroservice extends Service {
    private counterMock: ICounterService;

    constructor(broker: ServiceBroker, { container, ...settings }: { container: Container } & { subTopic: string }) {
        super(broker);

        const topic = NATS_MOLECULER_COUNTER_SERIVCE;
        this.counterMock = container.get<ICounterService>(TYPES.CounterMockService);
        this.parseServiceSchema({
            name: topic,
            actions: {
                [CounterCommands.ADD_COUNTER]: {
                    handler: async (ctx: Context<{ amount?: number }>) => {
                        return this.counterMock.addCounter(ctx.params.amount);
                    },
                },
                [CounterCommands.COUNTER_QUERY]: {
                    handler: async (ctx: Context) => {
                        return this.counterMock.counterQuery();
                    },
                },
            },
        });
    }
}

```

# packages-modules/counter/server/src/schema/schema.graphql

```graphql
""" Database counter """
type Counter {
  """ Current amount """
  amount: Int!
}

extend type Query {
  """ Counter """
  counter: Counter

  """ Counter from Datasource """
  counterCache: Counter

  """ Moleculer Counter """
  moleculerCounter: Counter
}

extend type Mutation {
  """ Increase counter value returns current counter amount """
  addCounter(
    """ Amount to add to counter """
    amount: Int
  ): Counter

  """ sync cached counter with current value """
  syncCachedCounter: Boolean

  """ add Counter """
  addMoleculerCounter(amount: Int): Counter
}

extend type Subscription {
  """ Subscription fired when anyone increases counter """
  counterUpdated: Counter

  moleculerCounterUpdate: Counter
}

```

# packages-modules/counter/server/src/resolvers/resolver.ts

```ts
import { IContext } from '../interfaces';
import { IResolvers, Counter } from '../generated-models';

const COUNTER_SUBSCRIPTION = 'counter_subscription';

export const resolver: (options: any) => IResolvers<IContext> = (options) => ({
    Query: {
        counter(obj, args, context) {
            return context.counterMockService.counterQuery() as Counter;
        },
        counterCache(obj, args, context) {
            return context.dataSources.counterCache.counterQuery() as Counter;
        },
        moleculerCounter(obj, args, context) {
            return context.counterMockProxyService.counterQuery();
        },
    },
    Mutation: {
        async addCounter(obj, { amount }, context) {
            await context.counterMockService.addCounter(amount);
            const counter = await context.counterMockService.counterQuery();

            options.pubsub.publish(COUNTER_SUBSCRIPTION, {
                counterUpdated: { amount: counter.amount },
            });

            return counter;
        },
        async addMoleculerCounter(obj, { amount }, { counterMockProxyService }) {
            await counterMockProxyService.addCounter(amount);
            const counter = await counterMockProxyService.counterQuery();

            options.pubsub.publish(COUNTER_SUBSCRIPTION, {
                moleculerCounterUpdate: { amount: counter.amount },
            });

            return counter;
        },
        async syncCachedCounter(obj, args, context) {
            await context.dataSources.counterCache.addCounter();
            return true;
        },
    },
    Subscription: {
        counterUpdated: {
            subscribe: () => options.pubsub.asyncIterator(COUNTER_SUBSCRIPTION),
        },
        moleculerCounterUpdate: {
            subscribe: () => options.pubsub.asyncIterator(COUNTER_SUBSCRIPTION),
        },
    },
});

```

# packages-modules/counter/server/src/resolvers/index.ts

```ts
export * from './resolver';

```

# packages-modules/counter/server/src/interfaces/index.ts

```ts
export * from './context';
export * from './counter-service';

```

# packages-modules/counter/server/src/interfaces/counter-service.ts

```ts
import { Counter } from '../generated-models';

export interface ICounterService {
    counterQuery(): Counter | PromiseLike<Counter> | Promise<Counter>;

    addCounter(amount?: number): Promise<void> | void;
}

```

# packages-modules/counter/server/src/interfaces/context.ts

```ts
import { ICounterService } from './counter-service';

export interface IContext extends IService {
    dataSources: IDataSources;
}

export interface IDataSources {
    counterCache: ICounterService;
}
export interface IService {
    counterMockService: ICounterService;
    // counterMockProxyService?: ICounterService;
}

```

# packages-modules/counter/server/src/graphqlTypes/schema.graphql

```graphql
scalar Date
scalar Time
scalar DateTime

```

# packages-modules/counter/server/src/graphqlTypes/resolvers.ts

```ts
/* eslint-disable no-unused-vars */
import { GraphQLDate, GraphQLTime, GraphQLDateTime } from 'graphql-iso-date';

export default (pubsub) => ({
    Date: GraphQLDate,
    Time: GraphQLTime,
    DateTime: GraphQLDateTime,
});

```

# packages-modules/counter/server/src/graphqlTypes/index.ts

```ts
// Components
import { Feature } from '@common-stack/server-core';
import createResolvers from './resolvers';

const graphqlFiles = (<any>require).context('', true, /\**.graphql?/);

const schema = graphqlFiles.keys().map((graphqlName) => {
    return graphqlFiles(graphqlName);
});

export default new Feature({ schema, createResolversFunc: createResolvers } as any);

```

# packages-modules/counter/server/src/dataloader/index.ts

```ts
export * from './counter-dataloader';

```

# packages-modules/counter/server/src/dataloader/counter-dataloader.ts

```ts
import { DataSource, DataSourceConfig } from 'apollo-datasource';
import { ApolloError } from 'apollo-server-errors';
import { InMemoryLRUCache } from 'apollo-server-caching';
// import { setupCaching } from './cache';
import { KeyValueCache } from 'apollo-server-caching';
import { IService, IContext, ICounterService } from '../interfaces';
import { setupCaching } from './cache';
import { Counter } from '../generated-models';

export interface CacheOptions {
    ttl?: number;
}

export class CounterDataSource extends DataSource<IService> implements ICounterService {
    private context!: IContext;

    private cacheCounterService: ICounterService;

    constructor() {
        super();
    }

    public counterQuery(): Counter | Promise<Counter> | PromiseLike<Counter> {
        return this.cacheCounterService.counterQuery();
    }

    public addCounter(amount?: number) {
        return this.cacheCounterService.addCounter();
    }

    public initialize(config: DataSourceConfig<IContext>) {
        this.context = config.context;
        if (!this.context.counterMockService) {
            throw new ApolloError('Missing TextFileService in the context!');
        }
        try {
            const cache = config.cache || new InMemoryLRUCache<string>();
            this.cacheCounterService = setupCaching({ counterService: config.context.counterMockService, cache });
        } catch (err) {
            throw new ApolloError(`Setting up cache in the FilesDataSource failed due to ${err}`);
        }
    }
}

```

# packages-modules/counter/server/src/dataloader/cache.ts

```ts
import * as DataLoader from 'dataloader';
import { KeyValueCache } from 'apollo-server-caching';
import { logger } from '@cdm-logger/server';
import { config } from '../config';
import { ICounterService } from '../interfaces';
import { Counter } from '../generated-models';

const KEY = 'COUNTER';
export const setupCaching = ({
    counterService,
    cache,
}: {
    counterService: ICounterService;
    cache: KeyValueCache<string>;
}) => {
    const loader = new DataLoader<string, Counter>(
        (args) => {
            return (counterService.counterQuery() as Promise<Counter>).then((data) => [data]);
        },
        { batch: false },
    );
    const cachedCounterService: ICounterService = {} as ICounterService;
    cachedCounterService.counterQuery = async () => {
        // stores as file:///tmp/tmp.txt
        const key = KEY;
        const cacheDoc = await cache.get(key);

        if (cacheDoc) {
            logger.trace('  document pulled from cache, [%s]', JSON.stringify(cacheDoc));
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return JSON.parse(cacheDoc);
        }
        try {
            const doc = await loader.load(KEY);

            // https://github.com/apollographql/apollo-server/tree/master/packages/apollo-server-caching#apollo-server-caching
            await cache.set(key, JSON.stringify(doc), { ttl: config.FILES_TTL });
            return doc;
        } catch (e) {
            console.log('error: ', e);
            return null;
        }
    };
    // it does syncing of counter
    cachedCounterService.addCounter = async () => {
        cache.delete(KEY);
        const newCounter = await loader.load(KEY);
        await cache.set(KEY, JSON.stringify(newCounter), { ttl: config.FILES_TTL });
    };

    return cachedCounterService;
};

```

# packages-modules/counter/server/src/containers/index.ts

```ts
export * from './containers';

```

# packages-modules/counter/server/src/containers/containers.ts

```ts
import { ContainerModule, interfaces } from 'inversify';
import { CounterMockService, CounterMockProxyService } from '../services';
import { TYPES } from '../constants';
import { ICounterService } from '../interfaces';

/**
 * Local services and exposed micro services to serve remote connections.
 * Operates within in the Gateway.
 *
 * @param settings Settings
 */
export const localCounterModule: (settings) => interfaces.ContainerModule = (settings) =>
    new ContainerModule((bind: interfaces.Bind) => {
        // bind<ICounterService>(TYPES.CounterMockService)
        //     .to(CounterMockService)
        //     .inSingletonScope()
        //     .whenTargetIsDefault();

        bind<ICounterService>(TYPES.CounterMockService)
            .to(CounterMockProxyService)
            .inSingletonScope()
            .whenTargetNamed('proxy');
    });

/**
 * Operates external to the Gateway. Usually a broker listen to calls and invoke this service
 * local to the micro container.
 *
 * @param settings Settings
 */
export const externalCounterModule: (settings) => interfaces.ContainerModule = (settings) =>
    new ContainerModule((bind: interfaces.Bind) => {
        bind<ICounterService>(TYPES.CounterMockService).to(CounterMockService).inSingletonScope();
    });

```

# packages-modules/counter/server/src/constants/index.ts

```ts
export * from './constants';

```

# packages-modules/counter/server/src/constants/constants.ts

```ts
export const NATS_MOLECULER_COUNTER_SERIVCE = 'NATS_MOLECULER_COUNTER_SERIVCE';

export enum CounterCommands {
    COUNTER_QUERY = 'COUNTER_QUERY',
    ADD_COUNTER = 'ADD_COUNTER',
}

export const TYPES = {
    CounterMockService: Symbol('CounterMockService'),
    CounterMockMicroservice: Symbol('CounterMockMicroservice'),
    CounterMockRemoteService: Symbol('CounterMockRemoteService'),
};

```

# packages-modules/counter/server/src/config/index.ts

```ts
export * from './config';

```

# packages-modules/counter/server/src/config/config.ts

```ts
import * as envalid from 'envalid';

const { str, num } = envalid;

export const config = envalid.cleanEnv(process.env, {
    FILES_TTL: num({ default: 3600, desc: 'TTL for files cache in Seconds' }),
});

```

# packages-modules/counter/mobile/src/utils/menu.ts

```ts
export const getFilteredRoutes = (accountPageStore, selectedRoutes) =>
    accountPageStore
        .map((item) => {
            if (selectedRoutes.indexOf(item.key) !== -1) {
                const { path } = item;
                return {
                    [path]: item,
                };
            }
            return null;
        })
        .filter((valid) => valid);

export const getFilteredTabs = (accountPageStore, selectedTabs) =>
    accountPageStore
        .map((item) => {
            if (selectedTabs.indexOf(item.key) !== -1) {
                const { component, ...rest } = item;
                return rest;
            }
        })
        .filter((valid) => valid);

```

# packages-modules/counter/mobile/src/utils/index.ts

```ts
export * from './menu';

```

# packages-modules/counter/mobile/src/connected-react-router/module.tsx

```tsx
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Feature } from '@common-stack/client-react';
import { connectedReactRouterCounter } from './redux';
import { filteredRoutes } from './compute';

export default new Feature({
    routeConfig: filteredRoutes,
    reducer: { connectedReactRouterCounter },
});

```

# packages-modules/counter/mobile/src/connected-react-router/index.ts

```ts
import { Feature } from '@common-stack/client-react';
import reactRouter from './module';

export default new Feature(reactRouter);

```

# packages-modules/counter/mobile/src/connected-react-router/compute.tsx

```tsx
/* eslint-disable @typescript-eslint/naming-convention */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { IMenuPosition } from '@common-stack/client-react';
import { Hello } from './components/Hello';
import { Counter } from './components/Counter';
import { getFilteredRoutes } from '../utils';

enum CONNECTED_REACT_ROUTER_ROUTES_TYPES {
    HOME = '/org',
    HELLO = '/org/hello',
    COUNTER = '/org/counter',
}

export const counterPageStore: any[] = [
    {
        exact: true,
        icon: 'export',
        name: 'Hello',
        component: Hello,
        position: IMenuPosition.MIDDLE,
        key: CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO,
        path: CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO,
    },
    {
        exact: true,
        icon: 'export',
        name: 'Counter',
        component: Counter,
        position: IMenuPosition.MIDDLE,
        key: CONNECTED_REACT_ROUTER_ROUTES_TYPES.COUNTER,
        path: CONNECTED_REACT_ROUTER_ROUTES_TYPES.COUNTER,
    },
];

const selectedRoutesAndMenus = [
    CONNECTED_REACT_ROUTER_ROUTES_TYPES.HOME,
    CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO,
    CONNECTED_REACT_ROUTER_ROUTES_TYPES.COUNTER,
];

// get routes
const filteredRoutes = getFilteredRoutes(counterPageStore, selectedRoutesAndMenus);

export { filteredRoutes };

```

# packages-modules/counter/mobile/src/connected-react-router/README.md

```md
# Connected React Router TypeScript Example

You can try changing counter value and editing some components. Components will be updated while preserving counter state.

In Hello link, you will see that the HelloChild component can access router state (URL path) without passing as props via its parent.


Reference:

https://github.com/supasate/connected-react-router/tree/master/examples/typescript
```

# packages-modules/counter/mobile/src/common/module.tsx

```tsx
import * as  React from 'react';

import { Feature } from '@common-stack/client-react';
import { filteredRoutes } from './compute';

export default new Feature({
  routeConfig: filteredRoutes,
});

```

# packages-modules/counter/mobile/src/common/index.ts

```ts
import { Feature } from '@common-stack/client-react';
import common from './module';

export default new Feature(common);

```

# packages-modules/counter/mobile/src/common/generated-models.ts

```ts
/* tslint:disable */

import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';

import gql from 'graphql-tag';
import { MyContext } from './interfaces/context';

export type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    AnyObject: any;
    JSON: any;
    JSONObject: any;
    Date: any;
    Time: any;
    DateTime: any;
};

export type ClientCounter = {
    counter?: Maybe<Scalars['Int']>;
};

export type Counter = {
    amount: Scalars['Int'];
};

export type FieldError = {
    field: Scalars['String'];
    message: Scalars['String'];
};

export type Mutation = {
    dummy?: Maybe<Scalars['Int']>;
    addCounterState?: Maybe<ClientCounter>;
    addCounter?: Maybe<Counter>;
};

export type MutationAddCounterStateArgs = {
    amount: Scalars['Int'];
};

export type MutationAddCounterArgs = {
    amount?: Maybe<Scalars['Int']>;
};

export type Node = {
    id: Scalars['ID'];
};

export type Query = {
    dummy?: Maybe<Scalars['Int']>;
    counterState?: Maybe<ClientCounter>;
    counter?: Maybe<Counter>;
};

export type Subscription = {
    dummy?: Maybe<Scalars['Int']>;
    counterUpdated?: Maybe<Counter>;
};

export type AddCounterStateMutationVariables = {
    amount: Scalars['Int'];
};

export type AddCounterStateMutation = { __typename?: 'Mutation' } & {
    addCounterState: Maybe<{ __typename?: 'ClientCounter' } & Pick<ClientCounter, 'counter'>>;
};

export type AddCounterMutationVariables = {
    amount: Scalars['Int'];
};

export type AddCounterMutation = { __typename?: 'Mutation' } & {
    addCounter: Maybe<{ __typename?: 'Counter' } & Pick<Counter, 'amount'>>;
};

export type CounterStateQueryVariables = {};

export type CounterStateQuery = { __typename?: 'Query' } & {
    counterState: Maybe<{ __typename?: 'ClientCounter' } & Pick<ClientCounter, 'counter'>>;
};

export type CounterQueryQueryVariables = {};

export type CounterQueryQuery = { __typename?: 'Query' } & {
    counter: Maybe<{ __typename?: 'Counter' } & Pick<Counter, 'amount'>>;
};

export type OnCounterUpdatedSubscriptionVariables = {};

export type OnCounterUpdatedSubscription = { __typename?: 'Subscription' } & {
    counterUpdated: Maybe<{ __typename?: 'Counter' } & Pick<Counter, 'amount'>>;
};

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => Promise<TResult> | TResult;

export type StitchingResolver<TResult, TParent, TContext, TArgs> = {
    fragment: string;
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ResolverFn<TResult, TParent, TContext, TArgs>
    | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs>;
    resolve?: SubscriptionResolveFn<TResult, TParent, TContext, TArgs>;
}

export type SubscriptionResolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ((...args: any[]) => SubscriptionResolverObject<TResult, TParent, TContext, TArgs>)
    | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
    parent: TParent,
    context: TContext,
    info: GraphQLResolveInfo,
) => Maybe<TTypes>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
    next: NextResolverFn<TResult>,
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
    Query: {};
    Int: Scalars['Int'];
    ClientCounter: ClientCounter;
    Counter: Counter;
    Mutation: {};
    Subscription: {};
    String: Scalars['String'];
    Boolean: Scalars['Boolean'];
    AnyObject: Scalars['AnyObject'];
    JSON: Scalars['JSON'];
    JSONObject: Scalars['JSONObject'];
    FieldError: FieldError;
    Node: Node;
    ID: Scalars['ID'];
    Date: Scalars['Date'];
    Time: Scalars['Time'];
    DateTime: Scalars['DateTime'];
};

export interface AnyObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['AnyObject'], any> {
    name: 'AnyObject';
}

export type ClientCounterResolvers<ContextType = MyContext, ParentType = ResolversTypes['ClientCounter']> = {
    counter?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
};

export type CounterResolvers<ContextType = MyContext, ParentType = ResolversTypes['Counter']> = {
    amount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
};

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
    name: 'Date';
}

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
    name: 'DateTime';
}

export type FieldErrorResolvers<ContextType = MyContext, ParentType = ResolversTypes['FieldError']> = {
    field?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
    name: 'JSON';
}

export interface JsonObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSONObject'], any> {
    name: 'JSONObject';
}

export type MutationResolvers<ContextType = MyContext, ParentType = ResolversTypes['Mutation']> = {
    dummy?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    addCounterState?: Resolver<
        Maybe<ResolversTypes['ClientCounter']>,
        ParentType,
        ContextType,
        MutationAddCounterStateArgs
    >;
    addCounter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType, MutationAddCounterArgs>;
};

export type NodeResolvers<ContextType = MyContext, ParentType = ResolversTypes['Node']> = {
    __resolveType: TypeResolveFn<null, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type QueryResolvers<ContextType = MyContext, ParentType = ResolversTypes['Query']> = {
    dummy?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    counterState?: Resolver<Maybe<ResolversTypes['ClientCounter']>, ParentType, ContextType>;
    counter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
};

export type SubscriptionResolvers<ContextType = MyContext, ParentType = ResolversTypes['Subscription']> = {
    dummy?: SubscriptionResolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    counterUpdated?: SubscriptionResolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
};

export interface TimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Time'], any> {
    name: 'Time';
}

export type Resolvers<ContextType = MyContext> = {
    AnyObject?: GraphQLScalarType;
    ClientCounter?: ClientCounterResolvers<ContextType>;
    Counter?: CounterResolvers<ContextType>;
    Date?: GraphQLScalarType;
    DateTime?: GraphQLScalarType;
    FieldError?: FieldErrorResolvers<ContextType>;
    JSON?: GraphQLScalarType;
    JSONObject?: GraphQLScalarType;
    Mutation?: MutationResolvers<ContextType>;
    Node?: NodeResolvers;
    Query?: QueryResolvers<ContextType>;
    Subscription?: SubscriptionResolvers<ContextType>;
    Time?: GraphQLScalarType;
};

/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
 */
export type IResolvers<ContextType = MyContext> = Resolvers<ContextType>;
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export const AddCounterStateDocument = gql`
    mutation addCounterState($amount: Int!) {
        addCounterState(amount: $amount) @client {
            counter
        }
    }
`;
export const AddCounterDocument = gql`
    mutation addCounter($amount: Int!) {
        addCounter(amount: $amount) {
            amount
        }
    }
`;
export const CounterStateDocument = gql`
    query CounterState {
        counterState @client {
            counter
        }
    }
`;
export const CounterQueryDocument = gql`
    query counterQuery {
        counter {
            amount
        }
    }
`;
export const OnCounterUpdatedDocument = gql`
    subscription onCounterUpdated {
        counterUpdated {
            amount
        }
    }
`;

```

# packages-modules/counter/mobile/src/common/compute.tsx

```tsx
import * as React from 'react';
import { IMenuPosition } from '@common-stack/client-react';

import { Home } from '../common/components/Home';
import { getFilteredRoutes } from '../utils';

export const commonPageStore: any[] = [
    {
        path: '/',
        key: 'home',
        exact: true,
        name: 'Home',
        component: Home,
        position: IMenuPosition.MIDDLE,
    },
];

const selectedRoutesAndMenus = ['home'];


// get routes
const filteredRoutes = getFilteredRoutes(commonPageStore, selectedRoutesAndMenus);

export { filteredRoutes };

```

# portable-devices/mobile/src/components/layout/root-navigation.tsx

```tsx
import React, { useRef } from 'react';

export const navigationRefs = React.createRef<any>();

export function navigate(name: any) {
    navigationRefs.current?.navigate(name);
}

```

# portable-devices/mobile/src/components/layout/module.ts

```ts
/* eslint-disable prettier/prettier */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { Feature } from '@common-stack/client-react';
import NativeBaseSample from './NativeBaseSample'
import Layout from './Layout';

export default new Feature({
  routeConfig: [
    {
      '/': {
        exact: true,
        component: NativeBaseSample,
      } as any,
    },
    // {
    //   '/org': {
    //     exact: false,
    //     component: Layout,
    //     key: 'layout',
    //   } as any,
    // },
  ],
});

```

# portable-devices/mobile/src/components/layout/SideBar.tsx

```tsx
import React, { useState } from 'react';
import { Container, View, Text, List, ListItem, Left, Right, Icon, Drawer } from 'native-base';
import { Link } from 'react-router-native';

const SideBar = ({ routes, matchUrl }: any) => {
    const [icon, setIcon] = useState('chevron-down-outline');
    const [isToggle, setToggle] = useState(false);

    const toggle = () => {
        if (isToggle) {
            setIcon('chevron-down-outline');
            setToggle(false);
        } else {
            setIcon('chevron-up-outline');
            setToggle(true)
        }
    }

    const isMenuExist = routes.length > 0;

    return (
        <Container style={{ backgroundColor: '#1f1f1f' }}>
            {isMenuExist && routes.map(menu => (
                menu.routes ? (
                    <List>
                        <ListItem onPress={() => toggle()}>
                            <Left>
                                <Icon style={{ color: isToggle ? '#fff' : '#a1a1a1' }} name="document-outline" />
                                <Text style={{ color: isToggle ? '#fff' : '#a1a1a1' }}>{menu.name}</Text>
                            </Left>
                            <Right>
                                <Icon name={icon} />
                            </Right>
                        </ListItem>
                        {isToggle && (menu.routes.map(subMenu => (
                            <List>
                                <ListItem>
                                    <Left>
                                        <Link to={subMenu.path} underlayColor="#f0f4f7">
                                            <Text style={{ color: '#a1a1a1' }}>{subMenu.name}</Text>
                                        </Link>
                                    </Left >
                                </ListItem >
                            </List >
                        )))}
                    </List>
                ) :
                    (<List>
                        <ListItem>
                            <Left>
                                <Link to={menu.path} underlayColor="#f0f4f7">
                                    <Text style={{ color: '#a1a1a1' }}>{menu.name}</Text>
                                </Link>
                            </Left >
                        </ListItem >
                    </List >)
            ))}
        </Container >
    )
}

export default SideBar;

```

# portable-devices/mobile/src/components/layout/NativeBaseSample.tsx

```tsx
import React from 'react';
import {
  Text,
  Link,
  HStack,
  Center,
  Heading,
  Switch,
  useColorMode,
  NativeBaseProvider,
  extendTheme,
  VStack,
  Code,
} from 'native-base';
import NativeBaseIcon from './NativeBaseIcon';

// Define the config
const config = {
  useSystemColorMode: false,
  initialColorMode: "dark",
};

// extend the theme
export const theme = extendTheme({ config });

export default function App() {
  return (
    <NativeBaseProvider>
      <Center
        _dark={{ bg: "blueGray.900" }}
        _light={{ bg: "blueGray.50" }}
        px={4}
        flex={1}
      >
        <VStack space={5} alignItems="center">
          <NativeBaseIcon />
          <Heading size="lg">Welcome to NativeBase</Heading>
          <HStack space={2} alignItems="center">
            <Text>Edit</Text>
            <Code>App.tsx</Code>
            <Text>and save to reload.</Text>
          </HStack>
          <Link href="https://docs.nativebase.io" isExternal>
            <Text color="primary.500" underline fontSize={"xl"}>
              Learn NativeBase
            </Text>
          </Link>
          <ToggleDarkMode />
        </VStack>
      </Center>
    </NativeBaseProvider>
  );
}

// Color Switch Component
function ToggleDarkMode() {
  const { colorMode, toggleColorMode } = useColorMode();
  return (
    <HStack space={2} alignItems="center">
      <Text>Dark</Text>
      <Switch
        isChecked={colorMode === "light" ? true : false}
        onToggle={toggleColorMode}
        aria-label={
          colorMode === "light" ? "switch to dark mode" : "switch to light mode"
        }
      />
      <Text>Light</Text>
    </HStack>
  );
}

```

# portable-devices/mobile/src/components/layout/NativeBaseIcon.tsx

```tsx
import * as React from 'react';
import { Icon } from 'native-base';
import { G, Path } from 'react-native-svg';
const NativeBaseIcon = () => {
  return (
    <Icon size="220px" viewBox="0 0 602.339 681.729">
      <G
        id="Group_403"
        data-name="Group 403"
        transform="translate(14575 1918.542)"
      >
        <Path
          id="Path_1"
          data-name="Path 1"
          d="M488.722,0A45.161,45.161,0,0,1,527.83,22.576L675.676,278.584a45.162,45.162,0,0,1,0,45.171L527.83,579.763a45.162,45.162,0,0,1-39.108,22.576H193.008A45.162,45.162,0,0,1,153.9,579.763L6.053,323.755a45.162,45.162,0,0,1,0-45.171L153.9,22.576A45.162,45.162,0,0,1,193.008,0Z"
          transform="translate(-13972.661 -1918.542) rotate(90)"
          fill="#356290"
        />
        <Path
          id="Path_252"
          data-name="Path 252"
          d="M401.1,0A60.816,60.816,0,0,1,453.77,30.405L567.2,226.844a60.816,60.816,0,0,1,0,60.82L453.77,484.1A60.816,60.816,0,0,1,401.1,514.509H174.241A60.816,60.816,0,0,1,121.575,484.1L8.149,287.665a60.816,60.816,0,0,1,0-60.82L121.575,30.405A60.816,60.816,0,0,1,174.241,0Z"
          transform="translate(-14016.576 -1865.281) rotate(90)"
          fill="#1784b2"
        />
        <Path
          id="Path_251"
          data-name="Path 251"
          d="M345.81,0a36.573,36.573,0,0,1,31.674,18.288L480.566,196.856a36.573,36.573,0,0,1,0,36.569L377.484,411.993a36.573,36.573,0,0,1-31.674,18.288H139.655a36.572,36.572,0,0,1-31.674-18.288L4.9,233.425a36.573,36.573,0,0,1,0-36.569L107.981,18.288A36.573,36.573,0,0,1,139.655,0Z"
          transform="translate(-14058.69 -1820.41) rotate(90)"
          fill="#50bfc3"
        />
        <Path
          id="_x3C__x2F__x3E_"
          d="M187.066,335.455V297.993l-65.272-21.949,65.272-22.523V216.059L81,259.5v32.521Zm38.726,29.3L286.123,174H256.7l-60.33,190.759Zm72.052-29.3,106.066-43.783V259.267L297.844,216.059V254.44l59.3,23.328-59.3,19.421Z"
          transform="translate(-14516.286 -1846.988)"
          fill="#fff"
        />
      </G>
    </Icon>
  );
};

export default NativeBaseIcon;

```

# portable-devices/mobile/src/components/layout/Layout.tsx

```tsx
import React, { useRef } from 'react';
import { View } from 'react-native';
import { connect } from 'react-redux';
import MainHeader from './Header';
import { DrawerRoute } from './Drawer';

const Layout = (props: any, route: any) => {
  const drawerRef = useRef();
  return (
    <View style={{ flex: 1 }}>
      <MainHeader title="CDMBase LLC" drawerRef={drawerRef} />
      <DrawerRoute match={props.match} routes={route.routes || []} drawerRef={drawerRef}/>
    </View>
  );
};

export const ProLayout = connect((state: any) => {
  return {
    settings: state.settings,
    location: state.router.location,
  };
})(Layout);

export default Layout;

```

# portable-devices/mobile/src/components/layout/Header.tsx

```tsx
import React, { useState } from 'react';
import { Header, Left, Right, Body, Text, Icon } from 'native-base';

const MainHeader = (props: any) => {
  const[isToggle, setIsToggle] = useState(false);

  const toggle = () => {
    if(isToggle){
      props.drawerRef?.current?._root?.close();
    } else{
      props.drawerRef?.current?._root?.open();
    }
    setIsToggle(!isToggle)
  }

  return (
    <Header style={{ backgroundColor: '#1f1f1f' }}>
      <Left>
        <Icon style={{ color: '#fff' }} name="menu" onPress={() => toggle()} />
      </Left>
      <Body>
        <Text style={{ color: '#fff' }}>{props.title}</Text>
      </Body>
    </Header>
  );
};

export default MainHeader;

```

# portable-devices/mobile/src/components/layout/Drawer.tsx

```tsx
import * as React from 'react';
import { Drawer } from 'native-base';
import { Route } from 'react-router-native';
import SideBar from './SideBar';

export const DrawerRoute = ({ match, drawerRef, routes }: any) => {
  const onClose = () => {
    console.log("close")
    drawerRef.current._root.close()
  }

  return (
    <Drawer 
    ref={drawerRef} 
    content={
      <SideBar matchUrl={match.url} routes={routes} />
    }
    onClose={onClose}
    >
      {routes.map((route: any) => (
        <Route key={route.path} exact={route.exact} path={route.path} component={route.component} />
      ))}
    </Drawer>
  )
};

```

# portable-devices/mobile/src/components/__tests__/StyledText-test.js

```js
import * as React from 'react';
import renderer from 'react-test-renderer';

import { MonoText } from '../StyledText';

it(`renders correctly`, () => {
    const tree = renderer.create(<MonoText>Snapshot test!</MonoText>).toJSON();

    expect(tree).toMatchSnapshot();
});

```

# portable-devices/mobile/src/assets/images/splash.png

This is a binary file of the type: Image

# portable-devices/mobile/src/assets/images/icon.png

This is a binary file of the type: Image

# portable-devices/mobile/src/assets/images/favicon.png

This is a binary file of the type: Image

# portable-devices/mobile/src/assets/images/adaptive-icon.png

This is a binary file of the type: Image

# portable-devices/mobile/src/assets/fonts/SpaceMono-Regular.ttf

This is a binary file of the type: Binary

# packages-modules/counter/electron/src/epics/index.ts

```ts
export * from './count-tray-updater';

```

# packages-modules/counter/electron/src/epics/count-tray-updater.ts

```ts
/* eslint-disable @typescript-eslint/no-unused-vars */
import { ofType } from 'redux-observable';
import { Observable, of } from 'rxjs';
import { distinctUntilChanged, map, tap, exhaustMap, pluck, catchError, filter } from 'rxjs/operators';
import { ElectronTypes } from '@common-stack/client-core';
import { CONNECTED_REACT_ROUTER_ACTION_TYPES } from '@sample-stack/counter-module-browser/lib/connected-react-router/constants/action-types';

export const onCountChangedEpic = (
    action$: Observable<any>,
    state$: Observable<any>,
    { container, routes }: { container: any; routes },
) =>
    action$.pipe(
        ofType(CONNECTED_REACT_ROUTER_ACTION_TYPES.INCREMENT),
        exhaustMap(() =>
            state$.pipe(
                pluck('connectedReactRouterCounter'),
                distinctUntilChanged(),
                tap((count) => {
                    const st = container.get(ElectronTypes.TrayWindow);
                    st.updateTitle(count.toString());
                }),
                ofType('TRAY_UPDATED'),
            ),
        ),
    );

```

# packages-modules/counter/browser/src/utils/menu.ts

```ts
export const getFilteredMenus = (accountPageStore, selectedMenu) =>
    accountPageStore
        .map((item) => {
            if (selectedMenu.indexOf(item.key) !== -1) {
                const { path, component, ...rest } = item;
                return {
                    [path]: { name: rest.tab, ...rest },
                };
            }
        })
        .filter((valid) => valid);

export const getFilteredRoutes = (accountPageStore, selectedRoutes) =>
    accountPageStore
        .map((item) => {
            if (selectedRoutes.indexOf(item.key) !== -1) {
                const { path } = item;
                return {
                    [path]: item,
                };
            }
            return null;
        })
        .filter((valid) => valid);

export const getFilteredTabs = (accountPageStore, selectedTabs) =>
    accountPageStore
        .map((item) => {
            if (selectedTabs.indexOf(item.key) !== -1) {
                const { component, ...rest } = item;
                return rest;
            }
        })
        .filter((valid) => valid);

```

# packages-modules/counter/browser/src/utils/index.ts

```ts
export * from './menu';

```

# packages-modules/counter/browser/src/fela/theme.ts

```ts
import { Theme } from './interfaces';

export const theme: Theme = {
    color: {
        primary: 'lightblue',
        secondary: 'red',
        additional: 'lightgreen',
    },
};

```

# packages-modules/counter/browser/src/fela/module.tsx

```tsx
import * as React from 'react';
import { Feature } from '@common-stack/client-react';
import { filteredMenus, filteredRoutes } from './compute';



export default new Feature({
    menuConfig: filteredMenus,
    routeConfig: filteredRoutes,
});

```

# packages-modules/counter/browser/src/fela/index.ts

```ts
import { Feature } from '@common-stack/client-react';
import fela from './module';

export default new Feature(fela);

```

# packages-modules/counter/browser/src/fela/compute.tsx

```tsx
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import * as React from 'react';
import { IMenuPosition } from '@common-stack/client-react';
import { getFilteredMenus, getFilteredRoutes } from '../utils';
import { ComplexWithTheme } from './components/CompledWithTheme';



export const felaPageStore: any[] = [
    {
        component: ComplexWithTheme,
        tab: 'Fela Styling',
        key: 'fela',
        position: IMenuPosition.MIDDLE,
        name: 'Fela Styling',
        path: '/fela',
    },
];

const selectedRoutesAndMenus = ['fela'];

// get menus
const filteredMenus = getFilteredMenus(felaPageStore, selectedRoutesAndMenus);

// get routes
const filteredRoutes = getFilteredRoutes(felaPageStore, selectedRoutesAndMenus);

export { filteredMenus, filteredRoutes };

```

# packages-modules/counter/browser/src/fela/README.md

```md
<h1><img alt="Fela" src="docs/res/logo.png" width="203"/></h1>

Fela is a small, high-performant and framework-agnostic toolbelt to handle state-driven styling in JavaScript.<br>
It is dynamic by design and renders your styles depending on your application state.

Code Reference:

https://github.com/rofrischmann/fela/tree/master/examples/example-typescript
```

# packages-modules/counter/browser/src/connected-react-router/module.tsx

```tsx
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import * as React from 'react';
import { Feature } from '@common-stack/client-react';
import { Counter } from './components/Counter';
import NavBar from './components/NavBar';
import { connectedReactRouterCounter } from './redux';
import { filteredRoutes, filteredMenus } from './compute';

export default new Feature({
    navItem: <Counter />, // used in electron
    menuConfig: filteredMenus,
    routeConfig: filteredRoutes,
    reducer: { connectedReactRouterCounter },
});

```

# packages-modules/counter/browser/src/connected-react-router/index.ts

```ts
import { Feature } from '@common-stack/client-react';
import repository from './module';
import { Counter } from './components/Counter';

export { Counter };
export default new Feature(repository);

```

# packages-modules/counter/browser/src/connected-react-router/index.electron.ts

```ts
export { ElectronTrayModule } from './electron-module';

```

# packages-modules/counter/browser/src/connected-react-router/electron-module.tsx

```tsx
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Feature } from '@common-stack/client-react';
import { IMenuPosition, IRoute } from '@common-stack/client-react';
import { Counter } from './components/Counter';
import { connectedReactRouterCounter } from './redux';
import { CONNECTED_REACT_ROUTER_ROUTES_TYPES } from './constants';
import { getFilteredRoutes } from '../utils';


export const counterPageStore: IRoute[] = [
    {
        exact: true,
        icon: 'export',
        name: 'Counter',
        component: Counter,
        position: IMenuPosition.MIDDLE,
        key: CONNECTED_REACT_ROUTER_ROUTES_TYPES.ROOT,
        path: CONNECTED_REACT_ROUTER_ROUTES_TYPES.ROOT,
    },
];

const selectedRoutesAndMenus = [
    CONNECTED_REACT_ROUTER_ROUTES_TYPES.ROOT,
];
// get routes
const filteredRoutes = getFilteredRoutes(counterPageStore, selectedRoutesAndMenus);

export const ElectronTrayModule = new Feature({
    routeConfig: filteredRoutes,
    reducer: { connectedReactRouterCounter },
});


```

# packages-modules/counter/browser/src/connected-react-router/compute.tsx

```tsx
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import * as React from 'react';
import { IMenuPosition, IRoute } from '@common-stack/client-react';

import { Hello } from './components/Hello';
import { Counter } from './components/Counter';
import { Dashboard } from '../common/components/Dashboard';
import { getFilteredMenus, getFilteredRoutes } from '../utils';
import { CONNECTED_REACT_ROUTER_ROUTES_TYPES } from './constants';

export const counterPageStore: IRoute[] = [
    {
        exact: false,
        icon: 'export',
        component: Dashboard,
        position: IMenuPosition.MIDDLE,
        name: 'Connected React Router',
        key: CONNECTED_REACT_ROUTER_ROUTES_TYPES.HOME,
        path: CONNECTED_REACT_ROUTER_ROUTES_TYPES.HOME,
    },
    {
        exact: true,
        icon: 'export',
        name: 'Hello',
        component: Hello,
        position: IMenuPosition.MIDDLE,
        key: CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO,
        path: CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO,
    },
    {
        exact: true,
        icon: 'export',
        name: 'Counter',
        component: Counter,
        position: IMenuPosition.MIDDLE,
        key: CONNECTED_REACT_ROUTER_ROUTES_TYPES.COUNTER,
        path: CONNECTED_REACT_ROUTER_ROUTES_TYPES.COUNTER,
    },
];

const selectedRoutesAndMenus = [
    CONNECTED_REACT_ROUTER_ROUTES_TYPES.HOME,
    CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO,
    CONNECTED_REACT_ROUTER_ROUTES_TYPES.COUNTER,
];

// get routes
const filteredRoutes = getFilteredRoutes(counterPageStore, selectedRoutesAndMenus);

// get menus
const filteredMenus = getFilteredMenus(counterPageStore, selectedRoutesAndMenus);

export { filteredRoutes, filteredMenus };

```

# packages-modules/counter/browser/src/connected-react-router/README.md

```md
# Connected React Router TypeScript Example

You can try changing counter value and editing some components. Components will be updated while preserving counter state.

In Hello link, you will see that the HelloChild component can access router state (URL path) without passing as props via its parent.


Reference:

https://github.com/supasate/connected-react-router/tree/master/examples/typescript
```

# packages-modules/counter/browser/src/common/module.tsx

```tsx
import * as  React from 'react';

import { Feature } from '@common-stack/client-react';
import { filteredMenus, filteredRoutes } from './compute';

export default new Feature({
  menuConfig: filteredMenus,
  routeConfig: filteredRoutes,
});

```

# packages-modules/counter/browser/src/common/index.ts

```ts
import { Feature } from '@common-stack/client-react';
import common from './module';

export default new Feature(common);

```

# packages-modules/counter/browser/src/common/generated-models.ts

```ts
/* tslint:disable */

import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';

import gql from 'graphql-tag';
import { MyContext } from './interfaces/context';

export type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    AnyObject: any;
    JSON: any;
    JSONObject: any;
    Date: any;
    Time: any;
    DateTime: any;
};

export type ClientCounter = {
    counter?: Maybe<Scalars['Int']>;
};

export type Counter = {
    amount: Scalars['Int'];
};

export type FieldError = {
    field: Scalars['String'];
    message: Scalars['String'];
};

export type Mutation = {
    dummy?: Maybe<Scalars['Int']>;
    addCounterState?: Maybe<ClientCounter>;
    addCounter?: Maybe<Counter>;
};

export type MutationAddCounterStateArgs = {
    amount: Scalars['Int'];
};

export type MutationAddCounterArgs = {
    amount?: Maybe<Scalars['Int']>;
};

export type Node = {
    id: Scalars['ID'];
};

export type Query = {
    dummy?: Maybe<Scalars['Int']>;
    counterState?: Maybe<ClientCounter>;
    counter?: Maybe<Counter>;
};

export type Subscription = {
    dummy?: Maybe<Scalars['Int']>;
    counterUpdated?: Maybe<Counter>;
};

export type AddCounterStateMutationVariables = {
    amount: Scalars['Int'];
};

export type AddCounterStateMutation = { __typename?: 'Mutation' } & {
    addCounterState: Maybe<{ __typename?: 'ClientCounter' } & Pick<ClientCounter, 'counter'>>;
};

export type AddCounterMutationVariables = {
    amount: Scalars['Int'];
};

export type AddCounterMutation = { __typename?: 'Mutation' } & {
    addCounter: Maybe<{ __typename?: 'Counter' } & Pick<Counter, 'amount'>>;
};

export type CounterStateQueryVariables = {};

export type CounterStateQuery = { __typename?: 'Query' } & {
    counterState: Maybe<{ __typename?: 'ClientCounter' } & Pick<ClientCounter, 'counter'>>;
};

export type CounterQueryQueryVariables = {};

export type CounterQueryQuery = { __typename?: 'Query' } & {
    counter: Maybe<{ __typename?: 'Counter' } & Pick<Counter, 'amount'>>;
};

export type OnCounterUpdatedSubscriptionVariables = {};

export type OnCounterUpdatedSubscription = { __typename?: 'Subscription' } & {
    counterUpdated: Maybe<{ __typename?: 'Counter' } & Pick<Counter, 'amount'>>;
};

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => Promise<TResult> | TResult;

export type StitchingResolver<TResult, TParent, TContext, TArgs> = {
    fragment: string;
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ResolverFn<TResult, TParent, TContext, TArgs>
    | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs>;
    resolve?: SubscriptionResolveFn<TResult, TParent, TContext, TArgs>;
}

export type SubscriptionResolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
    | ((...args: any[]) => SubscriptionResolverObject<TResult, TParent, TContext, TArgs>)
    | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
    parent: TParent,
    context: TContext,
    info: GraphQLResolveInfo,
) => Maybe<TTypes>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
    next: NextResolverFn<TResult>,
    parent: TParent,
    args: TArgs,
    context: TContext,
    info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
    Query: {};
    Int: Scalars['Int'];
    ClientCounter: ClientCounter;
    Counter: Counter;
    Mutation: {};
    Subscription: {};
    String: Scalars['String'];
    Boolean: Scalars['Boolean'];
    AnyObject: Scalars['AnyObject'];
    JSON: Scalars['JSON'];
    JSONObject: Scalars['JSONObject'];
    FieldError: FieldError;
    Node: Node;
    ID: Scalars['ID'];
    Date: Scalars['Date'];
    Time: Scalars['Time'];
    DateTime: Scalars['DateTime'];
};

export interface AnyObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['AnyObject'], any> {
    name: 'AnyObject';
}

export type ClientCounterResolvers<ContextType = MyContext, ParentType = ResolversTypes['ClientCounter']> = {
    counter?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
};

export type CounterResolvers<ContextType = MyContext, ParentType = ResolversTypes['Counter']> = {
    amount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
};

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
    name: 'Date';
}

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
    name: 'DateTime';
}

export type FieldErrorResolvers<ContextType = MyContext, ParentType = ResolversTypes['FieldError']> = {
    field?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
    name: 'JSON';
}

export interface JsonObjectScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSONObject'], any> {
    name: 'JSONObject';
}

export type MutationResolvers<ContextType = MyContext, ParentType = ResolversTypes['Mutation']> = {
    dummy?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    addCounterState?: Resolver<
        Maybe<ResolversTypes['ClientCounter']>,
        ParentType,
        ContextType,
        MutationAddCounterStateArgs
    >;
    addCounter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType, MutationAddCounterArgs>;
};

export type NodeResolvers<ContextType = MyContext, ParentType = ResolversTypes['Node']> = {
    __resolveType: TypeResolveFn<null, ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type QueryResolvers<ContextType = MyContext, ParentType = ResolversTypes['Query']> = {
    dummy?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    counterState?: Resolver<Maybe<ResolversTypes['ClientCounter']>, ParentType, ContextType>;
    counter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
};

export type SubscriptionResolvers<ContextType = MyContext, ParentType = ResolversTypes['Subscription']> = {
    dummy?: SubscriptionResolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    counterUpdated?: SubscriptionResolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
};

export interface TimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Time'], any> {
    name: 'Time';
}

export type Resolvers<ContextType = MyContext> = {
    AnyObject?: GraphQLScalarType;
    ClientCounter?: ClientCounterResolvers<ContextType>;
    Counter?: CounterResolvers<ContextType>;
    Date?: GraphQLScalarType;
    DateTime?: GraphQLScalarType;
    FieldError?: FieldErrorResolvers<ContextType>;
    JSON?: GraphQLScalarType;
    JSONObject?: GraphQLScalarType;
    Mutation?: MutationResolvers<ContextType>;
    Node?: NodeResolvers;
    Query?: QueryResolvers<ContextType>;
    Subscription?: SubscriptionResolvers<ContextType>;
    Time?: GraphQLScalarType;
};

/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
 */
export type IResolvers<ContextType = MyContext> = Resolvers<ContextType>;
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export const AddCounterStateDocument = gql`
    mutation addCounterState($amount: Int!) {
        addCounterState(amount: $amount) @client {
            counter
        }
    }
`;
export const AddCounterDocument = gql`
    mutation addCounter($amount: Int!) {
        addCounter(amount: $amount) {
            amount
        }
    }
`;
export const CounterStateDocument = gql`
    query CounterState {
        counterState @client {
            counter
        }
    }
`;
export const CounterQueryDocument = gql`
    query counterQuery {
        counter {
            amount
        }
    }
`;
export const OnCounterUpdatedDocument = gql`
    subscription onCounterUpdated {
        counterUpdated {
            amount
        }
    }
`;

```

# packages-modules/counter/browser/src/common/compute.tsx

```tsx
import * as React from 'react';
import { IMenuPosition } from '@common-stack/client-react';

import { Home } from '../common/components/Home';
import { getFilteredMenus, getFilteredRoutes } from '../utils';

export const commonPageStore: any[] = [
    {
        path: '/',
        key: 'home',
        exact: true,
        name: 'Home',
        component: Home,
        position: IMenuPosition.MIDDLE,
    },
];

const selectedRoutesAndMenus = ['home'];

// get menus
const filteredMenus = getFilteredMenus(commonPageStore, selectedRoutesAndMenus);

// get routes
const filteredRoutes = getFilteredRoutes(commonPageStore, selectedRoutesAndMenus);

export { filteredMenus, filteredRoutes };

```

# packages-modules/counter/browser/src/apollo-server-n-client/module.tsx

```tsx
import { reducers } from './redux';
import { resolvers, stateDefault } from './graphql';

import { Feature } from '@common-stack/client-react';
import { filteredMenus, filteredRoutes } from './compute';

export default new Feature({
  menuConfig: filteredMenus,
  routeConfig: filteredRoutes,
  reducer: { counter: reducers },
  clientStateParams: { resolvers, defaults: [stateDefault] },
});

```

# packages-modules/counter/browser/src/apollo-server-n-client/index.ts

```ts
import { Feature } from '@common-stack/client-react';
import repository from './module';

export default new Feature(repository);

```

# packages-modules/counter/browser/src/apollo-server-n-client/generated-model.tsx

```tsx
/* tslint:disable */
import * as SchemaTypes from '../generated-models';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
import * as React from 'react';
import * as ApolloReactComponents from '@apollo/client/react/components';
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
const defaultOptions =  {}

export const AddCounterStateDocument = gql`
    mutation addCounterState($amount: Int!) {
  addCounterState(amount: $amount) @client {
    counter
  }
}
    `;
export type AddCounterStateMutationFn = Apollo.MutationFunction<SchemaTypes.AddCounterStateMutation, SchemaTypes.AddCounterStateMutationVariables>;
export type AddCounterStateComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<SchemaTypes.AddCounterStateMutation, SchemaTypes.AddCounterStateMutationVariables>, 'mutation'>;

    export const AddCounterStateComponent = (props: AddCounterStateComponentProps) => (
      <ApolloReactComponents.Mutation<SchemaTypes.AddCounterStateMutation, SchemaTypes.AddCounterStateMutationVariables> mutation={AddCounterStateDocument} {...props} />
    );
    

/**
 * __useAddCounterStateMutation__
 *
 * To run a mutation, you first call `useAddCounterStateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCounterStateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCounterStateMutation, { data, loading, error }] = useAddCounterStateMutation({
 *   variables: {
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useAddCounterStateMutation(baseOptions?: Apollo.MutationHookOptions<SchemaTypes.AddCounterStateMutation, SchemaTypes.AddCounterStateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SchemaTypes.AddCounterStateMutation, SchemaTypes.AddCounterStateMutationVariables>(AddCounterStateDocument, options);
      }
export type AddCounterStateMutationHookResult = ReturnType<typeof useAddCounterStateMutation>;
export type AddCounterStateMutationResult = Apollo.MutationResult<SchemaTypes.AddCounterStateMutation>;
export type AddCounterStateMutationOptions = Apollo.BaseMutationOptions<SchemaTypes.AddCounterStateMutation, SchemaTypes.AddCounterStateMutationVariables>;
export const AddCounterDocument = gql`
    mutation addCounter($amount: Int!) {
  addCounter(amount: $amount) {
    amount
  }
}
    `;
export type AddCounterMutationFn = Apollo.MutationFunction<SchemaTypes.AddCounterMutation, SchemaTypes.AddCounterMutationVariables>;
export type AddCounterComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<SchemaTypes.AddCounterMutation, SchemaTypes.AddCounterMutationVariables>, 'mutation'>;

    export const AddCounterComponent = (props: AddCounterComponentProps) => (
      <ApolloReactComponents.Mutation<SchemaTypes.AddCounterMutation, SchemaTypes.AddCounterMutationVariables> mutation={AddCounterDocument} {...props} />
    );
    

/**
 * __useAddCounterMutation__
 *
 * To run a mutation, you first call `useAddCounterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCounterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCounterMutation, { data, loading, error }] = useAddCounterMutation({
 *   variables: {
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useAddCounterMutation(baseOptions?: Apollo.MutationHookOptions<SchemaTypes.AddCounterMutation, SchemaTypes.AddCounterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SchemaTypes.AddCounterMutation, SchemaTypes.AddCounterMutationVariables>(AddCounterDocument, options);
      }
export type AddCounterMutationHookResult = ReturnType<typeof useAddCounterMutation>;
export type AddCounterMutationResult = Apollo.MutationResult<SchemaTypes.AddCounterMutation>;
export type AddCounterMutationOptions = Apollo.BaseMutationOptions<SchemaTypes.AddCounterMutation, SchemaTypes.AddCounterMutationVariables>;
export const AddCounter_WsDocument = gql`
    mutation AddCounter_WS($amount: Int!) {
  addCounter(amount: $amount) {
    amount
  }
}
    `;
export type AddCounter_WsMutationFn = Apollo.MutationFunction<SchemaTypes.AddCounter_WsMutation, SchemaTypes.AddCounter_WsMutationVariables>;
export type AddCounter_WsComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<SchemaTypes.AddCounter_WsMutation, SchemaTypes.AddCounter_WsMutationVariables>, 'mutation'>;

    export const AddCounter_WsComponent = (props: AddCounter_WsComponentProps) => (
      <ApolloReactComponents.Mutation<SchemaTypes.AddCounter_WsMutation, SchemaTypes.AddCounter_WsMutationVariables> mutation={AddCounter_WsDocument} {...props} />
    );
    

/**
 * __useAddCounter_WsMutation__
 *
 * To run a mutation, you first call `useAddCounter_WsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCounter_WsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCounterWsMutation, { data, loading, error }] = useAddCounter_WsMutation({
 *   variables: {
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useAddCounter_WsMutation(baseOptions?: Apollo.MutationHookOptions<SchemaTypes.AddCounter_WsMutation, SchemaTypes.AddCounter_WsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SchemaTypes.AddCounter_WsMutation, SchemaTypes.AddCounter_WsMutationVariables>(AddCounter_WsDocument, options);
      }
export type AddCounter_WsMutationHookResult = ReturnType<typeof useAddCounter_WsMutation>;
export type AddCounter_WsMutationResult = Apollo.MutationResult<SchemaTypes.AddCounter_WsMutation>;
export type AddCounter_WsMutationOptions = Apollo.BaseMutationOptions<SchemaTypes.AddCounter_WsMutation, SchemaTypes.AddCounter_WsMutationVariables>;
export const SyncCachedCounterDocument = gql`
    mutation SyncCachedCounter {
  syncCachedCounter
}
    `;
export type SyncCachedCounterMutationFn = Apollo.MutationFunction<SchemaTypes.SyncCachedCounterMutation, SchemaTypes.SyncCachedCounterMutationVariables>;
export type SyncCachedCounterComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<SchemaTypes.SyncCachedCounterMutation, SchemaTypes.SyncCachedCounterMutationVariables>, 'mutation'>;

    export const SyncCachedCounterComponent = (props: SyncCachedCounterComponentProps) => (
      <ApolloReactComponents.Mutation<SchemaTypes.SyncCachedCounterMutation, SchemaTypes.SyncCachedCounterMutationVariables> mutation={SyncCachedCounterDocument} {...props} />
    );
    

/**
 * __useSyncCachedCounterMutation__
 *
 * To run a mutation, you first call `useSyncCachedCounterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSyncCachedCounterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [syncCachedCounterMutation, { data, loading, error }] = useSyncCachedCounterMutation({
 *   variables: {
 *   },
 * });
 */
export function useSyncCachedCounterMutation(baseOptions?: Apollo.MutationHookOptions<SchemaTypes.SyncCachedCounterMutation, SchemaTypes.SyncCachedCounterMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SchemaTypes.SyncCachedCounterMutation, SchemaTypes.SyncCachedCounterMutationVariables>(SyncCachedCounterDocument, options);
      }
export type SyncCachedCounterMutationHookResult = ReturnType<typeof useSyncCachedCounterMutation>;
export type SyncCachedCounterMutationResult = Apollo.MutationResult<SchemaTypes.SyncCachedCounterMutation>;
export type SyncCachedCounterMutationOptions = Apollo.BaseMutationOptions<SchemaTypes.SyncCachedCounterMutation, SchemaTypes.SyncCachedCounterMutationVariables>;
export const CounterCacheQueryDocument = gql`
    query counterCacheQuery {
  counterCache {
    amount
  }
}
    `;
export type CounterCacheQueryComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<SchemaTypes.CounterCacheQueryQuery, SchemaTypes.CounterCacheQueryQueryVariables>, 'query'>;

    export const CounterCacheQueryComponent = (props: CounterCacheQueryComponentProps) => (
      <ApolloReactComponents.Query<SchemaTypes.CounterCacheQueryQuery, SchemaTypes.CounterCacheQueryQueryVariables> query={CounterCacheQueryDocument} {...props} />
    );
    

/**
 * __useCounterCacheQueryQuery__
 *
 * To run a query within a React component, call `useCounterCacheQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useCounterCacheQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCounterCacheQueryQuery({
 *   variables: {
 *   },
 * });
 */
export function useCounterCacheQueryQuery(baseOptions?: Apollo.QueryHookOptions<SchemaTypes.CounterCacheQueryQuery, SchemaTypes.CounterCacheQueryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SchemaTypes.CounterCacheQueryQuery, SchemaTypes.CounterCacheQueryQueryVariables>(CounterCacheQueryDocument, options);
      }
export function useCounterCacheQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SchemaTypes.CounterCacheQueryQuery, SchemaTypes.CounterCacheQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SchemaTypes.CounterCacheQueryQuery, SchemaTypes.CounterCacheQueryQueryVariables>(CounterCacheQueryDocument, options);
        }
export type CounterCacheQueryQueryHookResult = ReturnType<typeof useCounterCacheQueryQuery>;
export type CounterCacheQueryLazyQueryHookResult = ReturnType<typeof useCounterCacheQueryLazyQuery>;
export type CounterCacheQueryQueryResult = Apollo.QueryResult<SchemaTypes.CounterCacheQueryQuery, SchemaTypes.CounterCacheQueryQueryVariables>;
export const CounterStateDocument = gql`
    query CounterState {
  counterState @client {
    counter
  }
}
    `;
export type CounterStateComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<SchemaTypes.CounterStateQuery, SchemaTypes.CounterStateQueryVariables>, 'query'>;

    export const CounterStateComponent = (props: CounterStateComponentProps) => (
      <ApolloReactComponents.Query<SchemaTypes.CounterStateQuery, SchemaTypes.CounterStateQueryVariables> query={CounterStateDocument} {...props} />
    );
    

/**
 * __useCounterStateQuery__
 *
 * To run a query within a React component, call `useCounterStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useCounterStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCounterStateQuery({
 *   variables: {
 *   },
 * });
 */
export function useCounterStateQuery(baseOptions?: Apollo.QueryHookOptions<SchemaTypes.CounterStateQuery, SchemaTypes.CounterStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SchemaTypes.CounterStateQuery, SchemaTypes.CounterStateQueryVariables>(CounterStateDocument, options);
      }
export function useCounterStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SchemaTypes.CounterStateQuery, SchemaTypes.CounterStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SchemaTypes.CounterStateQuery, SchemaTypes.CounterStateQueryVariables>(CounterStateDocument, options);
        }
export type CounterStateQueryHookResult = ReturnType<typeof useCounterStateQuery>;
export type CounterStateLazyQueryHookResult = ReturnType<typeof useCounterStateLazyQuery>;
export type CounterStateQueryResult = Apollo.QueryResult<SchemaTypes.CounterStateQuery, SchemaTypes.CounterStateQueryVariables>;
export const CounterQueryDocument = gql`
    query counterQuery {
  counter {
    amount
  }
}
    `;
export type CounterQueryComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<SchemaTypes.CounterQueryQuery, SchemaTypes.CounterQueryQueryVariables>, 'query'>;

    export const CounterQueryComponent = (props: CounterQueryComponentProps) => (
      <ApolloReactComponents.Query<SchemaTypes.CounterQueryQuery, SchemaTypes.CounterQueryQueryVariables> query={CounterQueryDocument} {...props} />
    );
    

/**
 * __useCounterQueryQuery__
 *
 * To run a query within a React component, call `useCounterQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useCounterQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCounterQueryQuery({
 *   variables: {
 *   },
 * });
 */
export function useCounterQueryQuery(baseOptions?: Apollo.QueryHookOptions<SchemaTypes.CounterQueryQuery, SchemaTypes.CounterQueryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SchemaTypes.CounterQueryQuery, SchemaTypes.CounterQueryQueryVariables>(CounterQueryDocument, options);
      }
export function useCounterQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SchemaTypes.CounterQueryQuery, SchemaTypes.CounterQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SchemaTypes.CounterQueryQuery, SchemaTypes.CounterQueryQueryVariables>(CounterQueryDocument, options);
        }
export type CounterQueryQueryHookResult = ReturnType<typeof useCounterQueryQuery>;
export type CounterQueryLazyQueryHookResult = ReturnType<typeof useCounterQueryLazyQuery>;
export type CounterQueryQueryResult = Apollo.QueryResult<SchemaTypes.CounterQueryQuery, SchemaTypes.CounterQueryQueryVariables>;
export const OnCounterUpdatedDocument = gql`
    subscription onCounterUpdated {
  counterUpdated {
    amount
  }
}
    `;
export type OnCounterUpdatedComponentProps = Omit<ApolloReactComponents.SubscriptionComponentOptions<SchemaTypes.OnCounterUpdatedSubscription, SchemaTypes.OnCounterUpdatedSubscriptionVariables>, 'subscription'>;

    export const OnCounterUpdatedComponent = (props: OnCounterUpdatedComponentProps) => (
      <ApolloReactComponents.Subscription<SchemaTypes.OnCounterUpdatedSubscription, SchemaTypes.OnCounterUpdatedSubscriptionVariables> subscription={OnCounterUpdatedDocument} {...props} />
    );
    

/**
 * __useOnCounterUpdatedSubscription__
 *
 * To run a query within a React component, call `useOnCounterUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnCounterUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnCounterUpdatedSubscription({
 *   variables: {
 *   },
 * });
 */
export function useOnCounterUpdatedSubscription(baseOptions?: Apollo.SubscriptionHookOptions<SchemaTypes.OnCounterUpdatedSubscription, SchemaTypes.OnCounterUpdatedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<SchemaTypes.OnCounterUpdatedSubscription, SchemaTypes.OnCounterUpdatedSubscriptionVariables>(OnCounterUpdatedDocument, options);
      }
export type OnCounterUpdatedSubscriptionHookResult = ReturnType<typeof useOnCounterUpdatedSubscription>;
export type OnCounterUpdatedSubscriptionResult = Apollo.SubscriptionResult<SchemaTypes.OnCounterUpdatedSubscription>;
```

# packages-modules/counter/browser/src/apollo-server-n-client/compute.tsx

```tsx
import * as React from 'react';
import { IMenuPosition } from '@common-stack/client-react';

import Counter from './containers/Counter';
import { Dashboard } from '../common/components/Dashboard';
import { getFilteredMenus, getFilteredRoutes } from '../utils';

export const counterPageStore: any[] = [
    {
        exact: false,
        icon: 'export',
        key: 'dashboard',
        component: Dashboard,
        tab: 'Apollo Server & Client',
        position: IMenuPosition.MIDDLE,
        name: 'Apollo Server & Client',
        path: '/apollo-server-n-client',
    },
    {
        key: 'counter',
        name: 'Counter',
        icon: 'appstore-o',
        component: Counter,
        position: IMenuPosition.MIDDLE,
        path: '/apollo-server-n-client/counter',
    },
];

const selectedRoutesAndMenus = ['dashboard', 'counter'];

// get menus
const filteredMenus = getFilteredMenus(counterPageStore, selectedRoutesAndMenus);

// get routes
const filteredRoutes = getFilteredRoutes(counterPageStore, selectedRoutesAndMenus);

export { filteredMenus, filteredRoutes };

```

# packages/sample-store/src/repository/interfaces/index.ts

```ts
export * from './counter-repository';

```

# packages/sample-store/src/repository/interfaces/counter-repository.ts

```ts
import { IRepository } from '../../db-helpers';
import { ICount } from '../../models';

export interface ICounterRepository extends IRepository<ICount> {
    getCount: () => Promise<ICount>;

    addCount: (int) => void;
}

```

# packages/sample-store/src/models/interfaces/index.ts

```ts
export * from './count-model';

```

# packages/sample-store/src/models/interfaces/count-model.ts

```ts
import { IEntity } from '../../db-helpers';

export class ICount implements IEntity {
    public id: number;

    public amount: number;
}

```

# packages/sample-store/src/database-store/seeds/index.ts

```ts
// empty file on purpose
// empty file on purpose
exports.seed = function () {};

```

# packages/sample-store/src/database-store/seeds/counter.ts

```ts
import * as Knex from 'knex';

const initialAmount = 5;

export async function seed(knex: Knex) {
    await knex('count').truncate();

    return knex('count').insert({ amount: initialAmount });
}

```

# packages/sample-store/src/database-store/migrations/index.ts

```ts
// empty file on purpose
exports.up = function () {};
exports.down = function () {};

```

# packages/sample-store/src/database-store/migrations/counter.ts

```ts
import * as Knex from 'knex';

export const Counter_Table = 'count';
export const createCounter = async (driver) =>
    driver.schema.createTable(Counter_Table, (table) => {
        table.increments();
        table.timestamps(false, true);
        table.integer('amount').notNull();
    });
export const dropCounter = async (driver) =>
    driver.schema.dropTable(Counter_Table);

export async function up(knex: Knex) {
    return createCounter(knex);
}

export async function down(knex: Knex) {
    return dropCounter(knex);
}

```

# packages/sample-store/src/__tests__/db/config.json

```json
{
    "client": "sqlite3",
    "connection": {
        "filename": "packages/sample-store/__tests__/db/test-db.sqlite3"
    },
    "seeds": {
        "directory": "packages/sample-store/__tests__/db/seeds"
    },
    "migrations": {
        "directory": "packages/sample-store/__tests__/db/migrations"
    },
    "useNullAsDefault": true
}
```

# packages/sample-platform/browser/src/services/index.ts

```ts

```

# packages/sample-platform/browser/src/redux/index.ts

```ts
export * from './actions';
export * from './reducers';

```

# packages/sample-platform/browser/src/inversify-containers/module.ts

```ts
import { ContainerModule, interfaces, Container } from 'inversify';

export const platformModule: () => interfaces.ContainerModule = () =>
    new ContainerModule((bind: interfaces.Bind) => {});

```

# packages/sample-platform/browser/src/inversify-containers/index.ts

```ts
export * from './module';

```

# packages/sample-platform/browser/src/graphql/index.ts

```ts
export * from './mutations';
export * from './queries';
export * from './subscriptions';

```

# packages/sample-platform/browser/src/containers/index.ts

```ts
export * from './Counter';
export * from './PersonList';
// export * from './Loading';
export * from './ServerCounter';

```

# packages/sample-platform/browser/src/containers/ServerCounter.tsx

```tsx
import * as React from 'react';
import update from 'immutability-helper';
import { graphql } from '@apollo/react-hoc';
import compose from 'lodash/flowRight';
import { CounterComponent, ICounterProps } from '../components';
import { COUNT_SUBSCRIPTION, COUNT_QUERY, ADD_COUNT_MUTATION,} from '../graphql';
import { logger } from '@cdm-logger/client';
type SubscriptionProps = {
    subscribeToMore: Function;
};

// class WithSubscriptionCounter extends React.Component<SubscriptionProps & ICounterProps, {}> {

//     public subscription;

//     constructor(props) {
//         super(props);
//     }

//     public componentWillReceiveProps(nextProps) {
//         if (!nextProps.loading) {
//             if (this.subscription) {
//                 this.subscription();
//                 this.subscription = null;
//             }

//             // Subscribe or re-subscribe
//             if (!this.subscription) {
//                 this.subscribeToCount();
//             }
//         }
//     }

//     public componentWillUnmount() {
//         if (this.subscription) {
//             this.subscription();
//         }
//     }

//     private subscribeToCount() {
//         const { subscribeToMore } = this.props;
//         this.subscription = subscribeToMore({
//             document: onCountUpdated,
//             variables: {},
//             updateQuery: (prev, { subscriptionData: { data: { countUpdated: { amount } } } }) => {
//                 return update(prev, {
//                     count: {
//                         amount: {
//                             $set: amount,
//                         },
//                     },
//                 });
//             },
//         });
//     }

//     public render() {
//         const { ICounerProps } = this.props;
//         return <CounterComponent />;
//     }
// }


// save(amount) {
//     return () => mutate({
//         variables: { amount },
//         updateQueries,
//     });
// },

type countOptions = any & {
    countData: any;
};

const updateQueries = {
    counter: (prev, { mutationResult }) => {
        const newAmount = mutationResult.data.addCount.amount;
        return update(prev, {
            count: {
                amount: {
                    $set: newAmount,
                },
            },
        });
    },
};

export const CounterWithApollo: React.ComponentClass = (compose(
    graphql<{}, any, {}, {}>(ADD_COUNT_MUTATION, {
        props: ({ ownProps, mutate }) => ({
            save: (amount) => {
                return () => mutate({
                    variables: { amount },
                    // optimisticResponse: {
                    //     __typename: 'Mutation',

                    // },
                });
            },
        }),
    }),
    graphql<{}, any, {}, {}>(ADD_COUNT_MUTATION, {
        props: ({ ownProps, mutate }) => ({
            increment: (amount) => {
                return () => mutate({
                    variables: { amount },
                    // updateQueries,
                });
            },
        }),
    }),
)(graphql<ICounterProps, countOptions, {}, {}>(COUNT_QUERY, {
    name: 'countData',
    props: ({ countData }: any) => {
        const newlog = logger.child({ childName: 'UIController' });
        newlog.debug('count data : (%j)', countData);
        return {
            subscribeToCount: params => {
                // logger.debug('count subscript data (%j)', params);
                return countData.subscribeToMore({
                    document: COUNT_SUBSCRIPTION,
                    variables: {},
                    updateQuery: (prev: any, { subscriptionData }) => {
                        const payload = subscriptionData.data && subscriptionData.data.subscribeToWorkspace;
                        if (!payload) {
                            return prev;
                        }
                        return payload;
                    },
                });
            },
            counter: countData.count && countData.count.amount,
            isLoading: countData.loading,
            isSaving: false,
            load: () => countData.count.amount,
            error: countData.error,
        };
    },
})(CounterComponent as any))
);

```

# packages/sample-platform/browser/src/containers/PersonList.tsx

```tsx
import * as React from 'react';
import { graphql } from '@apollo/react-hoc';
import compose from 'lodash/flowRight';
import { PERSONS_QUERY } from '../graphql';

export interface IPersonListProps {
    persons;
}
const PersonListComponent: React.SFC<IPersonListProps> = ({ persons }) => (
    <div>
        <h2>Persons:</h2>
       {persons && persons.map((person, i) => <div key={i}>{person.name}</div>)}
    </div>
);

export const PersonList: React.ComponentClass<{}> =
    compose(
        graphql<{}, any, {}, {}>(PERSONS_QUERY),
        // flattenProp('data'),
    )(PersonListComponent);

```

# packages/sample-platform/browser/src/containers/Loading.tsx

```tsx
import * as React from 'react';

interface Props {}

const Loading: React.SFC<Props> = () => (
    <div>Loading</div>
);

// export const displayLoadingState = branch(
//     props => props.data.loading,
//     renderComponent(Loading)
// );

```

# packages/sample-platform/browser/src/containers/Counter.tsx

```tsx
import {
  incrementCounter,
  loadCount,
  saveCount,
  Action,
  Store,
} from '../redux';
import { connect } from 'react-redux';
import * as redux from 'redux';
import { CounterComponent, ICounterProps } from '../components';

export type CounterOwnProps = {
  label: string;
  store?: Store.Sample;
};

const mapStateToProps = (state: Store.Sample) => ({
  counter: state['@sample-stack/counter'],
  isSaving: state['@sample-stack/isSaving'],
  isLoading: state['@sample-stack/isLoading'],
  error: state['@sample-stack/error'],
  
});

const mapDispatchToProps = (dispatch: Function) => ({
  increment: (n: number) =>
    dispatch(incrementCounter(n)),
  load: () =>
    dispatch(loadCount(null)),
  save: (value: number) =>
    dispatch(saveCount({ value })),
});

// const stateProps = mapStateToProps;
// const dispatchProps = returntypeof(mapDispatchToProps);
// type StateProps = typeof stateProps;
// type DispatchProps = typeof dispatchProps;

// https://github.com/DefinitelyTyped/DefinitelyTyped/issues/8787
export const Counter =
connect<any, any, any>(mapStateToProps, mapDispatchToProps)(CounterComponent);


```

# packages/sample-platform/browser/src/containers/Clock.tsx

```tsx

```

# packages/sample-platform/browser/src/components/index.ts

```ts
export * from './Counter';

```

# packages/sample-platform/browser/src/components/NavBar.tsx

```tsx
import * as React from 'react';
import { Link } from 'react-router-dom';

const NavBar = () => (
    <div>
        <div><Link to="/">Home</Link> <Link to="/hello">Hello</Link> <Link to="/counter">Counter</Link></div>
    </div>
);

export { NavBar };

```

# packages/sample-platform/browser/src/components/Counter.tsx

```tsx
import * as React from 'react';

export interface ICounterProps {
    label: string;
    counter: { value: number };
    isSaving: boolean;
    isLoading: boolean;
    error: string;
    increment: (n: number) => void;
    save: (n: number) => void;
    load: () => void;
}

export interface ICounterState {
}

export class CounterComponent extends React.Component<ICounterProps, ICounterState> {

    private _onClickIncrement = (e: React.SyntheticEvent<HTMLButtonElement>) => {
        e.preventDefault();
        this.props.increment(1);
    }

    private _onClickSave = (e: React.SyntheticEvent<HTMLButtonElement>) => {
        e.preventDefault();
        if (!this.props.isSaving) {
            this.props.save(this.props.counter.value);
        }
    }

    private _onClickLoad = (e: React.SyntheticEvent<HTMLButtonElement>) => {
        e.preventDefault();
        if (!this.props.isLoading) {
            this.props.load();
        }
    }

    public render(): JSX.Element {
        const { counter, label, isSaving, isLoading, error } = this.props;
        return (
            <form>
                <legend>{label}</legend>
                <pre>{JSON.stringify({ counter, isSaving, isLoading }, null, 2)}</pre>
                <button onClick={this._onClickIncrement}>click me!</button>
                <button disabled={isSaving} onClick={this._onClickSave}>{isSaving ? 'saving...' : 'save'}</button>
                <button disabled={isLoading} onClick={this._onClickLoad}>{isLoading ? 'loading...' : 'load'}</button>
                {error ? <div className="error">{error}</div> : null}
            </form>);
    }
}



```

# tools/templates/module/browser/src/utils/index.ts

```ts

```

# tools/templates/module/browser/src/selectors/index.ts

```ts

```

# tools/templates/module/browser/src/locales/index.ts

```ts
/*
* The index.ts can be empty, it's just needed to point the loader to the root directory of the locales.
* https://github.com/alienfast/i18next-loader#option-2-use-with-import-syntax
*/
export default {};

```

# tools/templates/module/browser/src/graphql/schema.ts

```ts

```

# tools/templates/module/browser/src/graphql/index.ts

```ts
export * from './queries';
// export * from './mutations';

```

# tools/templates/module/browser/src/constants/index.ts

```ts
export * from './constants';

```

# tools/templates/module/browser/src/constants/constants.ts

```ts
export const $Module$_NAMESPACE = '@$Module$_NAMESPACE';



export enum $Module$_API_ROUTES {
    $Module$_ROOT = '@$Module$/ROOT',
}

```

# tools/templates/module/server/src/services/index.ts

```ts

```

# tools/templates/module/server/src/plugin/index.ts

```ts
import * as ILogger from 'bunyan';
const Hp = require('hemera-plugin');
import * as Hemera from 'nats-hemera';
import { Container } from 'inversify';
const HemeraJoi = require('hemera-joi');
import { NatsPubSub } from 'graphql-nats-subscriptions';


function WorkspaceServicePlugin(hemera: Hemera, options: { settings: any, client: any }, done) {

  const { settings, client } = options;
  const topic = `${HemeraTopics.ActivityCollector}/${settings.subTopic}`;

  const pubsub = new NatsPubSub({ client, logger: hemera.log });

  let container = new Container();

}

module.exports = Hp(WorkspaceServicePlugin, {
  hemera: '>=2.0.0-0',
  name: require('../../package.json').name,
});

```

# tools/templates/module/server/src/interfaces/index.ts

```ts

```

# tools/templates/module/server/src/containers/module.ts

```ts
import { TaggedType } from '@common-stack/core';
import { ContainerModule, interfaces, Container } from 'inversify';

import { TYPES } from '../constants';
import { IActivityCollector } from '../interfaces';
import { ActivityLocalservice, ActivityMicroservice } from '../services';

import { Redis } from '../storage/Redis';

export const activityModule: (settings: any, pubsub?) => interfaces.ContainerModule =
    (settings) => new ContainerModule((bind: interfaces.Bind) => {
        bind(TYPES.ActivityStorage).to(Redis);
        bind(TYPES.ActivityDBConnection).toConstantValue(settings.mongoConnection);

        bind<IActivityCollector>(TYPES.ActivityCollector)
            .to(ActivityLocalservice)
            .inSingletonScope()
            .whenTargetIsDefault();
    });

export const activityModuleNats: (settings: any, pubsub?: any) => interfaces.ContainerModule =
    settings =>
    new ContainerModule((bind: interfaces.Bind) => {
        bind(TYPES.ActivityStorage).to(Redis);
        bind(TYPES.ActivityDBConnection).toConstantValue(settings.mongoConnection);

        bind<IActivityCollector>(TYPES.ActivityCollector)
            .to(ActivityMicroservice)
            .inSingletonScope()
            .whenTargetNamed(TaggedType.MICROSERVICE);
    });

```

# tools/templates/module/server/src/containers/index.ts

```ts
export * from './module';

```

# tools/templates/module/server/src/config/index.ts

```ts
export * from './env-config';

```

# tools/templates/module/server/src/config/env-config.ts

```ts
import * as envalid from 'envalid';
const { str, email, json, num } = envalid;

export interface IConfig {
    NODE_ENV: string;
    REDIS_URL?: string;
    PROMETHEUS_API_URL?: string;
}

export const config = envalid.cleanEnv<IConfig>(process.env, {
    REDIS_URL: str(),
    PROMETHEUS_API_URL: str(),
    NODE_ENV: str({choices: ['production', 'test', 'staging', 'development'], default: 'production'}),
});


```

# tools/templates/module/server/src/constants/types.ts

```ts
export const TYPES = {
    ActivityStorage: 'ActivityStorage',
    ActivityCollector: 'ActivityCollector',
    ActivityDBConnection: 'ActivityDBConnection',
};

export enum EActivityScopes {
    User = 'user',
    Team = 'team',
    Cluster = 'cluster',
    Default = 'default',
    Workspace = 'workspace',
    Organization = 'organization',
}

export const MODELS = {
    ActivityStorageModel: 'ActivityStorageModel',
};

export enum HemeraTopics {
    ActivityStorage = 'ActivityStorage',
    ActivityCollector = 'ActivityCollector',
}

export enum HemeraCommands {
    Collect = 'Collect',

    StorageSet = 'StorageSet',
    StorageGet = 'StorageGet',
    StorageDelete = 'StorageDelete',

    StorageGetActive = 'StorageGetActive',
    StorageGetInactive = 'StorageGetInactive',
}

```

# tools/templates/module/server/src/constants/index.ts

```ts
export * from './types';

export const ACTIVITY_DEBOUNCE = 900000;
// export const ACTIVITY_DEBOUNCE = 10000;

```

# servers/frontend-server/src/modules/layout/components/index.ts

```ts
export * from './SideMenu';

```

# servers/frontend-server/src/modules/layout/components/SideMenu.tsx

```tsx
import * as H from 'history';
import * as React from 'react';
import { Link } from 'react-router-dom';
import * as PropTypes from 'prop-types';
import pathToRegexp from 'path-to-regexp';
import { Layout, Menu, Avatar } from 'antd';
import { IMenuPosition } from '@common-stack/client-react';

const { Sider } = Layout;
const { SubMenu } = Menu;

export function urlToList(url) {
    const urllist = url.split('/').filter(i => i);
    return urllist.map((urlItem, index) => {
        return `/${urllist.slice(0, index + 1).join('/')}`;
    });
}

const getImageUrl = (picture) => {
    return picture || "data:image/png;base64,${new Identicon(Base64.encode('myawsomestringbebe'), 420).toString()}";
};

/**
 * Recursively flatten  the data
 * [{path: string}, {path: string}] => {path, path2}
 * @param menu
 */
export const getFlatMenuKeys = menu =>
    menu.reduce((keys, item) => {
        keys.push(item.path);
        if (item.children) {
            return keys.concat(getFlatMenuKeys(item.children));
        }
        return keys;
    }, []);


/**
 * Find all matched menu keys based on paths
 * @param flatMenuKeys: [/abc, /abc/:id, /abc/:id/info]
 * @param paths: [/abc/ /abc/11, /abc/11/info]
 */
export const getMenuMatchKeys = (flatMenuKeys, paths) =>
    paths.reduce((matchKeys, path) => (
        matchKeys.concat(
            flatMenuKeys.filter(item => pathToRegexp(item).test(path)),
        )), []);

export namespace ISiderMenu {
    export interface CompProps {
        menuData: any;
        segments: any;
        onCollapse?: any;
        state?: boolean;
        isMobile?: boolean;
        renderer?: any;
        Authorized?: any;
        collapsed?: boolean;
        logo?: any;
        user?: any;
        styles?: {
            grow?: any;
            logo?: any;
            sider?: any;
            icon?: any;
        };
    }

    export interface StateProps {
        location: H.Location;
    }

    export interface CompState {
        openKeys?: any;
    }

    export type Props = CompProps & StateProps;
    export type State = CompState;
}
export class SiderMenu extends React.PureComponent<ISiderMenu.Props, ISiderMenu.State> {

    private menus;
    private flatMenuKeys;

    constructor(props) {
        super(props);
        this.menus = props.menuData;
        this.flatMenuKeys = getFlatMenuKeys(props.menuData);
        this.state = {
            openKeys: this.getDefaultCollapsedSubMenus(props),
        };
    }

    public static contextTypes = {
        renderer: PropTypes.any.isRequired,
    };

    public static defaultProps() {
        return {
            user: {},
            isMobile: false,
        };
    }


    public UNSAFE_componentWillReceiveProps(nextProps) {
        if (nextProps.location.pathname !== this.props.location.pathname) {
            this.setState({
                openKeys: this.getDefaultCollapsedSubMenus(nextProps),
            });
        }
    }

    /**
     * Convert pathname to openKeys
     * /list/search/articles => ['list', '/list/search']
     * @param props
     */
    public getDefaultCollapsedSubMenus(props) {
        const { location: { pathname } } = props || this.props;
        return getMenuMatchKeys(this.flatMenuKeys, urlToList(pathname));
    }

    /**
     * Allow menu.js config icon as string or ReactNode
     * icon: 'setting',
     * icon: 'http://demo.com/icon.png',
     * icon: <Icon type="setting" />,
     * @param icon
     */
    private getIcon(icon) {
        const { styles = {} } = this.props;
        if (typeof icon === 'string' && icon.indexOf('http') === 0) {
            return <img src={icon} alt="icon" className={styles.icon} />;
        } if (typeof icon === 'string') {
            return <div data-type={icon} style={styles.icon} />;
        }
        return icon;
    }

    private getAvatar(menu) {
        const { styles = {}, user } = this.props;
        return (
            <span data-user={user.nickname} id={!user || user.isTest ? `cde-user-placeholder` : 'cde-user'}>
                <div style={{ marginRight: '7px' }} data-src={getImageUrl(user.picture)}>
                    {user.nickname || 'Guest'}
                </div>
                {' '}
                <span> {user.nickname || 'Guest'}</span>
            </span>
        );
    }

    /**
     * Judge whether it is http link.return or a Link
     * @memberOf SiderMenu
     */
    private getMenuItemPath = item => {
        const { styles = {} } = this.props;
        const itemPath = this.conversionPath(item.path);
        const icon = this.getIcon(item.icon);
        const { target, name } = item;
        // Is it a http link
        if (/^https?:\/\//.test(itemPath)) {
            return (
                <a href={itemPath} target={target}>
                    {icon}
                    <span>{name}</span>
                </a>
            );
        }
        return (
            <Link
                to={itemPath}
                target={target}
                replace={itemPath === this.props.location.pathname}
                onClick={
                    this.props.isMobile
                        ? () => {
                            this.props.onCollapse(true);
                        }
                        : undefined
                }
            >
                {icon}
                <span>{name}</span>
            </Link>
        );
    }
    /**
     * get SubMenu or Item
     */
    private getSubMenuOrItem = item => {
        const { styles = {} } = this.props;
        if (item.children && item.children.some(child => child.name)) {
            const childrenItems = this.getNavMenuItems(item.children);
            if (childrenItems && childrenItems.length > 0) {
                return (
                    <SubMenu title={item.name} key={item.path}>
                        {childrenItems}
                    </SubMenu>
                );
            }
            return null;
        } else {
            return <Menu.Item key={item.path}>{this.getMenuItemPath(item)}</Menu.Item>;
        }
    }
    /**
     * @memberof SiderMenu
     */
    private getNavMenuItems = menusData => {
        if (!menusData) {
            return [];
        }
        return menusData.filter(item => item.name && !item.hideInMenu)
            .map(item => {
                // make dom
                const ItemDom = this.getSubMenuOrItem(item);
                return this.checkPermissionItem(item.authority, ItemDom);
            })
            .filter(item => item);
    }

    /**
     * Generates LOGO
     * @memberof SiderMenu
     */
    private getLogo(logo) {
        const { styles = {} } = this.props;
        return logo && (
            <div className={styles.logo} key="logo">
                <Link to="/">
                    <img src={logo.icon} alt="logo" />
                    <h1>{logo.name}</h1>
                </Link>
            </div>
        );
    }

    // Get the currently selected menu
    private getSelectedMenuKeys = () => {
        const { location: { pathname } } = this.props;
        return getMenuMatchKeys(this.flatMenuKeys, urlToList(pathname));
    }
    // conversion Path
    private conversionPath = path => {
        if (path && path.indexOf('http') === 0) {
            return path;
        } else {
            return `/${path || ''}`.replace(/\/+/g, '/');
        }
    }
    // permission to check
    private checkPermissionItem = (authority, ItemDom) => {
        if (this.props.Authorized && this.props.Authorized.check) {
            const { check } = this.props.Authorized;
            return check(authority, ItemDom);
        }
        return ItemDom;
    }
    private isMainMenu = key => {
        return this.menus.some(item => key && (item.key === key || item.path === key));
    }
    private handleOpenChange = openKeys => {
        const lastOpenKey = openKeys[openKeys.length - 1];
        const moreThanOne = openKeys.filter(openKey => this.isMainMenu(openKey)).length > 1;
        this.setState({
            openKeys: moreThanOne ? [lastOpenKey] : [...openKeys],
        });
    }

    public render() {
        const { renderer } = this.context;
        const { logo, collapsed, segments = [], onCollapse, styles = {} } = this.props;
        const { openKeys } = this.state;
        // Don't show popup menu when it is been collapsed
        const menuProps = collapsed ? {} : { openKeys };
        // If pathname can't match, use the nearest parent's key
        let selectedKeys = this.getSelectedMenuKeys();
        if (!selectedKeys.length) {
            selectedKeys = [openKeys[openKeys.length - 1]];
        }

        return (
            <Sider
                trigger={null}
                collapsible={true}
                collapsed={collapsed}
                breakpoint="lg"
                onCollapse={onCollapse}
                width={256}
                className={styles.sider}
            >
                {this.getLogo((this.menus.filter(menu => menu.position === IMenuPosition.LOGO) || [])[0])}
                <div className={styles.grow}>
                    <Menu
                        key="Menu-Middle"
                        theme="dark"
                        mode="inline"
                        {...menuProps}
                        className={styles.grow}
                        onOpenChange={this.handleOpenChange}
                        selectedKeys={selectedKeys}
                        style={{ padding: '16px 0', width: '100%' }}
                    >
                        {this.getNavMenuItems(this.menus.filter(menu => menu.position === IMenuPosition.MIDDLE))}
                    </Menu>
                    {segments.map((segment, segmentIndex) => (
                        <div key={segmentIndex}>
                            {React.cloneElement(segment, { collapsed })}
                        </div>
                    ))}
                </div>
                <Menu
                    key="Menu-Bottom"
                    theme="dark"
                    mode="inline"
                    {...menuProps}
                    onOpenChange={this.handleOpenChange}
                    selectedKeys={selectedKeys}
                    style={{ padding: '16px 0', width: '100%' }}
                >
                    {this.getNavMenuItems(this.menus.filter(menu => menu.position === IMenuPosition.BOTTOM))}
                </Menu>
            </Sider>
        );
    }
}


```

# portable-devices/desktop/src/renderer/modules/tray/module.tsx

```tsx
import * as React from 'react';
import { Feature, FeatureWithRouterFactory, renderRoutes2 } from '@common-stack/client-react';
import { Layout } from 'antd';
import { ElectronTrayModule } from '@sample-stack/counter-module-browser';

const features = new Feature(FeatureWithRouterFactory, ElectronTrayModule);
export const MainRoute = (props) => (
    <Layout>
        <Layout.Content style={{ height: '100%' }}>
            <section className="flex-grow" style={{ height: '100%' }}>
                {features.getRoutes()}
            </section>
        </Layout.Content>
    </Layout>
);

export default features;

```

# portable-devices/desktop/src/renderer/modules/tray/index.ts

```ts
import { logger } from '@cdm-logger/client';
import { ClientTypes } from '@common-stack/client-react';
import modules, { MainRoute } from './module';

class UtilityClass {
    // eslint-disable-next-line no-useless-constructor
    constructor(private modules) {}

    public getCacheKey(storeObj) {
        return this.modules.getDataIdFromObject(storeObj);
    }
}

const utility = new UtilityClass(modules);

// additional bindings to container
const container = modules.createContainers({}) as any;
container.bind(ClientTypes.Logger).toConstantValue(logger);
container.bind(ClientTypes.UtilityClass).toConstantValue(utility);

export default modules;
export { MainRoute, container, logger };

```

# portable-devices/desktop/src/renderer/modules/main/module.tsx

```tsx
import * as React from 'react';
import { Layout } from 'antd';
import counterModules from '@sample-stack/counter-module-browser';
import { Feature, FeatureWithRouterFactory } from '@common-stack/client-react';
import { SiderMenu } from '../../components/layout';

const features = new Feature(FeatureWithRouterFactory, counterModules);

export const MainRoute = (props) => (
    <Layout hasSider style={{ minHeight: '100vh', display: 'flex' }}>
        <SiderMenu
            collapsed={false}
            menuData={features.getMenus()}
            location={window.location as any}
            segments={features.sidebarSegments}
        />
        <Layout>
            <Layout.Content style={{ height: '100%' }}>
                <section className="flex-grow" style={{ height: '100%' }}>
                    {features.getRoutes()}
                </section>
            </Layout.Content>
        </Layout>
    </Layout>
);

export default features;

```

# portable-devices/desktop/src/renderer/modules/main/index.ts

```ts
import { logger } from '@cdm-logger/client';
import { ClientTypes } from '@common-stack/client-react';
import modules, { MainRoute } from './module';

class UtilityClass {
    // eslint-disable-next-line no-useless-constructor
    constructor(private modules) {}

    public getCacheKey(storeObj) {
        return this.modules.getDataIdFromObject(storeObj);
    }
}

const utility = new UtilityClass(modules);

// additional bindings to container
const container = modules.createContainers({}) as any;
container.bind(ClientTypes.Logger).toConstantValue(logger);
container.bind(ClientTypes.UtilityClass).toConstantValue(utility);

export default modules;
export { MainRoute, container, logger };

```

# portable-devices/desktop/src/renderer/config/tray/redux-config.ts

```ts
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable global-require */
/* eslint-disable no-nested-ternary */
/* eslint-disable no-underscore-dangle */
import { forwardToMain, replayActionRenderer, forwardToMainWithParams, getInitialStateRenderer } from 'electron-redux';
import { createEpicMiddleware } from 'redux-observable';
import { connectRouter, routerMiddleware } from 'connected-react-router';
import modules from '../../modules/tray';
import { createClientContainer } from './client.service';
import { isDev } from '../../../common';
import { rootEpic } from './epic-config';
import { createReduxStore as createBaseReduxStore } from '../../../common/config/base-redux-config';

export const history = require('../router-history');

const { apolloClient, container, services, logger } = createClientContainer();
export const epicMiddleware = createEpicMiddleware({
    dependencies: {
        apolloClient,
        routes: modules.getConfiguredRoutes(),
        services,
        container,
        logger,
    },
});

/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = () => {
    // middleware
    const router = connectRouter(history);

    // If we have preloaded state, save it.
    const store = createBaseReduxStore({
        scope: 'browser',
        isDebug: __DEBUGGING__,
        isDev,
        initialState: {},
        middleware: [routerMiddleware(history)],
        // epicMiddleware,
        preMiddleware: [forwardToMain],
        // rootEpic,
        reducers: { router, ...modules.reducers },
    });

    // Delete it once we have it stored in a variable
    if (__CLIENT__) {
        delete window.__PRELOADED_STATE__;
        // electron
        replayActionRenderer(store);
    }
    container.bind('ReduxStore').toConstantValue(store);

    return store;
};

```

# portable-devices/desktop/src/renderer/config/tray/fela-renderer.ts

```ts
import { createRenderer } from 'fela';
import webPreset from 'fela-preset-web';

export default () => {
    const renderer = createRenderer({
        plugins: [...webPreset],
        devMode: process.env.NODE_ENV ? process.env.NODE_ENV !== 'production' : false,
    });
    renderer.renderStatic(
        `
        html, body, #root{
            height: 100%;
            }
        `,
    );

    return renderer;
};

```

# portable-devices/desktop/src/renderer/config/tray/epic-config.ts

```ts
import { combineEpics, ofType } from 'redux-observable';
import { BehaviorSubject } from 'rxjs';
import { mergeMap, takeUntil } from 'rxjs/operators';
import modules from '../../modules/tray';

export const epic$ = new BehaviorSubject(combineEpics(...modules.epics));

// Since we're using mergeMap, by default any new
// epic that comes in will be merged into the previous
// one, unless an EPIC_END action is dispatched first,
// which would cause the old one(s) to be unsubscribed
export const rootEpic = (action$, ...rest) =>
    epic$.pipe<any>(mergeMap((epic) => epic(action$, ...rest).pipe(takeUntil(action$.pipe(ofType('EPIC_END'))))));

```

# portable-devices/desktop/src/renderer/config/tray/client.service.ts

```ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ClientTypes } from '@common-stack/client-core';
import { Container } from 'inversify';
import { ApolloClient } from '@apollo/client';
import { CdmLogger } from '@cdm-logger/core';
import { logger } from '@cdm-logger/client';
import modules, { container } from '../../modules/tray';
import { createApolloClient } from '../../../common/config/base-apollo-client';
import { PUBLIC_SETTINGS } from '../public-config';
import { isDev } from '../../../common';

let __CLIENT_SERVICE__: {
    apolloClient: ApolloClient<any>;
    container: Container;
    services: any;
    logger: CdmLogger.ILogger;
};
export const createClientContainer = () => {
    if (__CLIENT_SERVICE__) {
        return __CLIENT_SERVICE__;
    }
    const clientState = modules.getStateParams({ resolverContex: () => modules.createService({}, {}) });
    const { cache, apolloClient } = createApolloClient({
        httpGraphqlURL: PUBLIC_SETTINGS.GRAPHQL_URL,
        httpLocalGraphqlURL: PUBLIC_SETTINGS.LOCAL_GRAPHQL_URL,
        isDev,
        isDebug: __DEBUGGING__,
        isSSR: __SSR__,
        scope: 'browser',
        clientState,
        getDataIdFromObject: (result) => modules.getDataIdFromObject(result),
        initialState: null,
        logger,
    });
    // attaching the context to client as a workaround.
    container.bind(ClientTypes.ApolloClient).toConstantValue(apolloClient);
    container.bind(ClientTypes.InMemoryCache).toConstantValue(cache);
    const services = modules.createService({}, {});
    (apolloClient as any).container = services;

    __CLIENT_SERVICE__ = {
        container,
        apolloClient,
        services,
        logger,
    };
    return __CLIENT_SERVICE__;
};

```

# portable-devices/desktop/src/renderer/config/main/redux-config.ts

```ts
/* eslint-disable no-param-reassign */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable global-require */
/* eslint-disable no-nested-ternary */
/* eslint-disable no-underscore-dangle */
import { replayActionRenderer, forwardToMainWithParams } from 'electron-redux';
import storage from 'redux-persist/lib/storage';
import { combineReducers } from 'redux';
import autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2';
import { createEpicMiddleware } from 'redux-observable';
import { connectRouter, routerMiddleware } from 'connected-react-router';
import modules from '../../modules/main';
import { createClientContainer } from './client.service';
import { rootEpic, epic$ } from './epic-config';
import { createReduxStore as createBaseReduxStore } from '../../../common/config/base-redux-config';
import { isDev } from '../../../common';

const history = require('../router-history');

const { apolloClient, services, container, logger } = createClientContainer();
export const epicMiddleware = createEpicMiddleware({
    dependencies: {
        apolloClient,
        routes: modules.getConfiguredRoutes(),
        services,
        container,
        logger,
    },
});

export const persistConfig = {
    key: 'root',
    storage,
    stateReconciler: autoMergeLevel2,
    // Don't add `user` state to persist as it creates problems.
    transforms: modules.reduxPersistStateTransformers,
};

export const storeReducer = (hist) =>
    combineReducers({
        router: connectRouter(hist),
        ...modules.reducers,
    });

/**
 * Add any reducers required for this app dirctly in to
 * `combineReducers`
 */
export const createReduxStore = () => {
    // middleware
    const router = connectRouter(history);

    let store;
    if ((module as any).hot && (module as any).hot.data && (module as any).hot.data.store) {
        // console.log('Restoring Redux store:', JSON.stringify((module as any).hot.data.store.getState()));
        store = (module as any).hot.data.store;
        // replace the reducers always as we don't have ablity to find
        // new reducer added through our `modules`
        store.replaceReducer(
            persistReducer(persistConfig, storeReducer((module as any).hot.data.history || newHistory)),
        );
        // store.replaceReducer(storeReducer((module as any).hot.data.history || history));
    } else {
        // If we have preloaded state, save it.
        const initialState = __CLIENT__
            ? { ...window.__PRELOADED_STATE__ } // #952 TODO we need cookie to have id_token for SSR to work properly
            : {};
        // Delete it once we have it stored in a variable
        if (__CLIENT__) {
            delete window.__PRELOADED_STATE__;
        }
        store = createBaseReduxStore({
            scope: 'browser',
            isDebug: __DEBUGGING__,
            isDev,
            initialState: {},
            persistConfig,
            middleware: [routerMiddleware(history)],
            epicMiddleware,
            preMiddleware: [
                forwardToMainWithParams({
                    blacklist: [/^@@/, /^redux-form/, /^contribution/, /^command/],
                }),
            ],
            rootEpic,
            reducers: { router, ...modules.reducers },
        });
    }
    if ((module as any).hot) {
        (module as any).hot.dispose((data) => {
            // console.log("Saving Redux store:", JSON.stringify(store.getState()));
            data.store = store;
            data.history = history;
        });
        (module as any).hot.accept('../config/epic-config', () => {
            // we may need to reload epic always as we don't
            // know whether it is updated using our `modules`
            const nextRootEpic = require('./epic-config').rootEpic;
            // First kill any running epics
            store.dispatch({ type: 'EPIC_END' });
            // Now setup the new one
            epic$.next(nextRootEpic);
        });
    }
    // Delete it once we have it stored in a variable
    if (__CLIENT__) {
        // electron
        replayActionRenderer(store);
    }
    container.bind('ReduxStore').toConstantValue(store);
    return store;
};

```

# portable-devices/desktop/src/renderer/config/main/fela-renderer.ts

```ts
import { createRenderer } from 'fela';
import webPreset from 'fela-preset-web';

export default () => {
    const renderer = createRenderer({
        plugins: [...webPreset],
        devMode: process.env.NODE_ENV ? process.env.NODE_ENV !== 'production' : false,
    });
    renderer.renderStatic(
        `
        html, body, #root{
            height: 100%;
            }
            .ant-picker-dropdown, .ant-select-dropdown {
            
            }
            @media only screen and (min-width: 768px) {
                #usermenuStyle{
                    position: fixed;
                    top: calc(100% - 140px)!important;
                }
            }
            aside{
                overflow:inherit !important;
            }
        `,
    );

    return renderer;
};

```

# portable-devices/desktop/src/renderer/config/main/epic-config.ts

```ts
import { combineEpics, ofType } from 'redux-observable';
import { BehaviorSubject } from 'rxjs';
import { mergeMap, takeUntil } from 'rxjs/operators';
import modules from '../../modules/main';

export const epic$ = new BehaviorSubject(combineEpics(...modules.epics));

// Since we're using mergeMap, by default any new
// epic that comes in will be merged into the previous
// one, unless an EPIC_END action is dispatched first,
// which would cause the old one(s) to be unsubscribed
export const rootEpic = (action$, ...rest) =>
    epic$.pipe<any>(mergeMap((epic) => epic(action$, ...rest).pipe(takeUntil(action$.pipe(ofType('EPIC_END'))))));

```

# portable-devices/desktop/src/renderer/config/main/client.service.ts

```ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-underscore-dangle */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ClientTypes } from '@common-stack/client-core';
import { Container } from 'inversify';
import { ApolloClient } from '@apollo/client';
import { CdmLogger } from '@cdm-logger/core';
import { logger } from '@cdm-logger/client';
import modules, { container } from '../../modules/main';
import { createApolloClient } from '../../../common/config/base-apollo-client';
import { PUBLIC_SETTINGS } from '../public-config';
import { isDev } from '../../../common';

let __CLIENT_SERVICE__: {
    apolloClient: ApolloClient<any>;
    container: Container;
    services: any;
    logger: CdmLogger.ILogger;
};
export const createClientContainer = () => {
    if (__CLIENT_SERVICE__) {
        return __CLIENT_SERVICE__;
    }
    const clientState = modules.getStateParams({ resolverContex: () => modules.createService({}, {}) });
    const { cache, apolloClient } = createApolloClient({
        httpGraphqlURL: PUBLIC_SETTINGS.GRAPHQL_URL,
        httpLocalGraphqlURL: PUBLIC_SETTINGS.LOCAL_GRAPHQL_URL,
        isDev,
        isDebug: __DEBUGGING__,
        isSSR: __SSR__,
        scope: 'browser',
        clientState,
        getDataIdFromObject: (result) => modules.getDataIdFromObject(result),
        initialState: null,
        logger,
    });
    // attaching the context to client as a workaround.
    container.bind(ClientTypes.ApolloClient).toConstantValue(apolloClient);
    container.bind(ClientTypes.InMemoryCache).toConstantValue(cache);
    const services = modules.createService({}, {});
    (apolloClient as any).container = services;

    __CLIENT_SERVICE__ = {
        container,
        apolloClient,
        services,
        logger,
    };
    return __CLIENT_SERVICE__;
};

```

# portable-devices/desktop/src/renderer/components/layout/index.ts

```ts
export * from './components';

```

# portable-devices/desktop/src/main/utils/window/protocol.ts

```ts
/* eslint-disable import/no-extraneous-dependencies */
import { protocol, BrowserWindow } from 'electron';
import { dev } from 'electron-is';
import { format as formatUrl } from 'url';
import createProtocol from '../createProtocol';
import { config } from '../../../common/config/config';

protocol.registerSchemesAsPrivileged([{ scheme: 'app', privileges: { secure: true, standard: true } }]);

/**
 * Load address path
 * @param windows window
 * @param name path name in renderer
 */
export const loadUrl = (windows: BrowserWindow, name: string) => {
    if (dev()) {
        const htmlDevPath = formatUrl({
            protocol: 'http',
            slashes: true,
            hostname: config.ELECTRON_WEBPACK_WDS_HOST,
            port: config.ELECTRON_WEBPACK_WDS_PORT,
            pathname: `${name}.html`,
        });
        windows.loadURL(htmlDevPath);
    } else {
        createProtocol('app');
        windows.loadURL(`app://./${name}.html`);
    }
};

```

# portable-devices/desktop/src/main/utils/window/index.ts

```ts
/* eslint-disable import/no-extraneous-dependencies */
import { BrowserWindow, BrowserWindowConstructorOptions } from 'electron';
import { merge } from 'lodash';
import { loadDevTools } from './devTools';
import { loadUrl } from './protocol';

export interface WindowOpts extends BrowserWindowConstructorOptions {
    /**
     * URL
     */
    name: string;
    title?: string;
    show?: boolean;
    width?: number;
    height?: number;
    devTools?: boolean;
    /**
     * Allow renderer to use remote module
     */
    remote?: boolean;
}

/**
 * Method of constructing BrowserWindows object
 * @param opts { WindowOpts }
 */
export const createWindow = (opts: WindowOpts) => {
    const { name, title, width, height, devTools, remote, show = false } = opts;
    const windows = new BrowserWindow(
        merge(
            {},
            {
                show,
                width,
                height,
                title,
                webPreferences: {
                    nodeIntegration: true,
                    enableRemoteModule: remote,
                    // Context isolation environment
                    // https://www.electronjs.org/docs/tutorial/context-isolation
                    contextIsolation: false,
                    // devTools: isDev,
                },
            },
            opts,
        ),
    );

    loadUrl(windows, name);

    loadDevTools();

    // Show devtools and open it
    if (devTools) {
        windows.webContents.openDevTools();
    }
    return windows;
};

```

# portable-devices/desktop/src/main/utils/window/devTools.ts

```ts
/* eslint-disable global-require */
/* eslint-disable import/no-extraneous-dependencies */
import { app } from 'electron';
import { dev } from 'electron-is';
import { logger } from '../logger';

/**
 * Load plug-in and developer tool window
 */
export const loadDevTools = () => {
    if (!(dev() || process.env.DEBUG === '1')) return;

    app.whenReady().then(() => {
        const {
            default: installExtension,

            // React Dev tools cannot be repaired temporarily (Electron version >= 9.0)
            // https://github.com/electron/electron/issues/23662
            // REACT_DEVELOPER_TOOLS
            REDUX_DEVTOOLS,
        } = require('electron-devtools-installer');

        const extensions = [
            // REACT_DEVELOPER_TOOLS,
            REDUX_DEVTOOLS,
        ];

        try {
            installExtension(extensions).then((name: string) => {
                logger.trace(`Added Extension: ${name}`);
            });
        } catch (e) {
            logger.error('An error occurred: ', e);
        }
    });
};

```

# portable-devices/desktop/src/main/utils/sqlite/connection.ts

```ts
import { app } from 'electron';
import type { ConnectionOptions, EntityTarget } from 'typeorm';
import { createConnection, getConnection } from 'typeorm';
import path from 'path';
import { User } from '../../models';
import { getLogger } from '../logger';
import { isDev, isTest } from '../../../common';

const entities = [User];
// Database storage address
const storagePath = app.getPath('userData');

const connectConfig: ConnectionOptions = {
    type: 'sqlite',
    entities,
    database:
        // In-memory database under test
        /* istanbul ignore next */
        isTest ? ':memory:' : path.join(storagePath, 'database', `${isDev ? 'electron-template' : 'db'}.sqlite`),
};

/**
 * Get database link
 */
export const getDBConnection = async () => {
    const logger = getLogger('database');
    try {
        logger.info('Connect to the database...');
        const connection = await createConnection(connectConfig);
        logger.info('connection succeeded!');

        // A synchronization of the database is equivalent to initializing various tables
        // Otherwise it will report QueryFailedError: SQLITE_ERROR: no such table: User error
        await connection.synchronize();

        return connection;
    } catch (err) {
        logger.error('Database initialization failed, error message:');
        logger.error(err);
        return undefined;
    }
};

/**
 * Get a certain warehouse value
 * @param entity
 */
export function getRepository<T>(entity: EntityTarget<T>) {
    const conn = getConnection();
    return conn.getRepository(entity);
}

```

# portable-devices/desktop/src/main/utils/logger/logDecorator.ts

```ts
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/ban-types */
import { CdmLogger } from '@cdm-logger/core';
import { logger } from './customLogger';

interface LogParams {
    message: string;
    scope: any;
    level: CdmLogger.LoggerLevel;
}

const log = (propertyName: string, params: string | LogParams) => {
    // If it is plain text, output directly
    if (typeof params === 'string') {
        logger.info(`(${propertyName}) ${params}`);
    } else {
        // If it is an object, three parameters must be passed in and then output
        const { level, message, scope } = params;
        logger[`${level}`](`(${scope || propertyName}) ${message}`);
    }
};

/**
 * Call log before execution
 */
export const logBefore =
    (params: string | LogParams) => (target: Object, propertyName: string, descriptor: PropertyDescriptor) => {
        const method = descriptor.value;
        // Require, in order to work with decorator
        // eslint-disable-next-line func-names,no-param-reassign
        descriptor.value = function (...args: any[]) {
            log('main', params);
            return method.apply(this, args);
        };
    };

/**
 * Call log after execution
 * @param params
 */
export const logAfter =
    (params: string | LogParams) => (target: Object, propertyName: string, descriptor: PropertyDescriptor) => {
        const method = descriptor.value;
        // Require, in order to work with decorator
        // eslint-disable-next-line func-names,no-param-reassign
        descriptor.value = function (...args: any[]) {
            try {
                return method.apply(this, args);
            } finally {
                log('main', params);
            }
        };
    };

```

# portable-devices/desktop/src/main/utils/logger/index.ts

```ts
export * from './customLogger';
export * from './logDecorator';

```

# portable-devices/desktop/src/main/utils/logger/customLogger.ts

```ts
import { getLogger as createLogger } from '@cdm-logger/electron';
import { ConsoleLogger } from '@cdm-logger/server';
import { isDev } from '../../../common';

const logger = isDev ? ConsoleLogger.create('main') : createLogger('log');
logger.divider = (str = '-', length = 10) => {
    let line = '';
    for (let i = 0; i < length; i += 1) {
        line += str;
    }
    logger.info(line);
};
export { logger };
export const getLogger = (name) => logger.child({ className: name });

```

# packages-modules/counter/mobile/src/connected-react-router/redux/index.ts

```ts
export * from './actions';
export * from './reducers';

```

# packages-modules/counter/mobile/src/connected-react-router/interfaces/state.ts

```ts
import { RouterState } from 'connected-react-router';

export interface State {
    connectedReactRouterCounter: number;
    router: RouterState;
}

```

# packages-modules/counter/mobile/src/connected-react-router/interfaces/index.ts

```ts
export * from './state';

```

# packages-modules/counter/mobile/src/connected-react-router/constants/routes-types.ts

```ts
export enum CONNECTED_REACT_ROUTER_ROUTES_TYPES {
    HOME = '/org',
    HELLO = '/org/hello',
    COUNTER = '/org/counter',
}

```

# packages-modules/counter/mobile/src/connected-react-router/constants/index.ts

```ts
export * from './action-types';
export * from './routes-types';

```

# packages-modules/counter/mobile/src/connected-react-router/constants/action-types.ts

```ts
export const enum CONNECTED_REACT_ROUTER_ACTION_TYPES {
    INCREMENT = '@connected-react-router/INCREMENT',
    DECREMENT = '@connected-react-router/DECREMENT',
}

```

# packages-modules/counter/mobile/src/connected-react-router/components/Hello.tsx

```tsx
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
import * as React from 'react';
import { StyleSheet, View, Text, ViewStyle } from 'react-native';
import {  Box } from 'native-base';
import { connect } from 'react-redux';

interface Style {
    container: ViewStyle;
}

const HelloScreen = () => {
    return (
        <View style={styles.container}>
            <Box>
                <Text>Hello Value</Text>
            </Box>
            <Box style={{ position: 'absolute', left: 0, right: 0, bottom: 0 }}>
                <View>
                    <Text>Footer will be here</Text>
                </View>
            </Box>
        </View>
    );
};

const styles = StyleSheet.create<Style>({
    container: {
        flex: 1,
        textAlign: 'center',
    },
});

export const Hello = connect((state: any) => {
    return {
        settings: state.settings,
        location: state?.route?.location,
    };
})(HelloScreen);

```

# packages-modules/counter/mobile/src/connected-react-router/components/Counter.tsx

```tsx
import * as React from 'react';
import { Button, View, Text } from 'react-native';
import { Dispatch } from 'redux';
import { connect } from 'react-redux';
import { increment, decrement } from '../redux';
import { State } from '../interfaces';

interface CounterStateProps {
    count: number;
}

interface CounterDispatchProps {
    increment: () => void;
    decrement: () => void;
}

const CounterScreen: React.SFC<CounterStateProps & CounterDispatchProps> = (props) => {
    return (
        <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
            <View style={{ marginTop: 20 }}>
                <View style={{ marginBottom: 20 }}>
                    <Text>Counter value: {props.count}</Text>
                </View>

                <Button onPress={props.increment} title="Increment Counter" />

                <View style={{ marginTop: 10 }}>
                    <Button onPress={props.decrement} title="Decrement Counter" />
                </View>
            </View>
        </View>
    );
};

const mapStateToProps = (state: State) => ({
    count: state.connectedReactRouterCounter,
});

const mapDispatchToProps = (dispatch: Dispatch) => ({
    increment: () => dispatch(increment()),
    decrement: () => dispatch(decrement()),
});

export const Counter = connect<CounterStateProps, CounterDispatchProps>(
    mapStateToProps as any,
    mapDispatchToProps,
)(CounterScreen);

```

# packages-modules/counter/mobile/src/common/interfaces/context.ts

```ts
import { DataProxy } from '@apollo/client/cache';
import { ApolloClient } from '@apollo/client';

export interface MyContext {
    cache: DataProxy;
    getCacheKey: (options: { __typename: string; resource?: string; id?: string }) => string;
    apolloClient: ApolloClient<any>;
}

```

# packages-modules/counter/mobile/src/common/components/Home.tsx

```tsx
import * as React from 'react';

export const Home = () => (
    <div>
        <h1>FullStack-Pro</h1>
    </div>
);

```

# packages-modules/counter/mobile/src/common/components/Dashboard.tsx

```tsx
import * as React from 'react';
import { renderRoutes } from 'react-router-config';

export const Dashboard = (props) =>  <>{renderRoutes(props.route.routes, { matchPath: props.route.path })}</>;

```

# packages-modules/counter/browser/src/fela/interfaces/theme.ts

```ts
export interface Theme {
    color: {
        primary: string;
        secondary: string;
        additional: string;
    };
}

```

# packages-modules/counter/browser/src/fela/interfaces/index.ts

```ts
export * from './theme';

```

# packages-modules/counter/browser/src/fela/components/index.ts

```ts
export * from './ComplexComponent';

```

# packages-modules/counter/browser/src/fela/components/ComplexComponent.tsx

```tsx
import * as React from 'react';
import { connect, FelaWithStylesProps, Rules } from 'react-fela';
import { Theme } from '../interfaces';


interface OwnProps {
    fontScale: number;
}

interface Styles {
    container: any;
    firstSection: any;
    secondSection: any;
    thirdSection: any;
}

type Props = OwnProps & FelaWithStylesProps<OwnProps, Styles, Theme>;

const ComplexComponent: React.FunctionComponent<Props> = props => {
    const { styles, rules, theme } = props;

    return (
        <div>
            <div className={styles.container}>
            <div className={styles.firstSection}>First Section</div>
            <div className={styles.secondSection}>Second Section</div>
            <div className={styles.thirdSection}>Third Section</div>
            </div>
            <div>
                <h3>Rules</h3>
                {Object.entries(rules)
                .map(([key, rule]) => (
                    <div key={key}>
                    {`${key}: ${JSON.stringify(rule(props))}`}
                    </div>
                ))}
            </div>
            <div>
                <h3>Theme</h3>
                {JSON.stringify(theme)}
            </div>
        </div>

    );
};

const complexComponentStyle: Rules<OwnProps, Styles, Theme> = ({fontScale, theme}) => ({
    container: {
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
    },
    firstSection: ({ theme }) => ({
        backgroundColor: theme.color.primary,
        fontSize: `{5 * fontScale}px`,
    }),
    secondSection: {
        backgroundColor: theme.color.secondary,
        fontSize: `${7 * fontScale}px`,
    },
    thirdSection: {
        backgroundColor: theme.color.additional,
        fontSize: `${10 * fontScale}px`,
    },
});

export const Complex = connect(complexComponentStyle)(ComplexComponent);




```

# packages-modules/counter/browser/src/fela/components/CompledWithTheme.tsx

```tsx
import * as React from 'react';


import { ThemeProvider } from 'react-fela';
import { Complex } from './ComplexComponent';
import { theme } from '../theme';


const extendStyles = {
    container: {
        borderColor: 'black',
        borderRadius: '10px',
        borderStyle: 'solid',
    },
};


export const ComplexWithTheme: React.FunctionComponent<{}> = props => {


    return (
        <ThemeProvider theme={theme}>
            <Complex fontScale={10} extend={extendStyles} />
        </ThemeProvider>
    );

};

```

# packages-modules/counter/browser/src/connected-react-router/redux/index.ts

```ts
export * from './actions';
export * from './reducers';

```

# packages-modules/counter/browser/src/connected-react-router/interfaces/state.ts

```ts
import { RouterState } from 'connected-react-router';

export interface State {
    connectedReactRouterCounter: number;
    router: RouterState;
}

```

# packages-modules/counter/browser/src/connected-react-router/interfaces/index.ts

```ts
export * from './state';

```

# packages-modules/counter/browser/src/connected-react-router/constants/routes-types.ts

```ts
export enum CONNECTED_REACT_ROUTER_ROUTES_TYPES {
    ROOT = '/',
    HOME = '/connected-react-router',
    HELLO = '/connected-react-router/hello',
    COUNTER = '/connected-react-router/counter',
}

```

# packages-modules/counter/browser/src/connected-react-router/constants/index.ts

```ts
export * from './action-types';
export * from './routes-types';

```

# packages-modules/counter/browser/src/connected-react-router/constants/action-types.ts

```ts
export const enum CONNECTED_REACT_ROUTER_ACTION_TYPES {
    INCREMENT = '@connected-react-router/INCREMENT',
    DECREMENT = '@connected-react-router/DECREMENT',
}

```

# packages-modules/counter/browser/src/connected-react-router/components/NoMatch.tsx

```tsx
import * as React from 'react';

const NoMatch = () => (
  <div>
    No Match
  </div>
);

export default NoMatch;

```

# packages-modules/counter/browser/src/connected-react-router/components/NavBar.tsx

```tsx
import * as React from 'react';
import { Counter } from './Counter';

const NavBar = () => (
    <div>
        <Counter/>
    </div>
);

export default NavBar;

```

# packages-modules/counter/browser/src/connected-react-router/components/Home.tsx

```tsx
import * as React from 'react';

const Home = () => (
    <div>
        Home
  </div>
);

export { Home };

```

# packages-modules/counter/browser/src/connected-react-router/components/HelloChild.tsx

```tsx

import * as React from 'react';
import { connect } from 'react-redux';
import { Link } from 'react-router-dom';
import { State } from '../interfaces';
import { CONNECTED_REACT_ROUTER_ROUTES_TYPES } from '../constants';

interface HelloChildProps {
    pathname: string;
    search: string;
    hash: string;
}

const HelloChildComponent = ({ pathname, search, hash }: HelloChildProps) => (
    <div>
        Hello-Child
    <ul>
            <li><Link to={`${CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO}?color=Blue&size=40`}>with query string</Link></li>
            <li><Link to={`${CONNECTED_REACT_ROUTER_ROUTES_TYPES.HELLO}#lovelove`}>with hash</Link></li>
        </ul>
        <div>
            pathname: {pathname}
        </div>
        <div>
            search: {search}
        </div>
        <div>
            hash: {hash}
        </div>
    </div>
);

const mapStateToProps = (state: State) => ({
    pathname: state.router.location.pathname,
    search: state.router.location.search,
    hash: state.router.location.hash,
});

export const HelloChild = connect(mapStateToProps)(HelloChildComponent);

```

# packages-modules/counter/browser/src/connected-react-router/components/Hello.tsx

```tsx
import * as React from 'react';
import { HelloChild } from './HelloChild';

const Hello = () => (
    <div>
        <div>Hello</div>
        <HelloChild />
    </div>
);

export { Hello };

```

# packages-modules/counter/browser/src/connected-react-router/components/Counter.tsx

```tsx
/* eslint-disable react/button-has-type */
import * as React from 'react';
import { Dispatch } from 'redux';
import { connect } from 'react-redux';
import { RouteComponentProps } from 'react-router';
import { increment, decrement } from '../redux';
import { State } from '../interfaces';

const CounterComponent: React.SFC<StateProps & DispatchProps> = (props) => (
    <div>
        Counter: {props.count}
        <button onClick={props.increment}>+</button>
        <button onClick={props.decrement}>-</button>
    </div>
);

interface StateProps {
    count: number;
}

interface DispatchProps {
    increment: () => void;
    decrement: () => void;
}

const mapStateToProps = (state: State) => ({
    count: state.connectedReactRouterCounter,
});

const mapDispatchToProps = (dispatch: Dispatch) => ({
    increment: () => dispatch(increment()),
    decrement: () => dispatch(decrement()),
});

export const Counter = connect<StateProps, DispatchProps>(
    mapStateToProps,
    mapDispatchToProps,
)(CounterComponent);

```

# packages-modules/counter/browser/src/connected-react-router/__tests__/connected-react-router-module.test.ts

```ts
import Module from '../module';

import 'jest';

describe('connector modules', () => {
    it('module configuredRoutes', () => {
        const configuredRoutes = Module.getConfiguredRoutes();

        expect(configuredRoutes).toMatchSnapshot();
    });

    it('module routes', () => {
        const routes = Module.getRoutes();

        expect(routes).toMatchSnapshot();
    });
});

```

# packages-modules/counter/browser/src/common/interfaces/context.ts

```ts
import { DataProxy } from '@apollo/client/cache';
import { ApolloClient } from '@apollo/client';

export interface MyContext {
    cache: DataProxy;
    getCacheKey: (options: { __typename: string; resource?: string; id?: string }) => string;
    apolloClient: ApolloClient<any>;
}

```

# packages-modules/counter/browser/src/common/components/Home.tsx

```tsx
import * as React from 'react';

export const Home = () => (
    <div>
        <h1>FullStack-Pro</h1>
    </div>
);

```

# packages-modules/counter/browser/src/common/components/Dashboard.tsx

```tsx
import * as React from 'react';
import { renderRoutes } from 'react-router-config';

export const Dashboard = (props) =>  <>{renderRoutes(props.route.routes, { matchPath: props.route.path })}</>;

```

# packages-modules/counter/browser/src/apollo-server-n-client/redux/index.ts

```ts
export * from './reducers';

```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/index.ts

```ts
export * from './resolvers';

```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/id-generation.ts

```ts
/**
 * All the unique identifier to be used when normilizing the data in the store.
 * Refer: https://www.apollographql.com/docs/angular/basics/caching#configuration
 * We define it as Object and use a helper method to convert.
 * ex: const dataIdFromObject = {
 *  'ICounter': (result) => result.__typename + ':' + result._id,
 * }
 */
export const dataIdFromObject = {};

```

# packages-modules/counter/browser/src/apollo-server-n-client/containers/Counter.tsx

```tsx
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/restrict-plus-operands */
import React, { useEffect } from 'react';
import update from 'immutability-helper';
import { useDispatch, useSelector } from 'react-redux';
import CounterView from '../components/CounterView';
import {
    useCounterQueryQuery,
    useAddCounterMutation,
    useAddCounterStateMutation,
    useCounterStateQuery,
    useAddCounter_WsMutation, 
    useSyncCachedCounterMutation, 
    useCounterCacheQueryLazyQuery
} from '../generated-model';
import {
    OnCounterUpdatedDocument,
} from '../../common/generated-models';

/**
 * 
 * @description Counter Component with Data dependency.
 */
const CounterWithApollo: React.SFC<any> = (props) => {
    const [addCounterMutation] = useAddCounterMutation();
    const { loading, error, data: counterData, subscribeToMore, } = useCounterQueryQuery();
    const [addCounterStateMutation] = useAddCounterStateMutation();
    const { data: couterStateData } = useCounterStateQuery();
    const dispatch = useDispatch();
    const reduxCount = useSelector(state => (state as any).counter.reduxCount);
    const [getCounter, { loading: getCounterLoading, data: cachedData }] = useCounterCacheQueryLazyQuery({ fetchPolicy: 'network-only' });
    const [addCounterWs] = useAddCounter_WsMutation();
    const [syncCachedCounter] = useSyncCachedCounterMutation();

    useEffect(() => {
        const unsubscribe = subscribeToMore(getSubscriptionOptions({}));
        return () => unsubscribe();
    }, [subscribeToMore]);

    const onReduxIncrement = (value) => () => {
        dispatch({
            type: 'COUNTER_INCREMENT',
            value: Number(value),
        });
    }
    const addCounter = (amount) => () => {
        addCounterMutation({
            variables: { amount },
            // Update the Cache of the Query that need to be display when it's dependent mutation gets called.
            // This is needed for two reasons
            // a). When update the Optimistically update cache, this get executes
            // b). When the mutation response from Server, this gets update.
            // Note: Optimistically update wont' work when network is offline.
            update: (cache, { data: { addCounter } }) => {
                // update the query's cache manually
                // recommend to be done using fields but it can be done directly updating the cache
                cache.modify({
                    fields: {
                        counter(prev) {
                            return { amount: addCounter.amount };
                        }
                    }
                })
            },
            // Optimistically update the amount to the locally cached
            // before the server responds
            // You can verify it by setting the "Network conditions" in devtools to `Slow 3G`.
            // You will see the data gets updated before the server responds.
            optimisticResponse: {
                // __typename: 'Mutation',
                addCounter: {
                    __typename: 'Counter',
                    amount: counterData?.counter.amount + amount,
                }
            }
        })
    }

    const addCounterState = (amount) => () => {
        addCounterStateMutation({
            variables: { amount }
        });
    }
    const getSubscriptionOptions = ({ }) => {
        return {
            document: OnCounterUpdatedDocument,
            variables: {},
            updateQuery: (prev,
                {
                    subscriptionData: {
                        data: {
                            counterUpdated: { amount },
                        },
                    }
                }) => {
                return update(prev, {
                    counter: {
                        amount: {
                            $set: amount,
                        },
                    },
                });
            }
        }
    }

    return <CounterView
        loading={loading}
        counter={counterData?.counter}
        counterState={couterStateData?.counterState?.counter}
        addCounter={addCounter}
        addCounterState={addCounterState}
        reduxCount={reduxCount}
        onReduxIncrement={onReduxIncrement}
        getCounterLoading={getCounterLoading}
        addCounterWs={addCounterWs}
        getCounter={getCounter}
        syncCachedCounter={syncCachedCounter}
        cachedData={cachedData}
    />
}

export default CounterWithApollo;
```

# packages-modules/counter/browser/src/apollo-server-n-client/components/CounterView.tsx

```tsx
import * as React from 'react';
import { Helmet } from 'react-helmet';


/**
 * @description Plain`CounterView` component without any data dependency.
 */
const CounterView = ({
  loading,
  counter,
  addCounter,
  counterState,
  addCounterState,
  onReduxIncrement,
  reduxCount,
  getCounterLoading,
  addCounterWs,
  getCounter,
  syncCachedCounter,
  cachedData,
}: any) => {

  const renderMetaData = () => (
    <Helmet>
      <title>Counter</title>
      <meta name="description" content="Counter example page" />
    </Helmet>
  );
  if (loading) {
    return (
      <div>
        {renderMetaData()}
        <div className="text-center">Loading Page...</div>
      </div>
    );
  } else {
  return (
    <div>
      {renderMetaData()}
      <section>
          <p>
            Current counter, is {counter.amount} and cached data. This is being stored
            server-side in the database and using Apollo subscription for
            real-time updates.
          </p>
          <button id="graphql-button" color="primary" onClick={addCounter(1)}>
            Click to increase counter
          </button>
          <button id="graphql-button" color="primary" onClick={() => addCounterWs({ variables: { amount: 1 } })}>
            Click to increase counter via websocket
          </button>
        </section>
      <section>
        <p>
          Get Counter Cache
            {getCounterLoading ? "Loading Counter Data..." : cachedData ? <span style={{ fontStyle: 'bold' }}> {cachedData.counterCache.amount}</span> : null}
          <br />
          <button id="get-cached-counter" onClick={() => getCounter()}>
            Click to get cached counter
            </button>
          <button id="sync-cached-counter" onClick={() => syncCachedCounter()}>
            Synch Counter with Cache
            </button>
        </p>
      </section>
      <section>
        <p>
          Current reduxCount, is {reduxCount}. This is being stored
            client-side with Redux.
          </p>
        <button
          id="redux-button"
          color="primary"
          onClick={onReduxIncrement(1)}
        >
          Click to increase reduxCount
          </button>
      </section>
      <section>
        <p>
          Current apolloLinkStateCount, is {counterState}. This is being
            stored client-side with Apollo Link State.
          </p>
        <button
          id="apollo-link-button"
          color="primary"
          onClick={addCounterState(1)}
        >
          Click to increase apolloLinkState
          </button>
      </section>
    </div>
  );
  }
};

export default CounterView;

```

# packages/sample-store/src/__tests__/db/seeds/counter.ts

```ts
import * as Knex from 'knex';

const initialAmount = 5;

export async function seed(knex: Knex) {
    await knex('count').truncate();

    return knex('count').insert({ amount: initialAmount });
}

```

# packages/sample-store/src/__tests__/db/migrations/counter.ts

```ts
import * as Knex from 'knex';

export async function up(knex: Knex) {
    return knex.schema.createTable('count', (table) => {
        table.increments();
        table.timestamps();
        table.integer('amount').notNullable();
    });
}

export async function down(knex: Knex) {
    return knex.schema.dropTable('count');
}

```

# packages/sample-platform/browser/src/redux/reducers/sampleReducers.ts

```ts
import { combineReducers, Action as reduxAction } from 'redux';
import { Action } from '../actions';
import { Store } from './Store';

function isSaving(state = false, action: Action): boolean {
    switch (action.type) {
        case '@@sample-stack/SAVE_COUNT_REQUEST':
            return true;
        case '@@sample-stack/SAVE_COUNT_SUCCESS':
        case '@@sample-stack/SAVE_COUNT_ERROR':
            return false;
        default:
            return state;
    }
}

function isLoading(state = false, action: Action): boolean {
    switch (action.type) {
        case '@@sample-stack/LOAD_COUNT_REQUEST':
            return true;
        case '@@sample-stack/LOAD_COUNT_SUCCESS':
        case '@@sample-stack/LOAD_COUNT_ERROR':
            return false;
        default:
            return state;
    }
}

function error(state = '', action: Action): string {
    switch (action.type) {
        case '@@sample-stack/LOAD_COUNT_REQUEST':
        case '@@sample-stack/SAVE_COUNT_REQUEST':
            return '';
        case '@@sample-stack/LOAD_COUNT_ERROR':
        case '@@sample-stack/SAVE_COUNT_ERROR':
            return action.error.toString();
        default:
            return state;
    }
}

const initialState: Store.Counter = {
    value: 0,
};

function counter(
    state: Store.Counter = initialState,
    action: Action,
): Store.Counter {
    switch (action.type) {
        case '@@sample-stack/INCREMENT_COUNTER':
            const { delta } = action;
            return { value: state.value + delta };

        case '@@sample-stack/RESET_COUNTER':
            return { value: 0 };

        case '@@sample-stack/LOAD_COUNT_SUCCESS':
            return { value: action.response.value };

        default:
            return state;
    }
}

export const reducers = {
    '@sample-stack/counter': counter,
    '@sample-stack/isSaving': isSaving,
    '@sample-stack/isLoading': isLoading,
    '@sample-stack/error': error,
};

```

# packages/sample-platform/browser/src/redux/reducers/index.ts

```ts
import { reducers as sampleReducers } from './sampleReducers';

export { Store } from './Store';

export const reducers = {
    ...sampleReducers,
};

```

# packages/sample-platform/browser/src/redux/reducers/Store.ts

```ts
export namespace Store {
    export type Counter = { value: number };

    export type Sample = {
        '@sample-stack/counter': Counter;
        '@sample-stack/isSaving': boolean;
        '@sample-stack/isLoading': boolean;
        '@sample-stack/error': string;
    };
}

```

# packages/sample-platform/browser/src/redux/actions/sampleActions.ts

```ts
import * as redux from 'redux';

import { api } from '../../api';
import { Store } from '../reducers/index';

export type Q<T> = { request: T };
export type S<T> = { response: T };
export type E = { error: Error };

export type QEmpty = Q<null>;
export type QValue = Q<{ value: number }>;

export type Action =
    // UI actions
    | { type: '@@sample-stack/INCREMENT_COUNTER'; delta: number }
    | { type: '@@sample-stack/RESET_COUNTER' }

    // API Requests
    | ({ type: '@@sample-stack/SAVE_COUNT_REQUEST' } & QValue)
    | ({ type: '@@sample-stack/SAVE_COUNT_SUCCESS' } & QValue & S<{}>)
    | ({ type: '@@sample-stack/SAVE_COUNT_ERROR' } & QValue & E)
    | ({ type: '@@sample-stack/LOAD_COUNT_REQUEST' } & QEmpty)
    | ({ type: '@@sample-stack/LOAD_COUNT_SUCCESS' } & QEmpty &
          S<{ value: number }>)
    | ({ type: '@@sample-stack/LOAD_COUNT_ERROR' } & QEmpty & E);

export const incrementCounter = (delta: number): Action => ({
    type: '@@sample-stack/INCREMENT_COUNTER',
    delta,
});

export const resetCounter = (): Action => ({
    type: '@@sample-stack/RESET_COUNTER',
});

export type ApiActionGroup<_Q, _S> = {
    request: (q?: _Q) => Action & Q<_Q>;
    success: (s: _S, q?: _Q) => Action & Q<_Q> & S<_S>;
    error: (e: Error, q?: _Q) => Action & Q<_Q> & E;
};

const _saveCount: ApiActionGroup<{ value: number }, {}> = {
    request: (request) => ({
        type: '@@sample-stack/SAVE_COUNT_REQUEST',
        request,
    }),
    success: (response, request) => ({
        type: '@@sample-stack/SAVE_COUNT_SUCCESS',
        request,
        response,
    }),
    error: (error, request) => ({
        type: '@@sample-stack/SAVE_COUNT_ERROR',
        request,
        error,
    }),
};

const _loadCount: ApiActionGroup<null, { value: number }> = {
    request: (request) => ({
        type: '@@sample-stack/LOAD_COUNT_REQUEST',
        request: null,
    }),
    success: (response, request) => ({
        type: '@@sample-stack/LOAD_COUNT_SUCCESS',
        request: null,
        response,
    }),
    error: (error, request) => ({
        type: '@@sample-stack/LOAD_COUNT_ERROR',
        request: null,
        error,
    }),
};

type apiFunc<Q, S> = (q: Q) => Promise<S>;

function apiActionGroupFactory<Q, S>(
    x: ApiActionGroup<Q, S>,
    go: apiFunc<Q, S>,
) {
    return (request: Q) => (dispatch: redux.Dispatch) => {
        dispatch(x.request(request));
        go(request)
            .then((response) => dispatch(x.success(response, request)))
            .catch((e: Error) => dispatch(x.error(e, request)));
    };
}

export const saveCount = apiActionGroupFactory(_saveCount, api.save);
export const loadCount = apiActionGroupFactory(_loadCount, api.load);

```

# packages/sample-platform/browser/src/redux/actions/index.ts

```ts
export * from './sampleActions';

```

# packages/sample-platform/browser/src/redux/__mocks__/api.ts

```ts
export const api = {
    save: jest.fn(),
    load: jest.fn(),
};

```

# packages/sample-platform/browser/src/graphql/subscriptions/index.ts

```ts
export const COUNT_SUBSCRIPTION = require('./count');

```

# packages/sample-platform/browser/src/graphql/subscriptions/count.graphql

```graphql
subscription subscribeToCount{
  subscribeToCount {
        amount
    }
}

```

# packages/sample-platform/browser/src/graphql/queries/persons.graphql

```graphql
query getPersons {
    persons {
        id
        name
    }
}
```

# packages/sample-platform/browser/src/graphql/queries/person.graphql

```graphql
query getPerson($id: String!){
    getPerson(id: $id) {
        id
        name
        sex
        matches {
            id
            name
            sex
            matches {
                id
                name
                sex
                matches {
                    id
                    name
                    sex
                }
            }
        }
    }
}
```

# packages/sample-platform/browser/src/graphql/queries/index.ts

```ts
export const PERSON_QUERY = require('./person');
export const PERSONS_QUERY = require('./persons');
export const COUNT_QUERY = require('./count');

```

# packages/sample-platform/browser/src/graphql/queries/count.graphql

```graphql
query getCount {
    count {
        amount
    }
}
```

# packages/sample-platform/browser/src/graphql/mutations/index.ts

```ts
export const ADD_PERSON_MUTATION = require('./addPerson');
export const ADD_COUNT_MUTATION = require('./addCount');

```

# packages/sample-platform/browser/src/graphql/mutations/addPerson.graphql

```graphql
mutation addPerson($name: String!, $sex: String!) {
    addPerson(name: $name, sex: $sex) {
        id
        name
    }
}
```

# packages/sample-platform/browser/src/graphql/mutations/addCount.graphql

```graphql
mutation addCount($amount: Int!) {
    addCount(amount: $amount) {
        amount
    }
}
```

# packages/sample-platform/browser/src/containers/__tests__/utils.ts

```ts
/**
 * Call this helper inside async test to let promises finish, because they are allways async.
 */
export const nextTick = () =>
    new Promise((resolve) => setTimeout(resolve, 200));

```

# packages/sample-platform/browser/src/containers/__tests__/setup.ts

```ts
/* setup.js */

const { jsdom } = require('jsdom');

const exposedProperties = ['window', 'navigator', 'document'];

(<any>global).document = jsdom('');
(<any>global).window = document.defaultView;
Object.keys(document.defaultView).forEach((property) => {
    if (typeof global[property] === 'undefined') {
        exposedProperties.push(property);
        global[property] = document.defaultView[property];
    }
});

(<any>global).navigator = {
    userAgent: 'node.js',
};

```

# packages/sample-platform/browser/src/containers/__tests__/redux.test.tsx

```tsx
// import * as React from 'react';
// import * as renderer from 'react-test-renderer';
// import { mount, shallow } from 'enzyme';
// import { createStore, combineReducers, applyMiddleware } from 'redux';
// import { connect } from 'react-redux';
// import { print } from 'graphql';
// import gql from 'graphql-tag';

// declare function require(name: string);

// import ApolloClient from 'apollo-client';
// import { ApolloProvider, graphql } from 'react-apollo';
// import { mockNetworkInterface } from 'react-apollo/test-utils';

// describe('redux integration', () => {
//     it('updates child props on state change', (done) => {
//         const query = gql`query people($first: Int) { allPeople(first: $first) { people { name } } }`;
//         const data = { allPeople: { people: [{ name: 'Luke Skywalker' }] } };
//         const variables = { first: 1 };

//         const data2 = { allPeople: { people: [{ name: 'Leia Skywalker' }] } };
//         const variables2 = { first: 2 };

//         const networkInterface = mockNetworkInterface(
//             { request: { query, variables }, result: { data } },
//             { request: { query, variables: variables2 }, result: { data: data2 } },
//         );


//         const client = new ApolloClient({ networkInterface, addTypename: false });
//         let wrapper;

//         function counter(state = 1, action) {
//             switch (action.type) {
//                 case 'INCREMENT':
//                     return state + 1;
//                 default:
//                     return state;
//             }
//         }

//         // Typscript workaround
//         const apolloReducer = client.reducer() as () => any;

//         const store = createStore(
//             combineReducers({
//                 counter,
//                 apollo: apolloReducer,
//             }),
//             applyMiddleware(client.middleware()),
//         );


//         class Component extends React.Component<any, any> {
//             public componentWillReceiveProps(nextProps) {
//                 // trigger redux action
//                 if (nextProps.first === 1) {
//                     this.props.dispatch({ type: 'INCREMENT' });
//                 }

//                 if (nextProps.first === 2) {
//                     if (nextProps.data.loading) { return; }
//                     expect(nextProps.data.allPeople.people).toContain(data2.allPeople.people);
//                     done();
//                 }

//             }
//             public render() {
//                 return null;
//             }
//         }
//         const Container: React.ComponentClass<{}> = compose(
//             connect((state) => ({ first: state.counter })),
//             graphql(query),
//             flattenProp('data'),
//             pure,
//         )(Component);

//         wrapper = renderer.create(
//             <ApolloProvider client={client} store={store}>
//                 <Container />
//             </ApolloProvider>,
//         );
//     });

// });

```

# packages/sample-platform/browser/src/containers/__tests__/PersonList.test.tsx

```tsx
// import 'jest';
// import * as React from 'react';
// import { shallow, mount } from 'enzyme';
// import ApolloClient from 'apollo-client';
// import { MockedProvider } from 'react-apollo/test-utils';
// import './setup';

// declare function require(name: string);
// import * as TestUtils from 'react-addons-test-utils';
// import { createStore, combineReducers, applyMiddleware } from 'redux';
// import gql from 'graphql-tag';

// import { PersonList } from '../PersonList';
// import { reducers, Store } from '@sample-stack/platform-browser';
// import { ApolloProvider, graphql, createNetworkInterface } from 'react-apollo';
// import { database } from '@sample-stack/graphql-schema';
// import { mockNetworkInterface } from 'apollo-test-utils';
// import { PERSONS_QUERY } from '@sample-stack/platform-browser';

// describe('components/PersonList', () => {
//   it('renders correctly', (done) => {
//     const networkInterface = mockNetworkInterface({
//       request: { query: PERSONS_QUERY, variables: {} }, result: { data: database.persons },
//     });

//     const client = new ApolloClient({
//       networkInterface: networkInterface,
//     });


//     const store = createStore(combineReducers({
//       ...reducers,
//       apollo: client.reducer(),
//     }), applyMiddleware(client.middleware()));


//     expect(mount(
//       <ApolloProvider client={client} store={store}>
//         <PersonList />
//       </ApolloProvider>,
//     )).toMatchSnapshot();
//   });
// });

```

# packages/sample-platform/browser/src/containers/__tests__/Counter.test.tsx

```tsx
// import 'jest';
// import * as React from 'react';
// import { shallow, mount } from 'enzyme';
// import * as Sinon from 'sinon';
// import * as TestUtils from 'react-dom/test-utils';
// import { createStore, combineReducers } from 'redux';
// import configureStore from 'redux-mock-store';
// import { Counter } from '../Counter';
// import { reducers, Store } from '@sample-stack/platform-browser';
// import { Provider } from 'react-redux';
// import './setup';


// describe('components/Counter', () => {
//   it('renders', () => {
//     const store: any = createStore(combineReducers<Store.Sample>(reducers));

//     expect(shallow(
//       <Counter label="a counter!" store={store} />,
//     ).shallow()).toMatchSnapshot();
//   });

//   describe('COUNTER --- react-redux clicking "increment"', () => {
//     let counter;
//     let store;

//     beforeEach(() => {
//       store = createStore(combineReducers(reducers));
//       counter = mount(
//         <Provider store={store}>
//           <Counter label="a counter!'" />
//         </Provider>,
//       );
//     });


//     it('+++ check Props after increments counter', () => {
//       const increment = counter.find('button').first();
//       increment.simulate('click');
//       increment.simulate('click');
//       increment.simulate('click');


//       const getText = () => counter.find('pre').text();
//       expect(JSON.parse(getText()).counter.value).toBe(3);

//     });
//   });
// });

```

# packages/sample-platform/browser/src/containers/__tests__/ApolloProvider.test.tsx

```tsx
// import * as React from 'react';
// import { shallow } from 'enzyme';
// import { createStore } from 'redux';
// import * as PropTypes from 'prop-types';

// declare function require(name: string);
// import * as TestUtils from 'react-addons-test-utils';

// import ApolloClient from 'apollo-client';
// import { ApolloProvider } from 'react-apollo';
// import { InMemoryCache } from 'apollo-cache-inmemory';
// import { ApolloLink, Observable } from 'apollo-link';
// import { addTypenameToDocument } from 'apollo-utilities';

// interface ChildContext {
//     store: Object;
//     client: Object;
// }

// describe('<ApolloProvider /> Component', () => {

//     class Child extends React.Component<any, { store: any, client: any }> {
//         public static contextTypes: React.ValidationMap<any> = {
//             client: PropTypes.object.isRequired,
//             store: PropTypes.object.isRequired,
//         };

//         public context: ChildContext;

//         public render() {
//             return <div />;
//         }
//     }

//     const cache = new InMemoryCache();
//     const client = new ApolloClient();
//     const store = createStore(() => ({}));

//     it('should render children components', () => {
//         const wrapper = shallow(
//             <ApolloProvider store={store} client={client}>
//                 <div className="unique" />
//             </ApolloProvider>,
//         );

//         expect(wrapper.contains(<div className="unique" />)).toBe(true);
//     });
// });

```

# tools/templates/module/browser/src/locales/ru/translations.json

```json
{
    "navLink": "$Module$ ссылка",
    "title": "$Module$ модуль",
    "meta": "$Module$ пример",
    "welcomeText": "Привет, это $Module$ модуль"
}
```

# tools/templates/module/browser/src/locales/en/translations.json

```json
{
    "navLink": "$Module$ nav link",
    "title": "$Module$ module",
    "meta": "$Module$ example",
    "welcomeText": "Hello, This is the $Module$ module"
}
```

# tools/templates/module/browser/src/graphql/queries/module-query.gql

```gql
# GraphQL queries
query queryNameQuery {
  queryName {
    typename
  }
}
```

# tools/templates/module/browser/src/graphql/queries/index.ts

```ts
import * as ModuleQuery from './module-query';

```

# tools/templates/module/browser/src/graphql/mutations/index.ts

```ts

```

# tools/templates/module/browser/src/graphql/link/index.ts

```ts

```

# portable-devices/desktop/src/renderer/components/layout/components/index.ts

```ts
export * from './SideMenu';

```

# portable-devices/desktop/src/renderer/components/layout/components/SideMenu.tsx

```tsx
import * as H from 'history';
import * as React from 'react';
import { Link } from 'react-router-dom';
import * as PropTypes from 'prop-types';
import pathToRegexp from 'path-to-regexp';
import { Layout, Menu, Avatar } from 'antd';
import { IMenuPosition } from '@common-stack/client-react';

const { Sider } = Layout;
const { SubMenu } = Menu;

export function urlToList(url) {
    const urllist = url.split('/').filter((i) => i);
    return urllist.map((urlItem, index) => {
        return `/${urllist.slice(0, index + 1).join('/')}`;
    });
}

const getImageUrl = (picture) => {
    return picture || "data:image/png;base64,${new Identicon(Base64.encode('myawsomestringbebe'), 420).toString()}";
};

/**
 * Recursively flatten  the data
 * [{path: string}, {path: string}] => {path, path2}
 * @param menu
 */
export const getFlatMenuKeys = (menu) =>
    menu.reduce((keys, item) => {
        keys.push(item.path);
        if (item.children) {
            return keys.concat(getFlatMenuKeys(item.children));
        }
        return keys;
    }, []);

/**
 * Find all matched menu keys based on paths
 * @param flatMenuKeys: [/abc, /abc/:id, /abc/:id/info]
 * @param paths: [/abc/ /abc/11, /abc/11/info]
 */
export const getMenuMatchKeys = (flatMenuKeys, paths) =>
    paths.reduce(
        (matchKeys, path) => matchKeys.concat(flatMenuKeys.filter((item) => pathToRegexp(item).test(path))),
        [],
    );

export namespace ISiderMenu {
    export interface CompProps {
        menuData: any;
        segments: any;
        onCollapse?: any;
        state?: boolean;
        isMobile?: boolean;
        renderer?: any;
        Authorized?: any;
        collapsed?: boolean;
        logo?: any;
        user?: any;
        styles?: {
            grow?: any;
            logo?: any;
            sider?: any;
            icon?: any;
        };
    }

    export interface StateProps {
        location: H.Location;
    }

    export interface CompState {
        openKeys?: any;
    }

    export type Props = CompProps & StateProps;
    export type State = CompState;
}
export class SiderMenu extends React.PureComponent<ISiderMenu.Props, ISiderMenu.State> {
    private menus;

    private flatMenuKeys;

    constructor(props) {
        super(props);
        this.menus = props.menuData;
        this.flatMenuKeys = getFlatMenuKeys(props.menuData);
        this.state = {
            openKeys: this.getDefaultCollapsedSubMenus(props),
        };
    }

    public static contextTypes = {
        renderer: PropTypes.any.isRequired,
    };

    public static defaultProps() {
        return {
            user: {},
            isMobile: false,
        };
    }

    public UNSAFE_componentWillReceiveProps(nextProps) {
        if (nextProps.location.pathname !== this.props.location.pathname) {
            this.setState({
                openKeys: this.getDefaultCollapsedSubMenus(nextProps),
            });
        }
    }

    /**
     * Convert pathname to openKeys
     * /list/search/articles => ['list', '/list/search']
     * @param props
     */
    public getDefaultCollapsedSubMenus(props) {
        const {
            location: { pathname },
        } = props || this.props;
        return getMenuMatchKeys(this.flatMenuKeys, urlToList(pathname));
    }

    /**
     * Allow menu.js config icon as string or ReactNode
     * icon: 'setting',
     * icon: 'http://demo.com/icon.png',
     * icon: <Icon type="setting" />,
     * @param icon
     */
    private getIcon(icon) {
        const { styles = {} } = this.props;
        if (typeof icon === 'string' && icon.indexOf('http') === 0) {
            return <img src={icon} alt="icon" className={styles.icon} />;
        }
        if (typeof icon === 'string') {
            return <div data-type={icon} style={styles.icon} />;
        }
        return icon;
    }

    private getAvatar(menu) {
        const { styles = {}, user } = this.props;
        return (
            <span data-user={user.nickname} id={!user || user.isTest ? `cde-user-placeholder` : 'cde-user'}>
                <div style={{ marginRight: '7px' }} data-src={getImageUrl(user.picture)}>
                    {user.nickname || 'Guest'}
                </div>{' '}
                <span> {user.nickname || 'Guest'}</span>
            </span>
        );
    }

    /**
     * Judge whether it is http link.return or a Link
     * @memberOf SiderMenu
     */
    private getMenuItemPath = (item) => {
        const { styles = {} } = this.props;
        const itemPath = this.conversionPath(item.path);
        const icon = this.getIcon(item.icon);
        const { target, name } = item;
        // Is it a http link
        if (/^https?:\/\//.test(itemPath)) {
            return (
                <a href={itemPath} target={target}>
                    {icon}
                    <span>{name}</span>
                </a>
            );
        }
        return (
            <Link
                to={itemPath}
                target={target}
                replace={itemPath === this.props.location.pathname}
                onClick={
                    this.props.isMobile
                        ? () => {
                              this.props.onCollapse(true);
                          }
                        : undefined
                }
            >
                {icon}
                <span>{name}</span>
            </Link>
        );
    };

    /**
     * get SubMenu or Item
     */
    private getSubMenuOrItem = (item) => {
        const { styles = {} } = this.props;
        if (item.children && item.children.some((child) => child.name)) {
            const childrenItems = this.getNavMenuItems(item.children);
            if (childrenItems && childrenItems.length > 0) {
                return (
                    <SubMenu title={item.name} key={item.path}>
                        {childrenItems}
                    </SubMenu>
                );
            }
            return null;
        }
        return <Menu.Item key={item.path}>{this.getMenuItemPath(item)}</Menu.Item>;
    };

    /**
     * @memberof SiderMenu
     */
    private getNavMenuItems = (menusData) => {
        if (!menusData) {
            return [];
        }
        return menusData
            .filter((item) => item.name && !item.hideInMenu)
            .map((item) => {
                // make dom
                const ItemDom = this.getSubMenuOrItem(item);
                return this.checkPermissionItem(item.authority, ItemDom);
            })
            .filter((item) => item);
    };

    /**
     * Generates LOGO
     * @memberof SiderMenu
     */
    private getLogo(logo) {
        const { styles = {} } = this.props;
        return (
            logo && (
                <div className={styles.logo} key="logo">
                    <Link to="/">
                        <img src={logo.icon} alt="logo" />
                        <h1>{logo.name}</h1>
                    </Link>
                </div>
            )
        );
    }

    // Get the currently selected menu
    private getSelectedMenuKeys = () => {
        const {
            location: { pathname },
        } = this.props;
        return getMenuMatchKeys(this.flatMenuKeys, urlToList(pathname));
    };

    // conversion Path
    private conversionPath = (path) => {
        if (path && path.indexOf('http') === 0) {
            return path;
        }
        return `/${path || ''}`.replace(/\/+/g, '/');
    };

    // permission to check
    private checkPermissionItem = (authority, ItemDom) => {
        if (this.props.Authorized && this.props.Authorized.check) {
            const { check } = this.props.Authorized;
            return check(authority, ItemDom);
        }
        return ItemDom;
    };

    private isMainMenu = (key) => {
        return this.menus.some((item) => key && (item.key === key || item.path === key));
    };

    private handleOpenChange = (openKeys) => {
        const lastOpenKey = openKeys[openKeys.length - 1];
        const moreThanOne = openKeys.filter((openKey) => this.isMainMenu(openKey)).length > 1;
        this.setState({
            openKeys: moreThanOne ? [lastOpenKey] : [...openKeys],
        });
    };

    public render() {
        const { renderer } = this.context;
        const { logo, collapsed, segments = [], onCollapse, styles = {} } = this.props;
        const { openKeys } = this.state;
        // Don't show popup menu when it is been collapsed
        const menuProps = collapsed ? {} : { openKeys };
        // If pathname can't match, use the nearest parent's key
        let selectedKeys = this.getSelectedMenuKeys();
        if (!selectedKeys.length) {
            selectedKeys = [openKeys[openKeys.length - 1]];
        }

        return (
            <Sider
                trigger={null}
                collapsible
                collapsed={collapsed}
                breakpoint="lg"
                onCollapse={onCollapse}
                width={256}
                className={styles.sider}
            >
                {this.getLogo((this.menus.filter((menu) => menu.position === IMenuPosition.LOGO) || [])[0])}
                <div className={styles.grow}>
                    <Menu
                        key="Menu-Middle"
                        theme="dark"
                        mode="inline"
                        {...menuProps}
                        className={styles.grow}
                        onOpenChange={this.handleOpenChange}
                        selectedKeys={selectedKeys}
                        style={{ padding: '16px 0', width: '100%' }}
                    >
                        {this.getNavMenuItems(this.menus.filter((menu) => menu.position === IMenuPosition.MIDDLE))}
                    </Menu>
                    {segments.map((segment, segmentIndex) => (
                        <div key={segmentIndex}>{React.cloneElement(segment, { collapsed })}</div>
                    ))}
                </div>
                <Menu
                    key="Menu-Bottom"
                    theme="dark"
                    mode="inline"
                    {...menuProps}
                    onOpenChange={this.handleOpenChange}
                    selectedKeys={selectedKeys}
                    style={{ padding: '16px 0', width: '100%' }}
                >
                    {this.getNavMenuItems(this.menus.filter((menu) => menu.position === IMenuPosition.BOTTOM))}
                </Menu>
            </Sider>
        );
    }
}

```

# packages-modules/counter/mobile/src/connected-react-router/redux/reducers/index.ts

```ts
export * from './counter';

```

# packages-modules/counter/mobile/src/connected-react-router/redux/reducers/counter.ts

```ts
import { Action } from 'redux';
import { CONNECTED_REACT_ROUTER_ACTION_TYPES } from '../../constants';

const connectedReactRouterCounter = (state = 0, action: Action) => {
    switch (action.type) {
        case CONNECTED_REACT_ROUTER_ACTION_TYPES.INCREMENT:
            return state + 1;
        case CONNECTED_REACT_ROUTER_ACTION_TYPES.DECREMENT:
            return state - 1;
        default:
            return state;
    }
};

export { connectedReactRouterCounter };

```

# packages-modules/counter/mobile/src/connected-react-router/redux/actions/index.ts

```ts
export * from './counter';

```

# packages-modules/counter/mobile/src/connected-react-router/redux/actions/counter.ts

```ts
import { CONNECTED_REACT_ROUTER_ACTION_TYPES } from '../../constants';

export const increment = () => ({
    type: CONNECTED_REACT_ROUTER_ACTION_TYPES.INCREMENT,
});

export const decrement = () => ({
    type: CONNECTED_REACT_ROUTER_ACTION_TYPES.DECREMENT,
});

```

# packages-modules/counter/browser/src/connected-react-router/redux/reducers/index.ts

```ts
export * from './counter';

```

# packages-modules/counter/browser/src/connected-react-router/redux/reducers/counter.ts

```ts
import { Action } from 'redux';
import { CONNECTED_REACT_ROUTER_ACTION_TYPES } from '../../constants';

const connectedReactRouterCounter = (state = 0, action: Action) => {
    switch (action.type) {
        case CONNECTED_REACT_ROUTER_ACTION_TYPES.INCREMENT:
            return state + 1;
        case CONNECTED_REACT_ROUTER_ACTION_TYPES.DECREMENT:
            return state - 1;
        default:
            return state;
    }
};

export { connectedReactRouterCounter };

```

# packages-modules/counter/browser/src/connected-react-router/redux/actions/index.ts

```ts
export * from './counter';

```

# packages-modules/counter/browser/src/connected-react-router/redux/actions/counter.ts

```ts
import { CONNECTED_REACT_ROUTER_ACTION_TYPES } from '../../constants';

export const increment = () => ({
    type: CONNECTED_REACT_ROUTER_ACTION_TYPES.INCREMENT,
});

export const decrement = () => ({
    type: CONNECTED_REACT_ROUTER_ACTION_TYPES.DECREMENT,
});

```

# packages-modules/counter/browser/src/connected-react-router/__tests__/__snapshots__/connected-react-router-module.test.ts.snap

```snap
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`connector modules module configuredRoutes 1`] = `
Array [
  Object {
    "component": [Function],
    "exact": true,
    "path": "/connected-react-router",
    "routes": Array [
      Object {
        "component": [Function],
        "exact": true,
        "path": "/connected-react-router/hello",
      },
      Object {
        "component": Object {
          "$$typeof": Symbol(react.memo),
          "WrappedComponent": [Function],
          "compare": null,
          "displayName": "Connect(Counter)",
          "type": [Function],
        },
        "exact": true,
        "path": "/connected-react-router/counter",
      },
    ],
  },
]
`;

exports[`connector modules module routes 1`] = `
<Switch>
  <Route
    exact={true}
    path="/connected-react-router"
    render={[Function]}
  />
</Switch>
`;

```

# packages-modules/counter/browser/src/apollo-server-n-client/redux/reducers/index.ts

```ts
const defaultState = {
    reduxCount: 1,
};

export const reducers = function (state = defaultState, action) {
    switch (action.type) {
        case 'COUNTER_INCREMENT':
            return {
                ...state,
                reduxCount: state.reduxCount + action.value,
            };

        default:
            return state;
    }
};

```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/subscriptions/CounterSubscription.gql

```gql
subscription onCounterUpdated {
  counterUpdated {
    amount
  }
}

```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/schema/counter-state.graphql

```graphql

type ClientCounter {
    counter: Int
}

extend type Query {
    counterState: ClientCounter
}
extend type Mutation {
    addCounterState(amount: Int!): ClientCounter
}
```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/resolvers/resolvers.ts

```ts
/* eslint-disable import/no-unresolved */
/* eslint-disable import/no-extraneous-dependencies */
import { IClientStateDefault } from '@common-stack/client-core';
import { InMemoryCache } from '@apollo/client/cache';
import { CounterStateDocument } from '../../../generated-models';

const TYPE_NAME = 'CounterState';

const stateDefault: IClientStateDefault = {
    type: 'query',
    query: CounterStateDocument,
    data: {
        counterState: {
            counter: 1,
            __typename: TYPE_NAME,
        },
    },
};

const resolvers = {
    Query: {
        counterState: (_, args, { cache }) => {
            const {
                counterState: { counter },
            } = cache.readQuery({ query: CounterStateDocument });
            return {
                counter,
                __typename: TYPE_NAME,
            };
        },
    },
    Mutation: {
        addCounterState: async (_, { amount }, { cache }: { cache: InMemoryCache }) => {
            const {
                counterState: { counter },
            } = cache.readQuery({ query: CounterStateDocument });
            const newAmount = amount + counter;

            await cache.writeQuery({
                query: CounterStateDocument,
                data: {
                    counterState: {
                        counter: newAmount,
                        __typename: TYPE_NAME,
                    },
                },
            });

            return null;
        },
    },
};

export { stateDefault, resolvers };

```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/resolvers/index.ts

```ts
export * from './resolvers';

```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/queries/CounterQuery.gql

```gql
query counterQuery {
  counter {
    amount
  }
}

```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/queries/CounterQuery.client.gql

```gql
query CounterState {
    counterState @client {
        counter
    }
}
```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/queries/CounterCacheQuery_WS.gql

```gql
query counterCacheQuery {
  counterCache {
    amount
  }
}

```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/mutations/SyncCachedCounter.gql

```gql
mutation SyncCachedCounter {
  syncCachedCounter
}

```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/mutations/AddCounter_WS.gql

```gql
mutation AddCounter_WS($amount: Int!) {
  addCounter(amount: $amount) {
    amount
  }
}

```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/mutations/AddCounter.gql

```gql
mutation addCounter($amount: Int!) {
  addCounter(amount: $amount) {
    amount
  }
}

```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/mutations/AddCounter.client.gql

```gql
mutation addCounterState($amount: Int!) {
    addCounterState(amount: $amount) @client {
        counter
    }
}
```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/__tests__/apollo-client.test.ts

```ts
import { client } from './apollo-client-test-helper';
import { AddCounterDocument } from '../../../generated-models';
import 'jest';

describe('Apollo Client tests', () => {
    it('client test', async () => {
        const result = await client.mutate({
            mutation: AddCounterDocument,
            variables: { amount: 1 },
            // data: {},
        });
        expect(result).toEqual({ data: { addCounterState: null }, errors: undefined });
    });
});

```

# packages-modules/counter/browser/src/apollo-server-n-client/graphql/__tests__/apollo-client-test-helper.ts

```ts
/* eslint-disable no-use-before-define */
/* eslint-disable import/no-extraneous-dependencies */
import { ApolloClient, ApolloClientOptions, ApolloLink } from '@apollo/client';
import { InMemoryCache } from '@apollo/client/cache';
// import * as schema from '../schema/schema.graphql';
import { resolvers } from '../resolvers';
import { dataIdFromObject } from '../id-generation';

const defaultSchema = `
type Query {
    dummy: Int
}
type Mutation {
    dummy: Int
}
`;

const cache = new InMemoryCache({
    dataIdFromObject: (object) => getDataIdFromObject(object),
});

const  params: ApolloClientOptions<any> = {
    cache,
    resolvers,
    // typeDefs: defaultSchema.concat(schema as any), // if client schema exist
};
const links = [];

const client = new ApolloClient({
    queryDeduplication: true,
    link: ApolloLink.from(links),
    cache,
});

function getDataIdFromObject(result: any) {
    if (dataIdFromObject[result.__typename]) {
        return dataIdFromObject[result.__typename](result);
    }
    return result.id || result._id;
}

export { client, getDataIdFromObject };

```

# packages/sample-platform/browser/src/redux/reducers/__tests__/sampleReducers.test.ts

```ts
import 'jest';
import { createStore, combineReducers } from 'redux';

import { reducers } from '../sampleReducers';
import { Store } from '../Store';

import { incrementCounter } from '../../actions';

describe('reducers/counter', () => {
    it('starts at 0', () => {
        const store = createStore(combineReducers<Store.Sample>(reducers));
        const counter = store.getState()['@sample-stack/counter'];
        expect(counter.value).toEqual(0);
    });

    it('increments', (done) => {
        const store = createStore(combineReducers<Store.Sample>(reducers));
        store.subscribe(() => {
            const counter = store.getState()['@sample-stack/counter'];
            expect(counter.value).toEqual(3);
            done();
        });
        store.dispatch(incrementCounter(3));
    });

    it('restores state', (done) => {
        const store = createStore(combineReducers<Store.Sample>(reducers));
        store.subscribe(() => {
            const counter = store.getState()['@sample-stack/counter'];
            expect(counter.value).toEqual(14);
            done();
        });
        store.dispatch({
            type: '@@sample-stack/LOAD_COUNT_SUCCESS',
            request: {},
            response: { value: 14 },
        });
    });
});

```

# packages/sample-platform/browser/src/redux/actions/__tests__/sampleActions.test.ts

```ts
import 'jest';

import { createStore } from 'redux';
import * as apiExports from '../../api';
import * as actions from '../sampleActions';

jest.mock('../../api');

const api: jest.Mocked<apiExports.Api> = apiExports.api as any;

describe('actions', () => {
    const store = () => {
        const reducer = jest.fn();
        const { dispatch } = createStore(reducer);
        reducer.mockReset(); // ignore @@redux/INIT
        return { dispatch, reducer };
    };

    const eventually = (assertFn) =>
        new Promise((resolve, reject) => {
            setTimeout(() => {
                try {
                    assertFn();
                } catch (e) {
                    return reject(e);
                }
                resolve();
            }, 1);
        });

    const expectTypes = (reducer, types) => () =>
        expect(reducer.mock.calls.map((x) => x[1].type)).toEqual(types);

    describe('.saveCount', () => {
        beforeEach(() => {
            api.save.mockReturnValue(Promise.resolve(null));
        });

        it('sends an API request', () => {
            actions.saveCount({ value: 14 })(jest.fn());
            expect(api.save.mock.calls).toHaveLength(1);
        });

        describe('when API request succeeds', () => {
            it('dispatches @@sample-stack/SAVE_COUNT_SUCCESS', () => {
                const { dispatch, reducer } = store();
                actions.saveCount({ value: 14 })(dispatch);
                return eventually(
                    expectTypes(reducer, [
                        '@@sample-stack/SAVE_COUNT_REQUEST',
                        '@@sample-stack/SAVE_COUNT_SUCCESS',
                    ]),
                );
            });
        });

        describe('when API request fails', () => {
            beforeEach(() => {
                api.save.mockReturnValue(
                    Promise.reject(new Error('something terrible happened')),
                );
            });

            it('dispatches @@sample-stack/SAVE_COUNT_ERROR', () => {
                const { dispatch, reducer } = store();
                actions.saveCount({ value: 14 })(dispatch);
                return eventually(
                    expectTypes(reducer, [
                        '@@sample-stack/SAVE_COUNT_REQUEST',
                        '@@sample-stack/SAVE_COUNT_ERROR',
                    ]),
                );
            });

            it('includes error message with @@sample-stack/SAVE_COUNT_ERROR', () => {
                const { dispatch, reducer } = store();
                actions.saveCount({ value: 14 })(dispatch);
                return eventually(() => {
                    expect(reducer.mock.calls[1][1].error.message).toEqual(
                        'something terrible happened',
                    );
                });
            });

            it('includes request with @@sample-stack/SAVE_COUNT_ERROR for convenience', () => {
                const { dispatch, reducer } = store();
                actions.saveCount({ value: 14 })(dispatch);
                return eventually(() => {
                    expect(reducer.mock.calls[1][1].request).toEqual({
                        value: 14,
                    });
                });
            });
        });
    });

    describe('.loadCount', () => {
        beforeEach(() => {
            api.load.mockReturnValue(Promise.resolve({ value: 14 }));
        });

        it('sends an API request', () => {
            actions.loadCount(null)(jest.fn());
            expect(api.load.mock.calls).toHaveLength(1);
        });

        describe('when API request succeeds', () => {
            it('dispatches @sample-stack/LOAD_COUNT_SUCCESS', () => {
                const { dispatch, reducer } = store();
                actions.loadCount(null)(dispatch);
                return eventually(
                    expectTypes(reducer, [
                        '@@sample-stack/LOAD_COUNT_REQUEST',
                        '@@sample-stack/LOAD_COUNT_SUCCESS',
                    ]),
                );
            });

            it('includes new value with LOAD_COUNT_SUCCESS', () => {
                const { dispatch, reducer } = store();
                actions.loadCount(null)(dispatch);
                return eventually(() => {
                    expect(reducer.mock.calls[1][1].response).toEqual({
                        value: 14,
                    });
                });
            });
        });

        describe('when API request fails', () => {
            beforeEach(() => {
                api.load.mockReturnValue(
                    Promise.reject(new Error('something terrible happened')),
                );
            });

            it('dispatches @@sample-stack/LOAD_COUNT_ERROR', () => {
                const { dispatch, reducer } = store();
                actions.loadCount(null)(dispatch);
                return eventually(
                    expectTypes(reducer, [
                        '@@sample-stack/LOAD_COUNT_REQUEST',
                        '@@sample-stack/LOAD_COUNT_ERROR',
                    ]),
                );
            });

            it('includes error message with @@sample-stack/LOAD_COUNT_ERROR', () => {
                const { dispatch, reducer } = store();
                actions.loadCount(null)(dispatch);
                return eventually(() => {
                    expect(reducer.mock.calls[1][1].error.message).toEqual(
                        'something terrible happened',
                    );
                });
            });
        });
    });
});

```

# packages/sample-platform/browser/src/containers/__tests__/__snapshots__/PersonList.test.tsx.snap

```snap
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`components/PersonList renders correctly 1`] = `
ShallowWrapper {
  "complexSelector": ComplexSelector {
    "buildPredicate": [Function],
    "childrenOfNode": [Function],
    "findWhereUnwrapped": [Function],
  },
  "length": 1,
  "node": <ApolloProvider
    client={
        ApolloClient {
            "addTypename": true,
            "dataId": [Function],
            "dataIdFromObject": [Function],
            "disableNetworkFetches": false,
            "fieldWithArgs": [Function],
            "fragmentMatcher": HeuristicFragmentMatcher {},
            "initialState": Object {},
            "middleware": [Function],
            "mutate": [Function],
            "networkInterface": MockNetworkInterface {
              "mockedResponsesByKey": Object {},
            },
            "query": [Function],
            "queryDeduplication": true,
            "reducerConfig": Object {
              "addTypename": true,
              "customResolvers": undefined,
              "dataIdFromObject": [Function],
              "fragmentMatcher": [Function],
            },
            "resetStore": [Function],
            "setStore": [Function],
            "ssrMode": false,
            "version": "local",
            "watchQuery": [Function],
          }
    }
    store={null}
>
    <Apollo(flattenProp(pure(PersonListComponent))) />
</ApolloProvider>,
  "nodes": Array [
    <ApolloProvider
      client={
            ApolloClient {
                  "addTypename": true,
                  "dataId": [Function],
                  "dataIdFromObject": [Function],
                  "disableNetworkFetches": false,
                  "fieldWithArgs": [Function],
                  "fragmentMatcher": HeuristicFragmentMatcher {},
                  "initialState": Object {},
                  "middleware": [Function],
                  "mutate": [Function],
                  "networkInterface": MockNetworkInterface {
                    "mockedResponsesByKey": Object {},
                  },
                  "query": [Function],
                  "queryDeduplication": true,
                  "reducerConfig": Object {
                    "addTypename": true,
                    "customResolvers": undefined,
                    "dataIdFromObject": [Function],
                    "fragmentMatcher": [Function],
                  },
                  "resetStore": [Function],
                  "setStore": [Function],
                  "ssrMode": false,
                  "version": "local",
                  "watchQuery": [Function],
                }
      }
      store={null}
>
      <Apollo(flattenProp(pure(PersonListComponent))) />
</ApolloProvider>,
  ],
  "options": Object {},
  "renderer": ReactShallowRenderer {
    "_instance": ShallowComponentWrapper {
      "_calledComponentWillUnmount": false,
      "_compositeType": 0,
      "_context": Object {},
      "_currentElement": <MockedProvider>
        <Apollo(flattenProp(pure(PersonListComponent))) />
</MockedProvider>,
      "_debugID": 1,
      "_hostContainerInfo": null,
      "_hostParent": null,
      "_instance": MockedProvider {
        "_reactInternalInstance": [Circular],
        "client": ApolloClient {
          "addTypename": true,
          "dataId": [Function],
          "dataIdFromObject": [Function],
          "disableNetworkFetches": false,
          "fieldWithArgs": [Function],
          "fragmentMatcher": HeuristicFragmentMatcher {},
          "initialState": Object {},
          "middleware": [Function],
          "mutate": [Function],
          "networkInterface": MockNetworkInterface {
            "mockedResponsesByKey": Object {},
          },
          "query": [Function],
          "queryDeduplication": true,
          "reducerConfig": Object {
            "addTypename": true,
            "customResolvers": undefined,
            "dataIdFromObject": [Function],
            "fragmentMatcher": [Function],
          },
          "resetStore": [Function],
          "setStore": [Function],
          "ssrMode": false,
          "version": "local",
          "watchQuery": [Function],
        },
        "context": Object {},
        "props": Object {
          "children": <Apollo(flattenProp(pure(PersonListComponent))) />,
        },
        "refs": Object {},
        "state": null,
        "updater": Object {
          "enqueueCallback": [Function],
          "enqueueCallbackInternal": [Function],
          "enqueueElementInternal": [Function],
          "enqueueForceUpdate": [Function],
          "enqueueReplaceState": [Function],
          "enqueueSetState": [Function],
          "isMounted": [Function],
          "validateCallback": [Function],
        },
      },
      "_mountOrder": 1,
      "_pendingCallbacks": null,
      "_pendingElement": null,
      "_pendingForceUpdate": false,
      "_pendingReplaceState": false,
      "_pendingStateQueue": null,
      "_renderedComponent": NoopInternalComponent {
        "_currentElement": <ApolloProvider
          client={
                    ApolloClient {
                              "addTypename": true,
                              "dataId": [Function],
                              "dataIdFromObject": [Function],
                              "disableNetworkFetches": false,
                              "fieldWithArgs": [Function],
                              "fragmentMatcher": HeuristicFragmentMatcher {},
                              "initialState": Object {},
                              "middleware": [Function],
                              "mutate": [Function],
                              "networkInterface": MockNetworkInterface {
                                "mockedResponsesByKey": Object {},
                              },
                              "query": [Function],
                              "queryDeduplication": true,
                              "reducerConfig": Object {
                                "addTypename": true,
                                "customResolvers": undefined,
                                "dataIdFromObject": [Function],
                                "fragmentMatcher": [Function],
                              },
                              "resetStore": [Function],
                              "setStore": [Function],
                              "ssrMode": false,
                              "version": "local",
                              "watchQuery": [Function],
                            }
          }
          store={null}
>
          <Apollo(flattenProp(pure(PersonListComponent))) />
</ApolloProvider>,
        "_debugID": 2,
        "_renderedOutput": <ApolloProvider
          client={
                    ApolloClient {
                              "addTypename": true,
                              "dataId": [Function],
                              "dataIdFromObject": [Function],
                              "disableNetworkFetches": false,
                              "fieldWithArgs": [Function],
                              "fragmentMatcher": HeuristicFragmentMatcher {},
                              "initialState": Object {},
                              "middleware": [Function],
                              "mutate": [Function],
                              "networkInterface": MockNetworkInterface {
                                "mockedResponsesByKey": Object {},
                              },
                              "query": [Function],
                              "queryDeduplication": true,
                              "reducerConfig": Object {
                                "addTypename": true,
                                "customResolvers": undefined,
                                "dataIdFromObject": [Function],
                                "fragmentMatcher": [Function],
                              },
                              "resetStore": [Function],
                              "setStore": [Function],
                              "ssrMode": false,
                              "version": "local",
                              "watchQuery": [Function],
                            }
          }
          store={null}
>
          <Apollo(flattenProp(pure(PersonListComponent))) />
</ApolloProvider>,
      },
      "_renderedNodeType": 1,
      "_rootNodeID": 0,
      "_topLevelWrapper": null,
      "_updateBatchNumber": null,
      "_warnedAboutRefsInRender": false,
    },
    "getRenderOutput": [Function],
    "render": [Function],
  },
  "root": [Circular],
  "unrendered": <MockedProvider>
    <Apollo(flattenProp(pure(PersonListComponent))) />
</MockedProvider>,
}
`;

```

# packages/sample-platform/browser/src/containers/__tests__/__snapshots__/Counter.test.tsx.snap

```snap
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`components/Counter renders 1`] = `
ShallowWrapper {
  "complexSelector": ComplexSelector {
    "buildPredicate": [Function],
    "childrenOfNode": [Function],
    "findWhereUnwrapped": [Function],
  },
  "length": 1,
  "node": <form>
    <legend>
        a counter!
    </legend>
    <pre>
        {
          "counter": {
            "value": 0
          },
          "isSaving": false,
          "isLoading": false
        }
    </pre>
    <button
        onClick={[Function]}
    >
        click me!
    </button>
    <button
        disabled={false}
        onClick={[Function]}
    >
        save
    </button>
    <button
        disabled={false}
        onClick={[Function]}
    >
        load
    </button>
</form>,
  "nodes": Array [
    <form>
      <legend>
            a counter!
      </legend>
      <pre>
            {
              "counter": {
                "value": 0
              },
              "isSaving": false,
              "isLoading": false
            }
      </pre>
      <button
            onClick={[Function]}
      >
            click me!
      </button>
      <button
            disabled={false}
            onClick={[Function]}
      >
            save
      </button>
      <button
            disabled={false}
            onClick={[Function]}
      >
            load
      </button>
</form>,
  ],
  "options": Object {},
  "renderer": ReactShallowRenderer {
    "_instance": ShallowComponentWrapper {
      "_calledComponentWillUnmount": false,
      "_compositeType": 0,
      "_context": Object {},
      "_currentElement": <CounterComponent
        counter={
                Object {
                        "value": 0,
                      }
        }
        error=""
        increment={[Function]}
        isLoading={false}
        isSaving={false}
        label="a counter!"
        load={[Function]}
        save={[Function]}
        store={
                Object {
                        "dispatch": [Function],
                        "getState": [Function],
                        "replaceReducer": [Function],
                        "subscribe": [Function],
                        Symbol(observable): [Function],
                      }
        }
        storeSubscription={
                Subscription {
                        "listeners": Object {
                          "notify": [Function],
                        },
                        "onStateChange": [Function],
                        "parentSub": undefined,
                        "store": Object {
                          "dispatch": [Function],
                          "getState": [Function],
                          "replaceReducer": [Function],
                          "subscribe": [Function],
                          Symbol(observable): [Function],
                        },
                        "unsubscribe": null,
                      }
        }
/>,
      "_debugID": 3,
      "_hostContainerInfo": null,
      "_hostParent": null,
      "_instance": CounterComponent {
        "_onClickIncrement": [Function],
        "_onClickLoad": [Function],
        "_onClickSave": [Function],
        "_reactInternalInstance": [Circular],
        "context": Object {},
        "props": Object {
          "counter": Object {
            "value": 0,
          },
          "error": "",
          "increment": [Function],
          "isLoading": false,
          "isSaving": false,
          "label": "a counter!",
          "load": [Function],
          "save": [Function],
          "store": Object {
            "dispatch": [Function],
            "getState": [Function],
            "replaceReducer": [Function],
            "subscribe": [Function],
            Symbol(observable): [Function],
          },
          "storeSubscription": Subscription {
            "listeners": Object {
              "notify": [Function],
            },
            "onStateChange": [Function],
            "parentSub": undefined,
            "store": Object {
              "dispatch": [Function],
              "getState": [Function],
              "replaceReducer": [Function],
              "subscribe": [Function],
              Symbol(observable): [Function],
            },
            "unsubscribe": null,
          },
        },
        "refs": Object {},
        "state": null,
        "updater": Object {
          "enqueueCallback": [Function],
          "enqueueCallbackInternal": [Function],
          "enqueueElementInternal": [Function],
          "enqueueForceUpdate": [Function],
          "enqueueReplaceState": [Function],
          "enqueueSetState": [Function],
          "isMounted": [Function],
          "validateCallback": [Function],
        },
      },
      "_mountOrder": 2,
      "_pendingCallbacks": null,
      "_pendingElement": null,
      "_pendingForceUpdate": false,
      "_pendingReplaceState": false,
      "_pendingStateQueue": null,
      "_renderedComponent": NoopInternalComponent {
        "_currentElement": <form>
          <legend>
                    a counter!
          </legend>
          <pre>
                    {
                      "counter": {
                        "value": 0
                      },
                      "isSaving": false,
                      "isLoading": false
                    }
          </pre>
          <button
                    onClick={[Function]}
          >
                    click me!
          </button>
          <button
                    disabled={false}
                    onClick={[Function]}
          >
                    save
          </button>
          <button
                    disabled={false}
                    onClick={[Function]}
          >
                    load
          </button>
</form>,
        "_debugID": 4,
        "_renderedOutput": <form>
          <legend>
                    a counter!
          </legend>
          <pre>
                    {
                      "counter": {
                        "value": 0
                      },
                      "isSaving": false,
                      "isLoading": false
                    }
          </pre>
          <button
                    onClick={[Function]}
          >
                    click me!
          </button>
          <button
                    disabled={false}
                    onClick={[Function]}
          >
                    save
          </button>
          <button
                    disabled={false}
                    onClick={[Function]}
          >
                    load
          </button>
</form>,
      },
      "_renderedNodeType": 0,
      "_rootNodeID": 0,
      "_topLevelWrapper": null,
      "_updateBatchNumber": null,
      "_warnedAboutRefsInRender": false,
    },
    "getRenderOutput": [Function],
    "render": [Function],
  },
  "root": [Circular],
  "unrendered": <CounterComponent
    counter={
        Object {
            "value": 0,
          }
    }
    error=""
    increment={[Function]}
    isLoading={false}
    isSaving={false}
    label="a counter!"
    load={[Function]}
    save={[Function]}
    store={
        Object {
            "dispatch": [Function],
            "getState": [Function],
            "replaceReducer": [Function],
            "subscribe": [Function],
            Symbol(observable): [Function],
          }
    }
    storeSubscription={
        Subscription {
            "listeners": Object {
              "notify": [Function],
            },
            "onStateChange": [Function],
            "parentSub": undefined,
            "store": Object {
              "dispatch": [Function],
              "getState": [Function],
              "replaceReducer": [Function],
              "subscribe": [Function],
              Symbol(observable): [Function],
            },
            "unsubscribe": null,
          }
    }
/>,
}
`;

```

